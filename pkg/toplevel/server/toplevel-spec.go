// Code generated by GENERATOR. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	externalRef0 "github.com/onosproject/aether-roc-api/pkg/aether_2_0_0/server"
	externalRef1 "github.com/onosproject/aether-roc-api/pkg/aether_4_0_0/server"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8xZfW/bONL/KgPtA+wuHsuy0+Bw58MB502zWWPTJGjcAoc6KGhpZLGVSC1JOfUW/u6H",
	"ISlbkuW8tDnc/eeInN+8ct7yNYhlUUqBwuhg8jXQcYYFsz/PMiZWSL8S1LHipeFSBJNAYalQEwEwiKVI",
	"+apSjA4htiRgJDDQXKxyBMPUCk0wCEolS1SGowV3nz/y5BDfZAg8QWF4ylGBTIG+OAKCvs94nIHJuK75",
	"sbLMCXcQmE2JwSTQRnGxCraDmo/73uXEBEj7m+U7/E2JDSbSYm+a3B7gskalLfITGPm7z+e1ZnnlbNjh",
	"ARoNWcsbxd3bwQaDgBssLOH/KUyDSfBDtPd95B0fOa+/J2KrmWPPlGKbYLsdBAr/qLjCJJh8aDjxbndT",
	"Lj9hbIi0idRnES4SvuZJxXK4YSaL7E1gIgGFhVxjAmnOVhDLYsmFiy8ugMFZbZp2RJXMZP3BRCdkh+M2",
	"9QwPyUnGmBnUcJ+hyVA573AK/QRzNA24pZQ5MrHzUb8wTe8citIxsNWpz7bnORb1k22bwb6F2JorPB2O",
	"hqOGw4cRs0q4g1CWKFjJXw03rMh7g2G6ByOusRQCY8PX3GxCjWrNY/x+Jmc9qMe46fDkGLuT72CniV+C",
	"Vp+VklX5/Vq9bqAROgqDqlRcv4DFzndYbeQXsM4e2tqEl2EiC8ZfIJZmNRTham5ewA633LgkhUWZs5dA",
	"nHski6pYmvI4jHOm9QtAN+EIvyrT70d9V6Y24cQvIOH7WAdbSkE3zMTZLzLZHKaX1zbpPVpFdvmJctUX",
	"g4JqXU/ReiMTzF3RpcRfF0WZwo+uuPwIUkDKlTYQK3RV4EPOxee7nzJjSj2JokTGeiiF1KWSlB+HUq0i",
	"+jt0zYm9EK1EwT/iTpToh0pjKNNw9ykcj8ahzwFejpCLUKOhjIza/HxQclwuDwUrMByPRk69UiFVjCSY",
	"GFXhIDDc5JS8u5d7ylBB1gjpczgenTwM17l7FK1WZTwaPwWweb2v0VFMaBYbZ5xUhuPx6NCr7zQmVKup",
	"3inUpRQa9QBiphRHDUSoWGF9yZayMq7B20MPDyzt+sQDcbhI8EvjhAuDK1S2jtZ69YrcU1Kb97RRzOBq",
	"E47H40P1ZnVzuu8KGPggAYGY2K5riZAxkeSoYao3Is6UFLLS+QZ+WrN8AqOfQSq47TkZU6T1id8Sa/CQ",
	"0hTtsI/2Pn3flQl75ktOMGVVbkLf0x8YZu5a25/cKwIK9Z/JFJVGWG7AkwNPQUgDusSYrJiA9M2g7QUr",
	"J1fk2isNTAMTwJKE+wbaRwZ1tCUzBhWx/jAK/8bCPxeLcLEYfrz7/0dbq44ud9uBF/+KFXiY94T/2gXd",
	"kWmic7H6lDa7weugyx4E873Te6y8PwSFKSrX5ENR5YaH9Ryzv8Ry33QOYc4+o4BUyQLq7LniJquWw1gW",
	"USOHuvzJSh4ZhRgVTBtUUamkkfYo8ql1fXIkKT4+oOjGxCP9VKSfN6UcmG4QfAk/40bTu9nNJtRKUunA",
	"I7Om4QUCM7u5spWK4J5pqMkHQSpVwUwwCShGQ6Lsy5IudJM+E9iRxk8VXKzaY0WTL9ewRLrhwegBMdCC",
	"lTqTpnfqSLBEkaCIN32cbaigiO1429WSFN2P1R05alzTr6s/7PV4zrV1+Y659XoDX4PJmPEsSIyuAM2I",
	"eEJN2PZl9iMh4mLj2AqiEvyPqncT0RLueE3q2qKQQhopeMzyfANcUFRpLlYDWOVyaT/WPAmiZrebWnex",
	"x4X5y2lP/qcEt+b9G4jG6FlfAlEVS1RPQ9aGmUofwa2UQmEg5ynGmzhHcLf7DdaZ2jOm8WFYe6UfC0VV",
	"UDKfv51e3U7P5rPrq49nv02vLs6DQevj2+vLy1+mZ783hum9x0jaIzLYox7ecM9NZrcRN1aBflFuzq9e",
	"z64uOrKcXb+5uTyfd0X8dTq7PH/d+fh+ejl7PZ0fgviDowR7wLtHlwxeA2eGvm2DK8nfnD5zpg3UGE/N",
	"oZVGVRfdQ6Z0UruFbrosUrAEH3+iHfU5yeQebeMB3bWr8CXX5um1vcH9cIVmU0QqbamUwrDYAmPBeG6f",
	"XCr/SaOaQHMv1WcuVjTPBAPfgQTXJQq42h3Cr7ISCfOaVoow6tLeA2MTdquZyBAWwdQVobks4RLXmC8C",
	"iJmgFraiVj6Vypr1Zjo/+w1iWRRMJMOFmBlgeS7vNWhco2J57ZK3qGWlKNv7D3a4qDu+mIYCf+4aZYLk",
	"xripQQps8Lg4n2vQmazyBMheXFToqRK6aTIlq5ULvMZG8e357XzPZrgQC7GoRqNXCHO7wBMGVcpiBP+H",
	"SDDxsFZlKfINlVz8QsnKxpgewszQfXthubEsL97NiKxgn9E1YGWOCwFeI8KGcWu0ARyuhq6ok/sKJjYN",
	"czADUsRIA1DOYxQuN3rXT0sWZxieDEctV0+i6P7+fsjsqR1+PamOLmdn51e355akMR103R0Mgt3qOnAr",
	"pO0g8AuDYBK8sp9su53Z6K83C0rGob1i16+x3b9SdrfxOEuCiVslzGVZ8/FjUr1cII9SY9FeXEaftKth",
	"7kU99t7264rt1r1uP3IS4cmoZ0C1wmJic4GuioKpDclqw5v5cVSWkJPQFMIddYks0kksFUb1aMf/xOir",
	"XydunUEUK9Cg0sHkQ0tTg19MVOaMi79TTVYazT8qk4Z/bavcM2q0tXASgGfqcqKNLncQsoSVBlW4PrUZ",
	"zumd7VNJvWtt5kOjKtzeDYJSuoTX9uatBb6pdHZm+/+WYx8zesNSB5a/vp3DwxZ1Ni8xJmA/fXaEKzF+",
	"RKAj4bZhRf5M21+cz+H6dyDctip0YOUESq27JwYkHWWDf03fXIIrgUO4JZfRgOviy8gytDHXXtbtdX9g",
	"m/ugWdyDP7Fbp/+2XR7QwZrMJyd7bCvGofqn36T+6f+U+qcPq3/aUb+ej4+p6ZcQ3xb/z0u3rX3Hs23g",
	"FYHpbjb8VGlT/1dUeFDSuDEkHlX7As28ee8/qXanG3y+5m1BDVtpOzB0cO+oiP07AAD//0BYjneXHwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "./aether-2.0.0-openapi3.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(pathPrefix, "./aether-4.0.0-openapi3.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
