// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	"reflect"
	"regexp"

	"github.com/onosproject/aether-roc-api/pkg/aether_3_0_0/types"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	externalRef0 "github.com/onosproject/config-models/modelplugin/aether-3.0.0/aether_3_0_0"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertyTarget

// EncodeToGnmiApList converts OAPI to gNMI.
func EncodeToGnmiApList(
	jsonObj *types.ApList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: ap-list []ApListApList
	if jsonObj.ApList != nil {

	}

	// Property: ap-list []ApListApList
	if jsonObj.ApList != nil {
		for _, item := range *jsonObj.ApList {
			item := item //Pinning
			paramsApList := make([]string, len(params))
			copy(paramsApList, params)
			paramsApList = append(paramsApList, "unknown_id")
			updatesApList, err :=
				EncodeToGnmiApListApList(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "ap-list"), paramsApList...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesApList...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApList", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApListApList converts OAPI to gNMI.
func EncodeToGnmiApListApList(
	jsonObj *types.ApListApList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: access-points []ApListApListAccessPoints
	if jsonObj.AccessPoints != nil {

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApListApListDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApListApListDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	if !removeIndex {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApListApListEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApListApListId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: access-points []ApListApListAccessPoints
	if jsonObj.AccessPoints != nil {
		for _, item := range *jsonObj.AccessPoints {
			item := item //Pinning
			paramsAccessPoints := make([]string, len(params))
			copy(paramsAccessPoints, params)
			paramsAccessPoints = append(paramsAccessPoints, "unknown_id")
			updatesAccessPoints, err :=
				EncodeToGnmiApListApListAccessPoints(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "access-points"), paramsAccessPoints...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesAccessPoints...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApListApList", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApListApListAccessPoints converts OAPI to gNMI.
func EncodeToGnmiApListApListAccessPoints(
	jsonObj *types.ApListApListAccessPoints, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if jsonObj.Address != nil {

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", *jsonObj.Address)
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApListApListAccessPointsAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil {

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)
		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApListApListAccessPointsEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: tac int32
	if !removeIndex {

		paramsTac := make([]string, len(params))
		copy(paramsTac, params)
		stringValTac := fmt.Sprintf("%v", jsonObj.Tac)
		paramsTac = append(paramsTac, stringValTac)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApListApListAccessPointsTac", paramsTac...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tac"), paramsTac...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApListApListAccessPoints", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplication converts OAPI to gNMI.
func EncodeToGnmiApplication(
	jsonObj *types.Application, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: application []ApplicationApplication
	if jsonObj.Application != nil {

	}

	// Property: application []ApplicationApplication
	if jsonObj.Application != nil {
		for _, item := range *jsonObj.Application {
			item := item //Pinning
			paramsApplication := make([]string, len(params))
			copy(paramsApplication, params)
			paramsApplication = append(paramsApplication, "unknown_id")
			updatesApplication, err :=
				EncodeToGnmiApplicationApplication(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "application"), paramsApplication...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesApplication...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Application", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationApplication converts OAPI to gNMI.
func EncodeToGnmiApplicationApplication(
	jsonObj *types.ApplicationApplication, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint []ApplicationApplicationEndpoint
	if jsonObj.Endpoint != nil {

	}
	// Property: enterprise string
	if !removeIndex {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: endpoint []ApplicationApplicationEndpoint
	if jsonObj.Endpoint != nil {
		for _, item := range *jsonObj.Endpoint {
			item := item //Pinning
			paramsEndpoint := make([]string, len(params))
			copy(paramsEndpoint, params)
			paramsEndpoint = append(paramsEndpoint, "unknown_id")
			updatesEndpoint, err :=
				EncodeToGnmiApplicationApplicationEndpoint(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "endpoint"), paramsEndpoint...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEndpoint...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApplicationApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationApplicationEndpoint converts OAPI to gNMI.
func EncodeToGnmiApplicationApplicationEndpoint(
	jsonObj *types.ApplicationApplicationEndpoint, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if !removeIndex {

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: name string
	if jsonObj.Name != nil {

		paramsName := make([]string, len(params))
		copy(paramsName, params)
		stringValName := fmt.Sprintf("%v", *jsonObj.Name)
		paramsName = append(paramsName, stringValName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointName", paramsName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/name"), paramsName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port-end int32
	if jsonObj.PortEnd != nil {

		paramsPortEnd := make([]string, len(params))
		copy(paramsPortEnd, params)
		stringValPortEnd := fmt.Sprintf("%v", *jsonObj.PortEnd)
		paramsPortEnd = append(paramsPortEnd, stringValPortEnd)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointPortEnd", paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-end"), paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port-start int32
	if !removeIndex {

		paramsPortStart := make([]string, len(params))
		copy(paramsPortStart, params)
		stringValPortStart := fmt.Sprintf("%v", jsonObj.PortStart)
		paramsPortStart = append(paramsPortStart, stringValPortStart)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointPortStart", paramsPortStart...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-start"), paramsPortStart...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: protocol string
	if jsonObj.Protocol != nil {

		paramsProtocol := make([]string, len(params))
		copy(paramsProtocol, params)
		stringValProtocol := fmt.Sprintf("%v", *jsonObj.Protocol)
		paramsProtocol = append(paramsProtocol, stringValProtocol)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointProtocol", paramsProtocol...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/protocol"), paramsProtocol...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApplicationApplicationEndpoint", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityService(
	jsonObj *types.ConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service []ConnectivityServiceConnectivityService
	if jsonObj.ConnectivityService != nil {

	}

	// Property: connectivity-service []ConnectivityServiceConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiConnectivityServiceConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityServiceConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityServiceConnectivityService(
	jsonObj *types.ConnectivityServiceConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: core-5g-endpoint string
	if jsonObj.Core5gEndpoint != nil {

		paramsCore5gEndpoint := make([]string, len(params))
		copy(paramsCore5gEndpoint, params)
		stringValCore5gEndpoint := fmt.Sprintf("%v", *jsonObj.Core5gEndpoint)
		paramsCore5gEndpoint = append(paramsCore5gEndpoint, stringValCore5gEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceCore5gEndpoint", paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/core-5g-endpoint"), paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: hss-endpoint string
	if jsonObj.HssEndpoint != nil {

		paramsHssEndpoint := make([]string, len(params))
		copy(paramsHssEndpoint, params)
		stringValHssEndpoint := fmt.Sprintf("%v", *jsonObj.HssEndpoint)
		paramsHssEndpoint = append(paramsHssEndpoint, stringValHssEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceHssEndpoint", paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/hss-endpoint"), paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pcrf-endpoint string
	if jsonObj.PcrfEndpoint != nil {

		paramsPcrfEndpoint := make([]string, len(params))
		copy(paramsPcrfEndpoint, params)
		stringValPcrfEndpoint := fmt.Sprintf("%v", *jsonObj.PcrfEndpoint)
		paramsPcrfEndpoint = append(paramsPcrfEndpoint, stringValPcrfEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServicePcrfEndpoint", paramsPcrfEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pcrf-endpoint"), paramsPcrfEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: spgwc-endpoint string
	if jsonObj.SpgwcEndpoint != nil {

		paramsSpgwcEndpoint := make([]string, len(params))
		copy(paramsSpgwcEndpoint, params)
		stringValSpgwcEndpoint := fmt.Sprintf("%v", *jsonObj.SpgwcEndpoint)
		paramsSpgwcEndpoint = append(paramsSpgwcEndpoint, stringValSpgwcEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceSpgwcEndpoint", paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/spgwc-endpoint"), paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServiceConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiDeviceGroup(
	jsonObj *types.DeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-group []DeviceGroupDeviceGroup
	if jsonObj.DeviceGroup != nil {

	}

	// Property: device-group []DeviceGroupDeviceGroup
	if jsonObj.DeviceGroup != nil {
		for _, item := range *jsonObj.DeviceGroup {
			item := item //Pinning
			paramsDeviceGroup := make([]string, len(params))
			copy(paramsDeviceGroup, params)
			paramsDeviceGroup = append(paramsDeviceGroup, "unknown_id")
			updatesDeviceGroup, err :=
				EncodeToGnmiDeviceGroupDeviceGroup(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device-group"), paramsDeviceGroup...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDeviceGroup...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroupDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiDeviceGroupDeviceGroup(
	jsonObj *types.DeviceGroupDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsis []DeviceGroupDeviceGroupImsis
	if jsonObj.Imsis != nil {

	}
	// Property: ip-domain string
	if jsonObj.IpDomain != nil {

		paramsIpDomain := make([]string, len(params))
		copy(paramsIpDomain, params)
		stringValIpDomain := fmt.Sprintf("%v", *jsonObj.IpDomain)
		paramsIpDomain = append(paramsIpDomain, stringValIpDomain)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupIpDomain", paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-domain"), paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: site string
	if !removeIndex {

		paramsSite := make([]string, len(params))
		copy(paramsSite, params)
		stringValSite := fmt.Sprintf("%v", jsonObj.Site)
		paramsSite = append(paramsSite, stringValSite)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupSite", paramsSite...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/site"), paramsSite...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: imsis []DeviceGroupDeviceGroupImsis
	if jsonObj.Imsis != nil {
		for _, item := range *jsonObj.Imsis {
			item := item //Pinning
			paramsImsis := make([]string, len(params))
			copy(paramsImsis, params)
			paramsImsis = append(paramsImsis, "unknown_id")
			updatesImsis, err :=
				EncodeToGnmiDeviceGroupDeviceGroupImsis(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "imsis"), paramsImsis...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesImsis...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroupDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroupDeviceGroupImsis converts OAPI to gNMI.
func EncodeToGnmiDeviceGroupDeviceGroupImsis(
	jsonObj *types.DeviceGroupDeviceGroupImsis, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: imsi-range-from int64
	if jsonObj.ImsiRangeFrom != nil {

		paramsImsiRangeFrom := make([]string, len(params))
		copy(paramsImsiRangeFrom, params)
		stringValImsiRangeFrom := fmt.Sprintf("%v", *jsonObj.ImsiRangeFrom)
		paramsImsiRangeFrom = append(paramsImsiRangeFrom, stringValImsiRangeFrom)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupImsisImsiRangeFrom", paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-from"), paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-range-to int64
	if jsonObj.ImsiRangeTo != nil {

		paramsImsiRangeTo := make([]string, len(params))
		copy(paramsImsiRangeTo, params)
		stringValImsiRangeTo := fmt.Sprintf("%v", *jsonObj.ImsiRangeTo)
		paramsImsiRangeTo = append(paramsImsiRangeTo, stringValImsiRangeTo)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupImsisImsiRangeTo", paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-to"), paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: name string
	if jsonObj.Name != nil {

		paramsName := make([]string, len(params))
		copy(paramsName, params)
		stringValName := fmt.Sprintf("%v", *jsonObj.Name)
		paramsName = append(paramsName, stringValName)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupImsisName", paramsName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/name"), paramsName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroupDeviceGroupImsis", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterprise(
	jsonObj *types.Enterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise []EnterpriseEnterprise
	if jsonObj.Enterprise != nil {

	}

	// Property: enterprise []EnterpriseEnterprise
	if jsonObj.Enterprise != nil {
		for _, item := range *jsonObj.Enterprise {
			item := item //Pinning
			paramsEnterprise := make([]string, len(params))
			copy(paramsEnterprise, params)
			paramsEnterprise = append(paramsEnterprise, "unknown_id")
			updatesEnterprise, err :=
				EncodeToGnmiEnterpriseEnterprise(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "enterprise"), paramsEnterprise...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEnterprise...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Enterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterprise(
	jsonObj *types.EnterpriseEnterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service []EnterpriseEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil {

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: connectivity-service []EnterpriseEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiEnterpriseEnterpriseConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterpriseConnectivityService converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterpriseConnectivityService(
	jsonObj *types.EnterpriseEnterpriseConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service string
	if jsonObj.ConnectivityService != nil {

		paramsConnectivityService := make([]string, len(params))
		copy(paramsConnectivityService, params)
		stringValConnectivityService := fmt.Sprintf("%v", *jsonObj.ConnectivityService)
		paramsConnectivityService = append(paramsConnectivityService, stringValConnectivityService)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceConnectivityService", paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connectivity-service"), paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	if jsonObj.Enabled != nil {

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)
		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterpriseConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiIpDomain converts OAPI to gNMI.
func EncodeToGnmiIpDomain(
	jsonObj *types.IpDomain, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: ip-domain []IpDomainIpDomain
	if jsonObj.IpDomain != nil {

	}

	// Property: ip-domain []IpDomainIpDomain
	if jsonObj.IpDomain != nil {
		for _, item := range *jsonObj.IpDomain {
			item := item //Pinning
			paramsIpDomain := make([]string, len(params))
			copy(paramsIpDomain, params)
			paramsIpDomain = append(paramsIpDomain, "unknown_id")
			updatesIpDomain, err :=
				EncodeToGnmiIpDomainIpDomain(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "ip-domain"), paramsIpDomain...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesIpDomain...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "IpDomain", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiIpDomainIpDomain converts OAPI to gNMI.
func EncodeToGnmiIpDomainIpDomain(
	jsonObj *types.IpDomainIpDomain, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: admin-status string
	if jsonObj.AdminStatus != nil {

		paramsAdminStatus := make([]string, len(params))
		copy(paramsAdminStatus, params)
		stringValAdminStatus := fmt.Sprintf("%v", *jsonObj.AdminStatus)
		paramsAdminStatus = append(paramsAdminStatus, stringValAdminStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainAdminStatus", paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/admin-status"), paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-primary string
	if jsonObj.DnsPrimary != nil {

		paramsDnsPrimary := make([]string, len(params))
		copy(paramsDnsPrimary, params)
		stringValDnsPrimary := fmt.Sprintf("%v", *jsonObj.DnsPrimary)
		paramsDnsPrimary = append(paramsDnsPrimary, stringValDnsPrimary)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDnsPrimary", paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-primary"), paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-secondary string
	if jsonObj.DnsSecondary != nil {

		paramsDnsSecondary := make([]string, len(params))
		copy(paramsDnsSecondary, params)
		stringValDnsSecondary := fmt.Sprintf("%v", *jsonObj.DnsSecondary)
		paramsDnsSecondary = append(paramsDnsSecondary, stringValDnsSecondary)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDnsSecondary", paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-secondary"), paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	if !removeIndex {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mtu int32
	if jsonObj.Mtu != nil {

		paramsMtu := make([]string, len(params))
		copy(paramsMtu, params)
		stringValMtu := fmt.Sprintf("%v", *jsonObj.Mtu)
		paramsMtu = append(paramsMtu, stringValMtu)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainMtu", paramsMtu...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mtu"), paramsMtu...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: subnet string
	if !removeIndex {

		paramsSubnet := make([]string, len(params))
		copy(paramsSubnet, params)
		stringValSubnet := fmt.Sprintf("%v", jsonObj.Subnet)
		paramsSubnet = append(paramsSubnet, stringValSubnet)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainSubnet", paramsSubnet...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/subnet"), paramsSubnet...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "IpDomainIpDomain", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSite converts OAPI to gNMI.
func EncodeToGnmiSite(
	jsonObj *types.Site, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: site []SiteSite
	if jsonObj.Site != nil {

	}

	// Property: site []SiteSite
	if jsonObj.Site != nil {
		for _, item := range *jsonObj.Site {
			item := item //Pinning
			paramsSite := make([]string, len(params))
			copy(paramsSite, params)
			paramsSite = append(paramsSite, "unknown_id")
			updatesSite, err :=
				EncodeToGnmiSiteSite(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "site"), paramsSite...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSite...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Site", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSite converts OAPI to gNMI.
func EncodeToGnmiSiteSite(
	jsonObj *types.SiteSite, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	if !removeIndex {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-definition SiteSiteImsiDefinition
	if jsonObj.ImsiDefinition != nil {

		update, err := EncodeToGnmiSiteSiteImsiDefinition(
			jsonObj.ImsiDefinition, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "imsi-definition"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSite", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSiteImsiDefinition converts OAPI to gNMI.
func EncodeToGnmiSiteSiteImsiDefinition(
	jsonObj *types.SiteSiteImsiDefinition, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise int32
	if jsonObj.Enterprise != nil {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", *jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: format string
	if jsonObj.Format != nil {

		paramsFormat := make([]string, len(params))
		copy(paramsFormat, params)
		stringValFormat := fmt.Sprintf("%v", *jsonObj.Format)
		paramsFormat = append(paramsFormat, stringValFormat)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionFormat", paramsFormat...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/format"), paramsFormat...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mcc int32
	if jsonObj.Mcc != nil {

		paramsMcc := make([]string, len(params))
		copy(paramsMcc, params)
		stringValMcc := fmt.Sprintf("%v", *jsonObj.Mcc)
		paramsMcc = append(paramsMcc, stringValMcc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionMcc", paramsMcc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mcc"), paramsMcc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mnc int32
	if jsonObj.Mnc != nil {

		paramsMnc := make([]string, len(params))
		copy(paramsMnc, params)
		stringValMnc := fmt.Sprintf("%v", *jsonObj.Mnc)
		paramsMnc = append(paramsMnc, stringValMnc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionMnc", paramsMnc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mnc"), paramsMnc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSiteImsiDefinition", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTemplate converts OAPI to gNMI.
func EncodeToGnmiTemplate(
	jsonObj *types.Template, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: template []TemplateTemplate
	if jsonObj.Template != nil {

	}

	// Property: template []TemplateTemplate
	if jsonObj.Template != nil {
		for _, item := range *jsonObj.Template {
			item := item //Pinning
			paramsTemplate := make([]string, len(params))
			copy(paramsTemplate, params)
			paramsTemplate = append(paramsTemplate, "unknown_id")
			updatesTemplate, err :=
				EncodeToGnmiTemplateTemplate(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "template"), paramsTemplate...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesTemplate...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Template", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTemplateTemplate converts OAPI to gNMI.
func EncodeToGnmiTemplateTemplate(
	jsonObj *types.TemplateTemplate, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink int32
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sd int32
	if jsonObj.Sd != nil {

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", *jsonObj.Sd)
		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sst int32
	if jsonObj.Sst != nil {

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", *jsonObj.Sst)
		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil {

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)
		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int32
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TemplateTemplate", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClass converts OAPI to gNMI.
func EncodeToGnmiTrafficClass(
	jsonObj *types.TrafficClass, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: traffic-class []TrafficClassTrafficClass
	if jsonObj.TrafficClass != nil {

	}

	// Property: traffic-class []TrafficClassTrafficClass
	if jsonObj.TrafficClass != nil {
		for _, item := range *jsonObj.TrafficClass {
			item := item //Pinning
			paramsTrafficClass := make([]string, len(params))
			copy(paramsTrafficClass, params)
			paramsTrafficClass = append(paramsTrafficClass, "unknown_id")
			updatesTrafficClass, err :=
				EncodeToGnmiTrafficClassTrafficClass(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "traffic-class"), paramsTrafficClass...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesTrafficClass...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClass", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassTrafficClass converts OAPI to gNMI.
func EncodeToGnmiTrafficClassTrafficClass(
	jsonObj *types.TrafficClassTrafficClass, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pdb int32
	if jsonObj.Pdb != nil {

		paramsPdb := make([]string, len(params))
		copy(paramsPdb, params)
		stringValPdb := fmt.Sprintf("%v", *jsonObj.Pdb)
		paramsPdb = append(paramsPdb, stringValPdb)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassPdb", paramsPdb...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pdb"), paramsPdb...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pelr int32
	if jsonObj.Pelr != nil {

		paramsPelr := make([]string, len(params))
		copy(paramsPelr, params)
		stringValPelr := fmt.Sprintf("%v", *jsonObj.Pelr)
		paramsPelr = append(paramsPelr, stringValPelr)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassPelr", paramsPelr...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pelr"), paramsPelr...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qci int32
	if jsonObj.Qci != nil {

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)
		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassTrafficClass", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiUpf converts OAPI to gNMI.
func EncodeToGnmiUpf(
	jsonObj *types.Upf, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: upf []UpfUpf
	if jsonObj.Upf != nil {

	}

	// Property: upf []UpfUpf
	if jsonObj.Upf != nil {
		for _, item := range *jsonObj.Upf {
			item := item //Pinning
			paramsUpf := make([]string, len(params))
			copy(paramsUpf, params)
			paramsUpf = append(paramsUpf, "unknown_id")
			updatesUpf, err :=
				EncodeToGnmiUpfUpf(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "upf"), paramsUpf...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesUpf...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Upf", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiUpfUpf converts OAPI to gNMI.
func EncodeToGnmiUpfUpf(
	jsonObj *types.UpfUpf, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if !removeIndex {

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	if !removeIndex {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port int32
	if !removeIndex {

		paramsPort := make([]string, len(params))
		copy(paramsPort, params)
		stringValPort := fmt.Sprintf("%v", jsonObj.Port)
		paramsPort = append(paramsPort, stringValPort)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfPort", paramsPort...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port"), paramsPort...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "UpfUpf", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcs converts OAPI to gNMI.
func EncodeToGnmiVcs(
	jsonObj *types.Vcs, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: vcs []VcsVcs
	if jsonObj.Vcs != nil {

	}

	// Property: vcs []VcsVcs
	if jsonObj.Vcs != nil {
		for _, item := range *jsonObj.Vcs {
			item := item //Pinning
			paramsVcs := make([]string, len(params))
			copy(paramsVcs, params)
			paramsVcs = append(paramsVcs, "unknown_id")
			updatesVcs, err :=
				EncodeToGnmiVcsVcs(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "vcs"), paramsVcs...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesVcs...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Vcs", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcs converts OAPI to gNMI.
func EncodeToGnmiVcsVcs(
	jsonObj *types.VcsVcs, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: ap string
	if jsonObj.Ap != nil {

		paramsAp := make([]string, len(params))
		copy(paramsAp, params)
		stringValAp := fmt.Sprintf("%v", *jsonObj.Ap)
		paramsAp = append(paramsAp, stringValAp)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsAp", paramsAp...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ap"), paramsAp...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: application []VcsVcsApplication
	if jsonObj.Application != nil {

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device-group []VcsVcsDeviceGroup
	if jsonObj.DeviceGroup != nil {

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink int32
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sd int32
	if !removeIndex {

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", jsonObj.Sd)
		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sst int32
	if !removeIndex {

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", jsonObj.Sst)
		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: template string
	if jsonObj.Template != nil {

		paramsTemplate := make([]string, len(params))
		copy(paramsTemplate, params)
		stringValTemplate := fmt.Sprintf("%v", *jsonObj.Template)
		paramsTemplate = append(paramsTemplate, stringValTemplate)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsTemplate", paramsTemplate...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/template"), paramsTemplate...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if !removeIndex {

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", jsonObj.TrafficClass)
		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: upf string
	if jsonObj.Upf != nil {

		paramsUpf := make([]string, len(params))
		copy(paramsUpf, params)
		stringValUpf := fmt.Sprintf("%v", *jsonObj.Upf)
		paramsUpf = append(paramsUpf, stringValUpf)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsUpf", paramsUpf...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf"), paramsUpf...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int32
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: application []VcsVcsApplication
	if jsonObj.Application != nil {
		for _, item := range *jsonObj.Application {
			item := item //Pinning
			paramsApplication := make([]string, len(params))
			copy(paramsApplication, params)
			paramsApplication = append(paramsApplication, "unknown_id")
			updatesApplication, err :=
				EncodeToGnmiVcsVcsApplication(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "application"), paramsApplication...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesApplication...)
		}
	}

	// Property: device-group []VcsVcsDeviceGroup
	if jsonObj.DeviceGroup != nil {
		for _, item := range *jsonObj.DeviceGroup {
			item := item //Pinning
			paramsDeviceGroup := make([]string, len(params))
			copy(paramsDeviceGroup, params)
			paramsDeviceGroup = append(paramsDeviceGroup, "unknown_id")
			updatesDeviceGroup, err :=
				EncodeToGnmiVcsVcsDeviceGroup(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device-group"), paramsDeviceGroup...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDeviceGroup...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcs", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcsApplication converts OAPI to gNMI.
func EncodeToGnmiVcsVcsApplication(
	jsonObj *types.VcsVcsApplication, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: allow bool
	if jsonObj.Allow != nil {

		paramsAllow := make([]string, len(params))
		copy(paramsAllow, params)
		stringValAllow := fmt.Sprintf("%v", *jsonObj.Allow)
		paramsAllow = append(paramsAllow, stringValAllow)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsApplicationAllow", paramsAllow...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/allow"), paramsAllow...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: application string
	if !removeIndex {

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)
		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsApplicationApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcsApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcsDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiVcsVcsDeviceGroup(
	jsonObj *types.VcsVcsDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-group string
	if jsonObj.DeviceGroup != nil {

		paramsDeviceGroup := make([]string, len(params))
		copy(paramsDeviceGroup, params)
		stringValDeviceGroup := fmt.Sprintf("%v", *jsonObj.DeviceGroup)
		paramsDeviceGroup = append(paramsDeviceGroup, stringValDeviceGroup)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDeviceGroupDeviceGroup", paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-group"), paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil {

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)
		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDeviceGroupEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcsDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

//Ignoring Target

//Ignoring RequestBodyApList

//Ignoring RequestBodyApListApList

//Ignoring RequestBodyApListApListAccessPoints

//Ignoring RequestBodyApplication

//Ignoring RequestBodyApplicationApplication

//Ignoring RequestBodyApplicationApplicationEndpoint

//Ignoring RequestBodyConnectivityService

//Ignoring RequestBodyConnectivityServiceConnectivityService

//Ignoring RequestBodyDeviceGroup

//Ignoring RequestBodyDeviceGroupDeviceGroup

//Ignoring RequestBodyDeviceGroupDeviceGroupImsis

//Ignoring RequestBodyEnterprise

//Ignoring RequestBodyEnterpriseEnterprise

//Ignoring RequestBodyEnterpriseEnterpriseConnectivityService

//Ignoring RequestBodyIpDomain

//Ignoring RequestBodyIpDomainIpDomain

//Ignoring RequestBodySite

//Ignoring RequestBodySiteSite

//Ignoring RequestBodySiteSiteImsiDefinition

//Ignoring RequestBodyTemplate

//Ignoring RequestBodyTemplateTemplate

//Ignoring RequestBodyTrafficClass

//Ignoring RequestBodyTrafficClassTrafficClass

//Ignoring RequestBodyUpf

//Ignoring RequestBodyUpfUpf

//Ignoring RequestBodyVcs

//Ignoring RequestBodyVcsVcs

//Ignoring RequestBodyVcsVcsApplication

//Ignoring RequestBodyVcsVcsDeviceGroup

// Not generating param-types
// Not generating request-bodies

// Not generating additional-properties
// Not generating additional-properties
