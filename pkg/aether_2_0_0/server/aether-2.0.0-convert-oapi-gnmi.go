// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	externalRef0 "github.com/onosproject/aether-models/models/aether-2.0.x/v2/api"
	"github.com/onosproject/aether-roc-api/pkg/aether_2_0_0/types"
	"github.com/onosproject/aether-roc-api/pkg/utils"

	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	"reflect"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertyTarget

//Ignoring AdditionalPropertyUnchanged

// EncodeToGnmiConnectivityServices converts OAPI to gNMI.
func EncodeToGnmiConnectivityServices(
	jsonObj *types.ConnectivityServices, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service ConnectivityServicesConnectivityServiceList
	if jsonObj.ConnectivityService != nil { // Optional leaf

		update, err := EncodeToGnmiConnectivityServicesConnectivityServiceList(
			jsonObj.ConnectivityService, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "connectivity-service"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServices", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityServicesConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityServicesConnectivityService(
	jsonObj *types.ConnectivityServicesConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: acc-prometheus-url string
	if jsonObj.AccPrometheusUrl != nil { // Optional leaf

		paramsAccPrometheusUrl := make([]string, len(params))
		copy(paramsAccPrometheusUrl, params)
		stringValAccPrometheusUrl := fmt.Sprintf("%v", *jsonObj.AccPrometheusUrl)

		paramsAccPrometheusUrl = append(paramsAccPrometheusUrl, stringValAccPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceAccPrometheusUrl", paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/acc-prometheus-url"), paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: connectivity-service-id string
	_, unchangedConnectivityServiceId := unchangedAttrs["connectivity-service-id"]
	if !unchangedConnectivityServiceId { // Mandatory leaf

		paramsConnectivityServiceId := make([]string, len(params))
		copy(paramsConnectivityServiceId, params)
		stringValConnectivityServiceId := fmt.Sprintf("%v", jsonObj.ConnectivityServiceId)
		if stringValConnectivityServiceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'connectivity-service-id' of 'ConnectivityServicesConnectivityService' must be provided or added to 'unchanged'")
		}
		paramsConnectivityServiceId = append(paramsConnectivityServiceId, stringValConnectivityServiceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceConnectivityServiceId", paramsConnectivityServiceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connectivity-service-id"), paramsConnectivityServiceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: core-5g-endpoint string
	if jsonObj.Core5gEndpoint != nil { // Optional leaf

		paramsCore5gEndpoint := make([]string, len(params))
		copy(paramsCore5gEndpoint, params)
		stringValCore5gEndpoint := fmt.Sprintf("%v", *jsonObj.Core5gEndpoint)

		paramsCore5gEndpoint = append(paramsCore5gEndpoint, stringValCore5gEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceCore5gEndpoint", paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/core-5g-endpoint"), paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServicesConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityServicesConnectivityServiceList converts OAPI List to gNMI List.
func EncodeToGnmiConnectivityServicesConnectivityServiceList(
	jsonObj *types.ConnectivityServicesConnectivityServiceList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiConnectivityServicesConnectivityService(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprises converts OAPI to gNMI.
func EncodeToGnmiEnterprises(
	jsonObj *types.Enterprises, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise EnterprisesEnterpriseList
	if jsonObj.Enterprise != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseList(
			jsonObj.Enterprise, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "enterprise"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Enterprises", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterprise(
	jsonObj *types.EnterprisesEnterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: application EnterprisesEnterpriseApplicationList
	if jsonObj.Application != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseApplicationList(
			jsonObj.Application, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "application"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: connectivity-service EnterprisesEnterpriseConnectivityServiceList
	if jsonObj.ConnectivityService != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseConnectivityServiceList(
			jsonObj.ConnectivityService, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "connectivity-service"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise-id string
	_, unchangedEnterpriseId := unchangedAttrs["enterprise-id"]
	if !unchangedEnterpriseId { // Mandatory leaf

		paramsEnterpriseId := make([]string, len(params))
		copy(paramsEnterpriseId, params)
		stringValEnterpriseId := fmt.Sprintf("%v", jsonObj.EnterpriseId)
		if stringValEnterpriseId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'enterprise-id' of 'EnterprisesEnterprise' must be provided or added to 'unchanged'")
		}
		paramsEnterpriseId = append(paramsEnterpriseId, stringValEnterpriseId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseEnterpriseId", paramsEnterpriseId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise-id"), paramsEnterpriseId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: site EnterprisesEnterpriseSiteList
	if jsonObj.Site != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteList(
			jsonObj.Site, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "site"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: template EnterprisesEnterpriseTemplateList
	if jsonObj.Template != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseTemplateList(
			jsonObj.Template, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "template"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: traffic-class EnterprisesEnterpriseTrafficClassList
	if jsonObj.TrafficClass != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseTrafficClassList(
			jsonObj.TrafficClass, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "traffic-class"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplication converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseApplication(
	jsonObj *types.EnterprisesEnterpriseApplication, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'EnterprisesEnterpriseApplication' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: application-id string
	_, unchangedApplicationId := unchangedAttrs["application-id"]
	if !unchangedApplicationId { // Mandatory leaf

		paramsApplicationId := make([]string, len(params))
		copy(paramsApplicationId, params)
		stringValApplicationId := fmt.Sprintf("%v", jsonObj.ApplicationId)
		if stringValApplicationId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'application-id' of 'EnterprisesEnterpriseApplication' must be provided or added to 'unchanged'")
		}
		paramsApplicationId = append(paramsApplicationId, stringValApplicationId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationApplicationId", paramsApplicationId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application-id"), paramsApplicationId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint EnterprisesEnterpriseApplicationEndpointList
	if jsonObj.Endpoint != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseApplicationEndpointList(
			jsonObj.Endpoint, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "endpoint"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplicationEndpoint converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseApplicationEndpoint(
	jsonObj *types.EnterprisesEnterpriseApplicationEndpoint, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint-id string
	_, unchangedEndpointId := unchangedAttrs["endpoint-id"]
	if !unchangedEndpointId { // Mandatory leaf

		paramsEndpointId := make([]string, len(params))
		copy(paramsEndpointId, params)
		stringValEndpointId := fmt.Sprintf("%v", jsonObj.EndpointId)
		if stringValEndpointId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'endpoint-id' of 'EnterprisesEnterpriseApplicationEndpoint' must be provided or added to 'unchanged'")
		}
		paramsEndpointId = append(paramsEndpointId, stringValEndpointId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointEndpointId", paramsEndpointId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint-id"), paramsEndpointId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mbr EnterprisesEnterpriseApplicationEndpointMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseApplicationEndpointMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: port-end int
	if jsonObj.PortEnd != nil { // Optional leaf

		paramsPortEnd := make([]string, len(params))
		copy(paramsPortEnd, params)
		stringValPortEnd := fmt.Sprintf("%v", *jsonObj.PortEnd)

		paramsPortEnd = append(paramsPortEnd, stringValPortEnd)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointPortEnd", paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-end"), paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port-start int
	if jsonObj.PortStart != nil { // Optional leaf

		paramsPortStart := make([]string, len(params))
		copy(paramsPortStart, params)
		stringValPortStart := fmt.Sprintf("%v", *jsonObj.PortStart)

		paramsPortStart = append(paramsPortStart, stringValPortStart)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointPortStart", paramsPortStart...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-start"), paramsPortStart...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: protocol string
	if jsonObj.Protocol != nil { // Optional leaf

		paramsProtocol := make([]string, len(params))
		copy(paramsProtocol, params)
		stringValProtocol := fmt.Sprintf("%v", *jsonObj.Protocol)

		paramsProtocol = append(paramsProtocol, stringValProtocol)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointProtocol", paramsProtocol...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/protocol"), paramsProtocol...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil { // Optional leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)

		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseApplicationEndpoint", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplicationEndpointList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseApplicationEndpointList(
	jsonObj *types.EnterprisesEnterpriseApplicationEndpointList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseApplicationEndpoint(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplicationEndpointMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseApplicationEndpointMbr(
	jsonObj *types.EnterprisesEnterpriseApplicationEndpointMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseApplicationEndpointMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplicationList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseApplicationList(
	jsonObj *types.EnterprisesEnterpriseApplicationList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseApplication(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseConnectivityService converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseConnectivityService(
	jsonObj *types.EnterprisesEnterpriseConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service string
	_, unchangedConnectivityService := unchangedAttrs["connectivity-service"]
	if !unchangedConnectivityService { // Mandatory leaf

		paramsConnectivityService := make([]string, len(params))
		copy(paramsConnectivityService, params)
		stringValConnectivityService := fmt.Sprintf("%v", jsonObj.ConnectivityService)
		if stringValConnectivityService == "" {
			return nil, liberrors.NewInvalid("mandatory field 'connectivity-service' of 'EnterprisesEnterpriseConnectivityService' must be provided or added to 'unchanged'")
		}
		paramsConnectivityService = append(paramsConnectivityService, stringValConnectivityService)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseConnectivityServiceConnectivityService", paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connectivity-service"), paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	if jsonObj.Enabled != nil { // Optional leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseConnectivityServiceEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseConnectivityServiceList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseConnectivityServiceList(
	jsonObj *types.EnterprisesEnterpriseConnectivityServiceList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseConnectivityService(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseList(
	jsonObj *types.EnterprisesEnterpriseList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterprise(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSite converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSite(
	jsonObj *types.EnterprisesEnterpriseSite, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device EnterprisesEnterpriseSiteDeviceList
	if jsonObj.Device != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteDeviceList(
			jsonObj.Device, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "device"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: device-group EnterprisesEnterpriseSiteDeviceGroupList
	if jsonObj.DeviceGroup != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupList(
			jsonObj.DeviceGroup, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "device-group"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-definition EnterprisesEnterpriseSiteImsiDefinition
	if jsonObj.ImsiDefinition != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteImsiDefinition(
			jsonObj.ImsiDefinition, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "imsi-definition"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: ip-domain EnterprisesEnterpriseSiteIpDomainList
	if jsonObj.IpDomain != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteIpDomainList(
			jsonObj.IpDomain, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "ip-domain"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: monitoring EnterprisesEnterpriseSiteMonitoring
	if jsonObj.Monitoring != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteMonitoring(
			jsonObj.Monitoring, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "monitoring"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sim-card EnterprisesEnterpriseSiteSimCardList
	if jsonObj.SimCard != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSimCardList(
			jsonObj.SimCard, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "sim-card"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: site-id string
	_, unchangedSiteId := unchangedAttrs["site-id"]
	if !unchangedSiteId { // Mandatory leaf

		paramsSiteId := make([]string, len(params))
		copy(paramsSiteId, params)
		stringValSiteId := fmt.Sprintf("%v", jsonObj.SiteId)
		if stringValSiteId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'site-id' of 'EnterprisesEnterpriseSite' must be provided or added to 'unchanged'")
		}
		paramsSiteId = append(paramsSiteId, stringValSiteId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSiteId", paramsSiteId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/site-id"), paramsSiteId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: slice EnterprisesEnterpriseSiteSliceList
	if jsonObj.Slice != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSliceList(
			jsonObj.Slice, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "slice"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: small-cell EnterprisesEnterpriseSiteSmallCellList
	if jsonObj.SmallCell != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSmallCellList(
			jsonObj.SmallCell, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "small-cell"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: upf EnterprisesEnterpriseSiteUpfList
	if jsonObj.Upf != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteUpfList(
			jsonObj.Upf, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "upf"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSite", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDevice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDevice(
	jsonObj *types.EnterprisesEnterpriseSiteDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device-id string
	_, unchangedDeviceId := unchangedAttrs["device-id"]
	if !unchangedDeviceId { // Mandatory leaf

		paramsDeviceId := make([]string, len(params))
		copy(paramsDeviceId, params)
		stringValDeviceId := fmt.Sprintf("%v", jsonObj.DeviceId)
		if stringValDeviceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device-id' of 'EnterprisesEnterpriseSiteDevice' must be provided or added to 'unchanged'")
		}
		paramsDeviceId = append(paramsDeviceId, stringValDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceDeviceId", paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-id"), paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imei string
	if jsonObj.Imei != nil { // Optional leaf

		paramsImei := make([]string, len(params))
		copy(paramsImei, params)
		stringValImei := fmt.Sprintf("%v", *jsonObj.Imei)

		paramsImei = append(paramsImei, stringValImei)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceImei", paramsImei...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imei"), paramsImei...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sim-card string
	if jsonObj.SimCard != nil { // Optional leaf

		paramsSimCard := make([]string, len(params))
		copy(paramsSimCard, params)
		stringValSimCard := fmt.Sprintf("%v", *jsonObj.SimCard)

		paramsSimCard = append(paramsSimCard, stringValSimCard)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceSimCard", paramsSimCard...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sim-card"), paramsSimCard...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroup(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device EnterprisesEnterpriseSiteDeviceGroupDeviceList
	if jsonObj.Device != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDeviceList(
			jsonObj.Device, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "device"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: device-group-id string
	_, unchangedDeviceGroupId := unchangedAttrs["device-group-id"]
	if !unchangedDeviceGroupId { // Mandatory leaf

		paramsDeviceGroupId := make([]string, len(params))
		copy(paramsDeviceGroupId, params)
		stringValDeviceGroupId := fmt.Sprintf("%v", jsonObj.DeviceGroupId)
		if stringValDeviceGroupId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device-group-id' of 'EnterprisesEnterpriseSiteDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsDeviceGroupId = append(paramsDeviceGroupId, stringValDeviceGroupId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDeviceGroupId", paramsDeviceGroupId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-group-id"), paramsDeviceGroupId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: ip-domain string
	if jsonObj.IpDomain != nil { // Optional leaf

		paramsIpDomain := make([]string, len(params))
		copy(paramsIpDomain, params)
		stringValIpDomain := fmt.Sprintf("%v", *jsonObj.IpDomain)

		paramsIpDomain = append(paramsIpDomain, stringValIpDomain)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupIpDomain", paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-domain"), paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mbr EnterprisesEnterpriseSiteDeviceGroupMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: traffic-class string
	_, unchangedTrafficClass := unchangedAttrs["traffic-class"]
	if !unchangedTrafficClass { // Mandatory leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", jsonObj.TrafficClass)
		if stringValTrafficClass == "" {
			return nil, liberrors.NewInvalid("mandatory field 'traffic-class' of 'EnterprisesEnterpriseSiteDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDevice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDevice(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroupDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-id string
	_, unchangedDeviceId := unchangedAttrs["device-id"]
	if !unchangedDeviceId { // Mandatory leaf

		paramsDeviceId := make([]string, len(params))
		copy(paramsDeviceId, params)
		stringValDeviceId := fmt.Sprintf("%v", jsonObj.DeviceId)
		if stringValDeviceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device-id' of 'EnterprisesEnterpriseSiteDeviceGroupDevice' must be provided or added to 'unchanged'")
		}
		paramsDeviceId = append(paramsDeviceId, stringValDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDeviceDeviceId", paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-id"), paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDeviceEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDeviceGroupDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDeviceList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDeviceList(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroupDeviceList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDevice(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupList(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroupList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroup(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupMbr(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroupMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	_, unchangedDownlink := unchangedAttrs["downlink"]
	if !unchangedDownlink { // Mandatory leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	_, unchangedUplink := unchangedAttrs["uplink"]
	if !unchangedUplink { // Mandatory leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDeviceGroupMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceList(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteDevice(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteImsiDefinition converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteImsiDefinition(
	jsonObj *types.EnterprisesEnterpriseSiteImsiDefinition, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise int32
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)

		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: format string
	_, unchangedFormat := unchangedAttrs["format"]
	if !unchangedFormat { // Mandatory leaf

		paramsFormat := make([]string, len(params))
		copy(paramsFormat, params)
		stringValFormat := fmt.Sprintf("%v", jsonObj.Format)
		if stringValFormat == "" {
			return nil, liberrors.NewInvalid("mandatory field 'format' of 'EnterprisesEnterpriseSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsFormat = append(paramsFormat, stringValFormat)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionFormat", paramsFormat...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/format"), paramsFormat...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mcc string
	_, unchangedMcc := unchangedAttrs["mcc"]
	if !unchangedMcc { // Mandatory leaf

		paramsMcc := make([]string, len(params))
		copy(paramsMcc, params)
		stringValMcc := fmt.Sprintf("%v", jsonObj.Mcc)
		if stringValMcc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mcc' of 'EnterprisesEnterpriseSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMcc = append(paramsMcc, stringValMcc)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionMcc", paramsMcc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mcc"), paramsMcc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mnc string
	_, unchangedMnc := unchangedAttrs["mnc"]
	if !unchangedMnc { // Mandatory leaf

		paramsMnc := make([]string, len(params))
		copy(paramsMnc, params)
		stringValMnc := fmt.Sprintf("%v", jsonObj.Mnc)
		if stringValMnc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mnc' of 'EnterprisesEnterpriseSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMnc = append(paramsMnc, stringValMnc)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionMnc", paramsMnc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mnc"), paramsMnc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteImsiDefinition", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteIpDomain converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteIpDomain(
	jsonObj *types.EnterprisesEnterpriseSiteIpDomain, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: admin-status string
	if jsonObj.AdminStatus != nil { // Optional leaf

		paramsAdminStatus := make([]string, len(params))
		copy(paramsAdminStatus, params)
		stringValAdminStatus := fmt.Sprintf("%v", *jsonObj.AdminStatus)

		paramsAdminStatus = append(paramsAdminStatus, stringValAdminStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainAdminStatus", paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/admin-status"), paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dnn string
	_, unchangedDnn := unchangedAttrs["dnn"]
	if !unchangedDnn { // Mandatory leaf

		paramsDnn := make([]string, len(params))
		copy(paramsDnn, params)
		stringValDnn := fmt.Sprintf("%v", jsonObj.Dnn)
		if stringValDnn == "" {
			return nil, liberrors.NewInvalid("mandatory field 'dnn' of 'EnterprisesEnterpriseSiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsDnn = append(paramsDnn, stringValDnn)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDnn", paramsDnn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dnn"), paramsDnn...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-primary string
	if jsonObj.DnsPrimary != nil { // Optional leaf

		paramsDnsPrimary := make([]string, len(params))
		copy(paramsDnsPrimary, params)
		stringValDnsPrimary := fmt.Sprintf("%v", *jsonObj.DnsPrimary)

		paramsDnsPrimary = append(paramsDnsPrimary, stringValDnsPrimary)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDnsPrimary", paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-primary"), paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-secondary string
	if jsonObj.DnsSecondary != nil { // Optional leaf

		paramsDnsSecondary := make([]string, len(params))
		copy(paramsDnsSecondary, params)
		stringValDnsSecondary := fmt.Sprintf("%v", *jsonObj.DnsSecondary)

		paramsDnsSecondary = append(paramsDnsSecondary, stringValDnsSecondary)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDnsSecondary", paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-secondary"), paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: ip-domain-id string
	_, unchangedIpDomainId := unchangedAttrs["ip-domain-id"]
	if !unchangedIpDomainId { // Mandatory leaf

		paramsIpDomainId := make([]string, len(params))
		copy(paramsIpDomainId, params)
		stringValIpDomainId := fmt.Sprintf("%v", jsonObj.IpDomainId)
		if stringValIpDomainId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'ip-domain-id' of 'EnterprisesEnterpriseSiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsIpDomainId = append(paramsIpDomainId, stringValIpDomainId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainIpDomainId", paramsIpDomainId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-domain-id"), paramsIpDomainId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mtu int
	if jsonObj.Mtu != nil { // Optional leaf

		paramsMtu := make([]string, len(params))
		copy(paramsMtu, params)
		stringValMtu := fmt.Sprintf("%v", *jsonObj.Mtu)

		paramsMtu = append(paramsMtu, stringValMtu)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainMtu", paramsMtu...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mtu"), paramsMtu...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: subnet string
	_, unchangedSubnet := unchangedAttrs["subnet"]
	if !unchangedSubnet { // Mandatory leaf

		paramsSubnet := make([]string, len(params))
		copy(paramsSubnet, params)
		stringValSubnet := fmt.Sprintf("%v", jsonObj.Subnet)
		if stringValSubnet == "" {
			return nil, liberrors.NewInvalid("mandatory field 'subnet' of 'EnterprisesEnterpriseSiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsSubnet = append(paramsSubnet, stringValSubnet)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainSubnet", paramsSubnet...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/subnet"), paramsSubnet...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteIpDomain", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteIpDomainList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteIpDomainList(
	jsonObj *types.EnterprisesEnterpriseSiteIpDomainList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteIpDomain(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteList(
	jsonObj *types.EnterprisesEnterpriseSiteList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSite(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteMonitoring converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteMonitoring(
	jsonObj *types.EnterprisesEnterpriseSiteMonitoring, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: edge-cluster-prometheus-url string
	if jsonObj.EdgeClusterPrometheusUrl != nil { // Optional leaf

		paramsEdgeClusterPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeClusterPrometheusUrl, params)
		stringValEdgeClusterPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeClusterPrometheusUrl)

		paramsEdgeClusterPrometheusUrl = append(paramsEdgeClusterPrometheusUrl, stringValEdgeClusterPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeClusterPrometheusUrl", paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-cluster-prometheus-url"), paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: edge-device EnterprisesEnterpriseSiteMonitoringEdgeDeviceList
	if jsonObj.EdgeDevice != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDeviceList(
			jsonObj.EdgeDevice, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "edge-device"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: edge-monitoring-prometheus-url string
	if jsonObj.EdgeMonitoringPrometheusUrl != nil { // Optional leaf

		paramsEdgeMonitoringPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeMonitoringPrometheusUrl, params)
		stringValEdgeMonitoringPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeMonitoringPrometheusUrl)

		paramsEdgeMonitoringPrometheusUrl = append(paramsEdgeMonitoringPrometheusUrl, stringValEdgeMonitoringPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeMonitoringPrometheusUrl", paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-monitoring-prometheus-url"), paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDevice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDevice(
	jsonObj *types.EnterprisesEnterpriseSiteMonitoringEdgeDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeDeviceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeDeviceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: edge-device-id string
	_, unchangedEdgeDeviceId := unchangedAttrs["edge-device-id"]
	if !unchangedEdgeDeviceId { // Mandatory leaf

		paramsEdgeDeviceId := make([]string, len(params))
		copy(paramsEdgeDeviceId, params)
		stringValEdgeDeviceId := fmt.Sprintf("%v", jsonObj.EdgeDeviceId)
		if stringValEdgeDeviceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'edge-device-id' of 'EnterprisesEnterpriseSiteMonitoringEdgeDevice' must be provided or added to 'unchanged'")
		}
		paramsEdgeDeviceId = append(paramsEdgeDeviceId, stringValEdgeDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeDeviceEdgeDeviceId", paramsEdgeDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-device-id"), paramsEdgeDeviceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteMonitoringEdgeDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDeviceList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDeviceList(
	jsonObj *types.EnterprisesEnterpriseSiteMonitoringEdgeDeviceList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDevice(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSimCard converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSimCard(
	jsonObj *types.EnterprisesEnterpriseSiteSimCard, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: iccid string
	if jsonObj.Iccid != nil { // Optional leaf

		paramsIccid := make([]string, len(params))
		copy(paramsIccid, params)
		stringValIccid := fmt.Sprintf("%v", *jsonObj.Iccid)

		paramsIccid = append(paramsIccid, stringValIccid)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardIccid", paramsIccid...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/iccid"), paramsIccid...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi int64
	if jsonObj.Imsi != nil { // Optional leaf

		paramsImsi := make([]string, len(params))
		copy(paramsImsi, params)
		stringValImsi := fmt.Sprintf("%v", *jsonObj.Imsi)

		paramsImsi = append(paramsImsi, stringValImsi)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardImsi", paramsImsi...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi"), paramsImsi...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sim-id string
	_, unchangedSimId := unchangedAttrs["sim-id"]
	if !unchangedSimId { // Mandatory leaf

		paramsSimId := make([]string, len(params))
		copy(paramsSimId, params)
		stringValSimId := fmt.Sprintf("%v", jsonObj.SimId)
		if stringValSimId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'sim-id' of 'EnterprisesEnterpriseSiteSimCard' must be provided or added to 'unchanged'")
		}
		paramsSimId = append(paramsSimId, stringValSimId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardSimId", paramsSimId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sim-id"), paramsSimId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSimCard", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSimCardList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteSimCardList(
	jsonObj *types.EnterprisesEnterpriseSiteSimCardList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteSimCard(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSlice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSlice(
	jsonObj *types.EnterprisesEnterpriseSiteSlice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'EnterprisesEnterpriseSiteSlice' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device-group EnterprisesEnterpriseSiteSliceDeviceGroupList
	if jsonObj.DeviceGroup != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroupList(
			jsonObj.DeviceGroup, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "device-group"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: filter EnterprisesEnterpriseSiteSliceFilterList
	if jsonObj.Filter != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSliceFilterList(
			jsonObj.Filter, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "filter"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: mbr EnterprisesEnterpriseSiteSliceMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSliceMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: priority-traffic-rule EnterprisesEnterpriseSiteSlicePriorityTrafficRuleList
	if jsonObj.PriorityTrafficRule != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleList(
			jsonObj.PriorityTrafficRule, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "priority-traffic-rule"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sd int32
	_, unchangedSd := unchangedAttrs["sd"]
	if !unchangedSd { // Mandatory leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: slice-id string
	_, unchangedSliceId := unchangedAttrs["slice-id"]
	if !unchangedSliceId { // Mandatory leaf

		paramsSliceId := make([]string, len(params))
		copy(paramsSliceId, params)
		stringValSliceId := fmt.Sprintf("%v", jsonObj.SliceId)
		if stringValSliceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'slice-id' of 'EnterprisesEnterpriseSiteSlice' must be provided or added to 'unchanged'")
		}
		paramsSliceId = append(paramsSliceId, stringValSliceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceSliceId", paramsSliceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/slice-id"), paramsSliceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sst int
	_, unchangedSst := unchangedAttrs["sst"]
	if !unchangedSst { // Mandatory leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: upf string
	if jsonObj.Upf != nil { // Optional leaf

		paramsUpf := make([]string, len(params))
		copy(paramsUpf, params)
		stringValUpf := fmt.Sprintf("%v", *jsonObj.Upf)

		paramsUpf = append(paramsUpf, stringValUpf)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceUpf", paramsUpf...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf"), paramsUpf...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSlice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroup(
	jsonObj *types.EnterprisesEnterpriseSiteSliceDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-group string
	_, unchangedDeviceGroup := unchangedAttrs["device-group"]
	if !unchangedDeviceGroup { // Mandatory leaf

		paramsDeviceGroup := make([]string, len(params))
		copy(paramsDeviceGroup, params)
		stringValDeviceGroup := fmt.Sprintf("%v", jsonObj.DeviceGroup)
		if stringValDeviceGroup == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device-group' of 'EnterprisesEnterpriseSiteSliceDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsDeviceGroup = append(paramsDeviceGroup, stringValDeviceGroup)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDeviceGroupDeviceGroup", paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-group"), paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDeviceGroupEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSliceDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroupList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroupList(
	jsonObj *types.EnterprisesEnterpriseSiteSliceDeviceGroupList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroup(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceFilter converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceFilter(
	jsonObj *types.EnterprisesEnterpriseSiteSliceFilter, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: allow bool
	if jsonObj.Allow != nil { // Optional leaf

		paramsAllow := make([]string, len(params))
		copy(paramsAllow, params)
		stringValAllow := fmt.Sprintf("%v", *jsonObj.Allow)

		paramsAllow = append(paramsAllow, stringValAllow)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceFilterAllow", paramsAllow...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/allow"), paramsAllow...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: application string
	_, unchangedApplication := unchangedAttrs["application"]
	if !unchangedApplication { // Mandatory leaf

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)
		if stringValApplication == "" {
			return nil, liberrors.NewInvalid("mandatory field 'application' of 'EnterprisesEnterpriseSiteSliceFilter' must be provided or added to 'unchanged'")
		}
		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceFilterApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: priority int
	if jsonObj.Priority != nil { // Optional leaf

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)

		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceFilterPriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSliceFilter", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceFilterList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceFilterList(
	jsonObj *types.EnterprisesEnterpriseSiteSliceFilterList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteSliceFilter(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceList(
	jsonObj *types.EnterprisesEnterpriseSiteSliceList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteSlice(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceMbr(
	jsonObj *types.EnterprisesEnterpriseSiteSliceMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSliceMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRule converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRule(
	jsonObj *types.EnterprisesEnterpriseSiteSlicePriorityTrafficRule, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: application string
	_, unchangedApplication := unchangedAttrs["application"]
	if !unchangedApplication { // Mandatory leaf

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)
		if stringValApplication == "" {
			return nil, liberrors.NewInvalid("mandatory field 'application' of 'EnterprisesEnterpriseSiteSlicePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		stringValDevice := fmt.Sprintf("%v", jsonObj.Device)
		if stringValDevice == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device' of 'EnterprisesEnterpriseSiteSlicePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsDevice = append(paramsDevice, stringValDevice)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint string
	_, unchangedEndpoint := unchangedAttrs["endpoint"]
	if !unchangedEndpoint { // Mandatory leaf

		paramsEndpoint := make([]string, len(params))
		copy(paramsEndpoint, params)
		stringValEndpoint := fmt.Sprintf("%v", jsonObj.Endpoint)
		if stringValEndpoint == "" {
			return nil, liberrors.NewInvalid("mandatory field 'endpoint' of 'EnterprisesEnterpriseSiteSlicePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsEndpoint = append(paramsEndpoint, stringValEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleEndpoint", paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint"), paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: gbr EnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbr
	if jsonObj.Gbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbr(
			jsonObj.Gbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "gbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: mbr EnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: priority-traffic-rule-id string
	_, unchangedPriorityTrafficRuleId := unchangedAttrs["priority-traffic-rule-id"]
	if !unchangedPriorityTrafficRuleId { // Mandatory leaf

		paramsPriorityTrafficRuleId := make([]string, len(params))
		copy(paramsPriorityTrafficRuleId, params)
		stringValPriorityTrafficRuleId := fmt.Sprintf("%v", jsonObj.PriorityTrafficRuleId)
		if stringValPriorityTrafficRuleId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'priority-traffic-rule-id' of 'EnterprisesEnterpriseSiteSlicePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsPriorityTrafficRuleId = append(paramsPriorityTrafficRuleId, stringValPriorityTrafficRuleId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRulePriorityTrafficRuleId", paramsPriorityTrafficRuleId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority-traffic-rule-id"), paramsPriorityTrafficRuleId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil { // Optional leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)

		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRule", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbr(
	jsonObj *types.EnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleGbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleList(
	jsonObj *types.EnterprisesEnterpriseSiteSlicePriorityTrafficRuleList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRule(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbr(
	jsonObj *types.EnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSlicePriorityTrafficRuleMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSmallCell converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSmallCell(
	jsonObj *types.EnterprisesEnterpriseSiteSmallCell, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if jsonObj.Address != nil { // Optional leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", *jsonObj.Address)

		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: small-cell-id string
	_, unchangedSmallCellId := unchangedAttrs["small-cell-id"]
	if !unchangedSmallCellId { // Mandatory leaf

		paramsSmallCellId := make([]string, len(params))
		copy(paramsSmallCellId, params)
		stringValSmallCellId := fmt.Sprintf("%v", jsonObj.SmallCellId)
		if stringValSmallCellId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'small-cell-id' of 'EnterprisesEnterpriseSiteSmallCell' must be provided or added to 'unchanged'")
		}
		paramsSmallCellId = append(paramsSmallCellId, stringValSmallCellId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellSmallCellId", paramsSmallCellId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/small-cell-id"), paramsSmallCellId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: tac string
	_, unchangedTac := unchangedAttrs["tac"]
	if !unchangedTac { // Mandatory leaf

		paramsTac := make([]string, len(params))
		copy(paramsTac, params)
		stringValTac := fmt.Sprintf("%v", jsonObj.Tac)
		if stringValTac == "" {
			return nil, liberrors.NewInvalid("mandatory field 'tac' of 'EnterprisesEnterpriseSiteSmallCell' must be provided or added to 'unchanged'")
		}
		paramsTac = append(paramsTac, stringValTac)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellTac", paramsTac...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tac"), paramsTac...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSmallCell", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSmallCellList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteSmallCellList(
	jsonObj *types.EnterprisesEnterpriseSiteSmallCellList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteSmallCell(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteUpf converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteUpf(
	jsonObj *types.EnterprisesEnterpriseSiteUpf, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'EnterprisesEnterpriseSiteUpf' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: config-endpoint string
	if jsonObj.ConfigEndpoint != nil { // Optional leaf

		paramsConfigEndpoint := make([]string, len(params))
		copy(paramsConfigEndpoint, params)
		stringValConfigEndpoint := fmt.Sprintf("%v", *jsonObj.ConfigEndpoint)

		paramsConfigEndpoint = append(paramsConfigEndpoint, stringValConfigEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfConfigEndpoint", paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/config-endpoint"), paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port int
	_, unchangedPort := unchangedAttrs["port"]
	if !unchangedPort { // Mandatory leaf

		paramsPort := make([]string, len(params))
		copy(paramsPort, params)
		stringValPort := fmt.Sprintf("%v", jsonObj.Port)

		paramsPort = append(paramsPort, stringValPort)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfPort", paramsPort...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port"), paramsPort...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: upf-id string
	_, unchangedUpfId := unchangedAttrs["upf-id"]
	if !unchangedUpfId { // Mandatory leaf

		paramsUpfId := make([]string, len(params))
		copy(paramsUpfId, params)
		stringValUpfId := fmt.Sprintf("%v", jsonObj.UpfId)
		if stringValUpfId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'upf-id' of 'EnterprisesEnterpriseSiteUpf' must be provided or added to 'unchanged'")
		}
		paramsUpfId = append(paramsUpfId, stringValUpfId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfUpfId", paramsUpfId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf-id"), paramsUpfId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteUpf", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteUpfList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseSiteUpfList(
	jsonObj *types.EnterprisesEnterpriseSiteUpfList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseSiteUpf(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTemplate converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseTemplate(
	jsonObj *types.EnterprisesEnterpriseTemplate, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'EnterprisesEnterpriseTemplate' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mbr EnterprisesEnterpriseTemplateMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseTemplateMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sd int32
	if jsonObj.Sd != nil { // Optional leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", *jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sst int
	if jsonObj.Sst != nil { // Optional leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", *jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: template-id string
	_, unchangedTemplateId := unchangedAttrs["template-id"]
	if !unchangedTemplateId { // Mandatory leaf

		paramsTemplateId := make([]string, len(params))
		copy(paramsTemplateId, params)
		stringValTemplateId := fmt.Sprintf("%v", jsonObj.TemplateId)
		if stringValTemplateId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'template-id' of 'EnterprisesEnterpriseTemplate' must be provided or added to 'unchanged'")
		}
		paramsTemplateId = append(paramsTemplateId, stringValTemplateId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateTemplateId", paramsTemplateId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/template-id"), paramsTemplateId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseTemplate", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTemplateList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseTemplateList(
	jsonObj *types.EnterprisesEnterpriseTemplateList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseTemplate(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTemplateMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseTemplateMbr(
	jsonObj *types.EnterprisesEnterpriseTemplateMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseTemplateMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTrafficClass converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseTrafficClass(
	jsonObj *types.EnterprisesEnterpriseTrafficClass, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: arp int
	if jsonObj.Arp != nil { // Optional leaf

		paramsArp := make([]string, len(params))
		copy(paramsArp, params)
		stringValArp := fmt.Sprintf("%v", *jsonObj.Arp)

		paramsArp = append(paramsArp, stringValArp)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassArp", paramsArp...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/arp"), paramsArp...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pdb int
	if jsonObj.Pdb != nil { // Optional leaf

		paramsPdb := make([]string, len(params))
		copy(paramsPdb, params)
		stringValPdb := fmt.Sprintf("%v", *jsonObj.Pdb)

		paramsPdb = append(paramsPdb, stringValPdb)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassPdb", paramsPdb...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pdb"), paramsPdb...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pelr int
	if jsonObj.Pelr != nil { // Optional leaf

		paramsPelr := make([]string, len(params))
		copy(paramsPelr, params)
		stringValPelr := fmt.Sprintf("%v", *jsonObj.Pelr)

		paramsPelr = append(paramsPelr, stringValPelr)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassPelr", paramsPelr...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pelr"), paramsPelr...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qci int
	if jsonObj.Qci != nil { // Optional leaf

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)

		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class-id string
	_, unchangedTrafficClassId := unchangedAttrs["traffic-class-id"]
	if !unchangedTrafficClassId { // Mandatory leaf

		paramsTrafficClassId := make([]string, len(params))
		copy(paramsTrafficClassId, params)
		stringValTrafficClassId := fmt.Sprintf("%v", jsonObj.TrafficClassId)
		if stringValTrafficClassId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'traffic-class-id' of 'EnterprisesEnterpriseTrafficClass' must be provided or added to 'unchanged'")
		}
		paramsTrafficClassId = append(paramsTrafficClassId, stringValTrafficClassId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassTrafficClassId", paramsTrafficClassId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class-id"), paramsTrafficClassId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseTrafficClass", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTrafficClassList converts OAPI List to gNMI List.
func EncodeToGnmiEnterprisesEnterpriseTrafficClassList(
	jsonObj *types.EnterprisesEnterpriseTrafficClassList, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiEnterprisesEnterpriseTrafficClass(&childObj, true, removeIndex, target, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

//Ignoring Target

//Ignoring RequestBodyConnectivityServices

//Ignoring RequestBodyConnectivityServicesConnectivityService

//Ignoring RequestBodyEnterprises

//Ignoring RequestBodyEnterprisesEnterprise

//Ignoring RequestBodyEnterprisesEnterpriseApplication

//Ignoring RequestBodyEnterprisesEnterpriseApplicationEndpoint

//Ignoring RequestBodyEnterprisesEnterpriseApplicationEndpointMbr

//Ignoring RequestBodyEnterprisesEnterpriseConnectivityService

//Ignoring RequestBodyEnterprisesEnterpriseSite

//Ignoring RequestBodyEnterprisesEnterpriseSiteDevice

//Ignoring RequestBodyEnterprisesEnterpriseSiteDeviceGroup

//Ignoring RequestBodyEnterprisesEnterpriseSiteDeviceGroupDevice

//Ignoring RequestBodyEnterprisesEnterpriseSiteDeviceGroupMbr

//Ignoring RequestBodyEnterprisesEnterpriseSiteImsiDefinition

//Ignoring RequestBodyEnterprisesEnterpriseSiteIpDomain

//Ignoring RequestBodyEnterprisesEnterpriseSiteMonitoring

//Ignoring RequestBodyEnterprisesEnterpriseSiteMonitoringEdgeDevice

//Ignoring RequestBodyEnterprisesEnterpriseSiteSimCard

//Ignoring RequestBodyEnterprisesEnterpriseSiteSlice

//Ignoring RequestBodyEnterprisesEnterpriseSiteSliceDeviceGroup

//Ignoring RequestBodyEnterprisesEnterpriseSiteSliceFilter

//Ignoring RequestBodyEnterprisesEnterpriseSiteSliceMbr

//Ignoring RequestBodyEnterprisesEnterpriseSiteSlicePriorityTrafficRule

//Ignoring RequestBodyEnterprisesEnterpriseSiteSmallCell

//Ignoring RequestBodyEnterprisesEnterpriseSiteUpf

//Ignoring RequestBodyEnterprisesEnterpriseTemplate

//Ignoring RequestBodyEnterprisesEnterpriseTemplateMbr

//Ignoring RequestBodyEnterprisesEnterpriseTrafficClass

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating param-types
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating request-bodies

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
