// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	"github.com/onosproject/aether-roc-api/pkg/aether_2_0_0/types"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	externalRef0 "github.com/onosproject/config-models/modelplugin/aether-2.0.0/aether_2_0_0"

	"reflect"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertyTarget

//Ignoring AdditionalPropertyUnchanged

// EncodeToGnmiConnectivityServices converts OAPI to gNMI.
func EncodeToGnmiConnectivityServices(
	jsonObj *types.ConnectivityServices, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service []ConnectivityServicesConnectivityService
	if jsonObj.ConnectivityService != nil { // Optional leaf

	}

	// Property: connectivity-service []ConnectivityServicesConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiConnectivityServicesConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServices", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityServicesConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityServicesConnectivityService(
	jsonObj *types.ConnectivityServicesConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: acc-prometheus-url string
	if jsonObj.AccPrometheusUrl != nil { // Optional leaf

		paramsAccPrometheusUrl := make([]string, len(params))
		copy(paramsAccPrometheusUrl, params)
		stringValAccPrometheusUrl := fmt.Sprintf("%v", *jsonObj.AccPrometheusUrl)

		paramsAccPrometheusUrl = append(paramsAccPrometheusUrl, stringValAccPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceAccPrometheusUrl", paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/acc-prometheus-url"), paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: core-5g-endpoint string
	if jsonObj.Core5gEndpoint != nil { // Optional leaf

		paramsCore5gEndpoint := make([]string, len(params))
		copy(paramsCore5gEndpoint, params)
		stringValCore5gEndpoint := fmt.Sprintf("%v", *jsonObj.Core5gEndpoint)

		paramsCore5gEndpoint = append(paramsCore5gEndpoint, stringValCore5gEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceCore5gEndpoint", paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/core-5g-endpoint"), paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'ConnectivityServicesConnectivityService' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServicesConnectivityServiceId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServicesConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprises converts OAPI to gNMI.
func EncodeToGnmiEnterprises(
	jsonObj *types.Enterprises, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise []EnterprisesEnterprise
	if jsonObj.Enterprise != nil { // Optional leaf

	}

	// Property: enterprise []EnterprisesEnterprise
	if jsonObj.Enterprise != nil {
		for _, item := range *jsonObj.Enterprise {
			item := item //Pinning
			paramsEnterprise := make([]string, len(params))
			copy(paramsEnterprise, params)
			paramsEnterprise = append(paramsEnterprise, "unknown_id")
			updatesEnterprise, err :=
				EncodeToGnmiEnterprisesEnterprise(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "enterprise"), paramsEnterprise...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEnterprise...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Enterprises", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterprise(
	jsonObj *types.EnterprisesEnterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: application []EnterprisesEnterpriseApplication
	if jsonObj.Application != nil { // Optional leaf

	}
	// Property: connectivity-service []EnterprisesEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil { // Optional leaf

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: ent-id string
	_, unchangedEntId := unchangedAttrs["ent-id"]
	if !unchangedEntId { // Mandatory leaf

		paramsEntId := make([]string, len(params))
		copy(paramsEntId, params)
		stringValEntId := fmt.Sprintf("%v", jsonObj.EntId)
		if stringValEntId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'ent-id' of 'EnterprisesEnterprise' must be provided or added to 'unchanged'")
		}
		paramsEntId = append(paramsEntId, stringValEntId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseEntId", paramsEntId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ent-id"), paramsEntId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: site []EnterprisesEnterpriseSite
	if jsonObj.Site != nil { // Optional leaf

	}
	// Property: template []EnterprisesEnterpriseTemplate
	if jsonObj.Template != nil { // Optional leaf

	}
	// Property: traffic-class []EnterprisesEnterpriseTrafficClass
	if jsonObj.TrafficClass != nil { // Optional leaf

	}

	// Property: application []EnterprisesEnterpriseApplication
	if jsonObj.Application != nil {
		for _, item := range *jsonObj.Application {
			item := item //Pinning
			paramsApplication := make([]string, len(params))
			copy(paramsApplication, params)
			paramsApplication = append(paramsApplication, "unknown_id")
			updatesApplication, err :=
				EncodeToGnmiEnterprisesEnterpriseApplication(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "application"), paramsApplication...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesApplication...)
		}
	}

	// Property: connectivity-service []EnterprisesEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiEnterprisesEnterpriseConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	// Property: site []EnterprisesEnterpriseSite
	if jsonObj.Site != nil {
		for _, item := range *jsonObj.Site {
			item := item //Pinning
			paramsSite := make([]string, len(params))
			copy(paramsSite, params)
			paramsSite = append(paramsSite, "unknown_id")
			updatesSite, err :=
				EncodeToGnmiEnterprisesEnterpriseSite(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "site"), paramsSite...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSite...)
		}
	}

	// Property: template []EnterprisesEnterpriseTemplate
	if jsonObj.Template != nil {
		for _, item := range *jsonObj.Template {
			item := item //Pinning
			paramsTemplate := make([]string, len(params))
			copy(paramsTemplate, params)
			paramsTemplate = append(paramsTemplate, "unknown_id")
			updatesTemplate, err :=
				EncodeToGnmiEnterprisesEnterpriseTemplate(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "template"), paramsTemplate...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesTemplate...)
		}
	}

	// Property: traffic-class []EnterprisesEnterpriseTrafficClass
	if jsonObj.TrafficClass != nil {
		for _, item := range *jsonObj.TrafficClass {
			item := item //Pinning
			paramsTrafficClass := make([]string, len(params))
			copy(paramsTrafficClass, params)
			paramsTrafficClass = append(paramsTrafficClass, "unknown_id")
			updatesTrafficClass, err :=
				EncodeToGnmiEnterprisesEnterpriseTrafficClass(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "traffic-class"), paramsTrafficClass...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesTrafficClass...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplication converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseApplication(
	jsonObj *types.EnterprisesEnterpriseApplication, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'EnterprisesEnterpriseApplication' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: app-id string
	_, unchangedAppId := unchangedAttrs["app-id"]
	if !unchangedAppId { // Mandatory leaf

		paramsAppId := make([]string, len(params))
		copy(paramsAppId, params)
		stringValAppId := fmt.Sprintf("%v", jsonObj.AppId)
		if stringValAppId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'app-id' of 'EnterprisesEnterpriseApplication' must be provided or added to 'unchanged'")
		}
		paramsAppId = append(paramsAppId, stringValAppId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationAppId", paramsAppId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/app-id"), paramsAppId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint []EnterprisesEnterpriseApplicationEndpoint
	if jsonObj.Endpoint != nil { // Optional leaf

	}

	// Property: endpoint []EnterprisesEnterpriseApplicationEndpoint
	if jsonObj.Endpoint != nil {
		for _, item := range *jsonObj.Endpoint {
			item := item //Pinning
			paramsEndpoint := make([]string, len(params))
			copy(paramsEndpoint, params)
			paramsEndpoint = append(paramsEndpoint, "unknown_id")
			updatesEndpoint, err :=
				EncodeToGnmiEnterprisesEnterpriseApplicationEndpoint(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "endpoint"), paramsEndpoint...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEndpoint...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplicationEndpoint converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseApplicationEndpoint(
	jsonObj *types.EnterprisesEnterpriseApplicationEndpoint, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint-id string
	_, unchangedEndpointId := unchangedAttrs["endpoint-id"]
	if !unchangedEndpointId { // Mandatory leaf

		paramsEndpointId := make([]string, len(params))
		copy(paramsEndpointId, params)
		stringValEndpointId := fmt.Sprintf("%v", jsonObj.EndpointId)
		if stringValEndpointId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'endpoint-id' of 'EnterprisesEnterpriseApplicationEndpoint' must be provided or added to 'unchanged'")
		}
		paramsEndpointId = append(paramsEndpointId, stringValEndpointId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointEndpointId", paramsEndpointId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint-id"), paramsEndpointId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mbr EnterprisesEnterpriseApplicationEndpointMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseApplicationEndpointMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: port-end int
	if jsonObj.PortEnd != nil { // Optional leaf

		paramsPortEnd := make([]string, len(params))
		copy(paramsPortEnd, params)
		stringValPortEnd := fmt.Sprintf("%v", *jsonObj.PortEnd)

		paramsPortEnd = append(paramsPortEnd, stringValPortEnd)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointPortEnd", paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-end"), paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port-start int
	if jsonObj.PortStart != nil { // Optional leaf

		paramsPortStart := make([]string, len(params))
		copy(paramsPortStart, params)
		stringValPortStart := fmt.Sprintf("%v", *jsonObj.PortStart)

		paramsPortStart = append(paramsPortStart, stringValPortStart)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointPortStart", paramsPortStart...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-start"), paramsPortStart...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: protocol string
	if jsonObj.Protocol != nil { // Optional leaf

		paramsProtocol := make([]string, len(params))
		copy(paramsProtocol, params)
		stringValProtocol := fmt.Sprintf("%v", *jsonObj.Protocol)

		paramsProtocol = append(paramsProtocol, stringValProtocol)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointProtocol", paramsProtocol...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/protocol"), paramsProtocol...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil { // Optional leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)

		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseApplicationEndpoint", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseApplicationEndpointMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseApplicationEndpointMbr(
	jsonObj *types.EnterprisesEnterpriseApplicationEndpointMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseApplicationEndpointMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseApplicationEndpointMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseConnectivityService converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseConnectivityService(
	jsonObj *types.EnterprisesEnterpriseConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service string
	_, unchangedConnectivityService := unchangedAttrs["connectivity-service"]
	if !unchangedConnectivityService { // Mandatory leaf

		paramsConnectivityService := make([]string, len(params))
		copy(paramsConnectivityService, params)
		stringValConnectivityService := fmt.Sprintf("%v", jsonObj.ConnectivityService)
		if stringValConnectivityService == "" {
			return nil, liberrors.NewInvalid("mandatory field 'connectivity-service' of 'EnterprisesEnterpriseConnectivityService' must be provided or added to 'unchanged'")
		}
		paramsConnectivityService = append(paramsConnectivityService, stringValConnectivityService)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseConnectivityServiceConnectivityService", paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connectivity-service"), paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	if jsonObj.Enabled != nil { // Optional leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseConnectivityServiceEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSite converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSite(
	jsonObj *types.EnterprisesEnterpriseSite, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device []EnterprisesEnterpriseSiteDevice
	if jsonObj.Device != nil { // Optional leaf

	}
	// Property: device-group []EnterprisesEnterpriseSiteDeviceGroup
	if jsonObj.DeviceGroup != nil { // Optional leaf

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-definition EnterprisesEnterpriseSiteImsiDefinition
	if jsonObj.ImsiDefinition != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteImsiDefinition(
			jsonObj.ImsiDefinition, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "imsi-definition"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: ip-domain []EnterprisesEnterpriseSiteIpDomain
	if jsonObj.IpDomain != nil { // Optional leaf

	}
	// Property: monitoring EnterprisesEnterpriseSiteMonitoring
	if jsonObj.Monitoring != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteMonitoring(
			jsonObj.Monitoring, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "monitoring"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: priority-traffic-rule []EnterprisesEnterpriseSitePriorityTrafficRule
	if jsonObj.PriorityTrafficRule != nil { // Optional leaf

	}
	// Property: sim-card []EnterprisesEnterpriseSiteSimCard
	if jsonObj.SimCard != nil { // Optional leaf

	}
	// Property: site-id string
	_, unchangedSiteId := unchangedAttrs["site-id"]
	if !unchangedSiteId { // Mandatory leaf

		paramsSiteId := make([]string, len(params))
		copy(paramsSiteId, params)
		stringValSiteId := fmt.Sprintf("%v", jsonObj.SiteId)
		if stringValSiteId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'site-id' of 'EnterprisesEnterpriseSite' must be provided or added to 'unchanged'")
		}
		paramsSiteId = append(paramsSiteId, stringValSiteId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSiteId", paramsSiteId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/site-id"), paramsSiteId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: slice []EnterprisesEnterpriseSiteSlice
	if jsonObj.Slice != nil { // Optional leaf

	}
	// Property: small-cell []EnterprisesEnterpriseSiteSmallCell
	if jsonObj.SmallCell != nil { // Optional leaf

	}
	// Property: upf []EnterprisesEnterpriseSiteUpf
	if jsonObj.Upf != nil { // Optional leaf

	}

	// Property: device []EnterprisesEnterpriseSiteDevice
	if jsonObj.Device != nil {
		for _, item := range *jsonObj.Device {
			item := item //Pinning
			paramsDevice := make([]string, len(params))
			copy(paramsDevice, params)
			paramsDevice = append(paramsDevice, "unknown_id")
			updatesDevice, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteDevice(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device"), paramsDevice...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDevice...)
		}
	}

	// Property: device-group []EnterprisesEnterpriseSiteDeviceGroup
	if jsonObj.DeviceGroup != nil {
		for _, item := range *jsonObj.DeviceGroup {
			item := item //Pinning
			paramsDeviceGroup := make([]string, len(params))
			copy(paramsDeviceGroup, params)
			paramsDeviceGroup = append(paramsDeviceGroup, "unknown_id")
			updatesDeviceGroup, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroup(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device-group"), paramsDeviceGroup...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDeviceGroup...)
		}
	}

	// Property: ip-domain []EnterprisesEnterpriseSiteIpDomain
	if jsonObj.IpDomain != nil {
		for _, item := range *jsonObj.IpDomain {
			item := item //Pinning
			paramsIpDomain := make([]string, len(params))
			copy(paramsIpDomain, params)
			paramsIpDomain = append(paramsIpDomain, "unknown_id")
			updatesIpDomain, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteIpDomain(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "ip-domain"), paramsIpDomain...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesIpDomain...)
		}
	}

	// Property: priority-traffic-rule []EnterprisesEnterpriseSitePriorityTrafficRule
	if jsonObj.PriorityTrafficRule != nil {
		for _, item := range *jsonObj.PriorityTrafficRule {
			item := item //Pinning
			paramsPriorityTrafficRule := make([]string, len(params))
			copy(paramsPriorityTrafficRule, params)
			paramsPriorityTrafficRule = append(paramsPriorityTrafficRule, "unknown_id")
			updatesPriorityTrafficRule, err :=
				EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRule(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "priority-traffic-rule"), paramsPriorityTrafficRule...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesPriorityTrafficRule...)
		}
	}

	// Property: sim-card []EnterprisesEnterpriseSiteSimCard
	if jsonObj.SimCard != nil {
		for _, item := range *jsonObj.SimCard {
			item := item //Pinning
			paramsSimCard := make([]string, len(params))
			copy(paramsSimCard, params)
			paramsSimCard = append(paramsSimCard, "unknown_id")
			updatesSimCard, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteSimCard(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "sim-card"), paramsSimCard...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSimCard...)
		}
	}

	// Property: slice []EnterprisesEnterpriseSiteSlice
	if jsonObj.Slice != nil {
		for _, item := range *jsonObj.Slice {
			item := item //Pinning
			paramsSlice := make([]string, len(params))
			copy(paramsSlice, params)
			paramsSlice = append(paramsSlice, "unknown_id")
			updatesSlice, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteSlice(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "slice"), paramsSlice...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSlice...)
		}
	}

	// Property: small-cell []EnterprisesEnterpriseSiteSmallCell
	if jsonObj.SmallCell != nil {
		for _, item := range *jsonObj.SmallCell {
			item := item //Pinning
			paramsSmallCell := make([]string, len(params))
			copy(paramsSmallCell, params)
			paramsSmallCell = append(paramsSmallCell, "unknown_id")
			updatesSmallCell, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteSmallCell(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "small-cell"), paramsSmallCell...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSmallCell...)
		}
	}

	// Property: upf []EnterprisesEnterpriseSiteUpf
	if jsonObj.Upf != nil {
		for _, item := range *jsonObj.Upf {
			item := item //Pinning
			paramsUpf := make([]string, len(params))
			copy(paramsUpf, params)
			paramsUpf = append(paramsUpf, "unknown_id")
			updatesUpf, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteUpf(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "upf"), paramsUpf...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesUpf...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSite", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDevice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDevice(
	jsonObj *types.EnterprisesEnterpriseSiteDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dev-id string
	_, unchangedDevId := unchangedAttrs["dev-id"]
	if !unchangedDevId { // Mandatory leaf

		paramsDevId := make([]string, len(params))
		copy(paramsDevId, params)
		stringValDevId := fmt.Sprintf("%v", jsonObj.DevId)
		if stringValDevId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'dev-id' of 'EnterprisesEnterpriseSiteDevice' must be provided or added to 'unchanged'")
		}
		paramsDevId = append(paramsDevId, stringValDevId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceDevId", paramsDevId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dev-id"), paramsDevId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imei int64
	if jsonObj.Imei != nil { // Optional leaf

		paramsImei := make([]string, len(params))
		copy(paramsImei, params)
		stringValImei := fmt.Sprintf("%v", *jsonObj.Imei)

		paramsImei = append(paramsImei, stringValImei)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceImei", paramsImei...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imei"), paramsImei...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sim-card string
	if jsonObj.SimCard != nil { // Optional leaf

		paramsSimCard := make([]string, len(params))
		copy(paramsSimCard, params)
		stringValSimCard := fmt.Sprintf("%v", *jsonObj.SimCard)

		paramsSimCard = append(paramsSimCard, stringValSimCard)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceSimCard", paramsSimCard...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sim-card"), paramsSimCard...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroup(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device []EnterprisesEnterpriseSiteDeviceGroupDevice
	if jsonObj.Device != nil { // Optional leaf

	}
	// Property: dg-id string
	_, unchangedDgId := unchangedAttrs["dg-id"]
	if !unchangedDgId { // Mandatory leaf

		paramsDgId := make([]string, len(params))
		copy(paramsDgId, params)
		stringValDgId := fmt.Sprintf("%v", jsonObj.DgId)
		if stringValDgId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'dg-id' of 'EnterprisesEnterpriseSiteDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsDgId = append(paramsDgId, stringValDgId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDgId", paramsDgId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dg-id"), paramsDgId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: ip-domain string
	if jsonObj.IpDomain != nil { // Optional leaf

		paramsIpDomain := make([]string, len(params))
		copy(paramsIpDomain, params)
		stringValIpDomain := fmt.Sprintf("%v", *jsonObj.IpDomain)

		paramsIpDomain = append(paramsIpDomain, stringValIpDomain)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupIpDomain", paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-domain"), paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mbr EnterprisesEnterpriseSiteDeviceGroupMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	// Property: device []EnterprisesEnterpriseSiteDeviceGroupDevice
	if jsonObj.Device != nil {
		for _, item := range *jsonObj.Device {
			item := item //Pinning
			paramsDevice := make([]string, len(params))
			copy(paramsDevice, params)
			paramsDevice = append(paramsDevice, "unknown_id")
			updatesDevice, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDevice(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device"), paramsDevice...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDevice...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDevice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupDevice(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroupDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-id string
	_, unchangedDeviceId := unchangedAttrs["device-id"]
	if !unchangedDeviceId { // Mandatory leaf

		paramsDeviceId := make([]string, len(params))
		copy(paramsDeviceId, params)
		stringValDeviceId := fmt.Sprintf("%v", jsonObj.DeviceId)
		if stringValDeviceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device-id' of 'EnterprisesEnterpriseSiteDeviceGroupDevice' must be provided or added to 'unchanged'")
		}
		paramsDeviceId = append(paramsDeviceId, stringValDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDeviceDeviceId", paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-id"), paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupDeviceEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDeviceGroupDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteDeviceGroupMbr(
	jsonObj *types.EnterprisesEnterpriseSiteDeviceGroupMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	_, unchangedDownlink := unchangedAttrs["downlink"]
	if !unchangedDownlink { // Mandatory leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	_, unchangedTrafficClass := unchangedAttrs["traffic-class"]
	if !unchangedTrafficClass { // Mandatory leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", jsonObj.TrafficClass)
		if stringValTrafficClass == "" {
			return nil, liberrors.NewInvalid("mandatory field 'traffic-class' of 'EnterprisesEnterpriseSiteDeviceGroupMbr' must be provided or added to 'unchanged'")
		}
		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupMbrTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	_, unchangedUplink := unchangedAttrs["uplink"]
	if !unchangedUplink { // Mandatory leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteDeviceGroupMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteDeviceGroupMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteImsiDefinition converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteImsiDefinition(
	jsonObj *types.EnterprisesEnterpriseSiteImsiDefinition, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise int32
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)

		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: format string
	_, unchangedFormat := unchangedAttrs["format"]
	if !unchangedFormat { // Mandatory leaf

		paramsFormat := make([]string, len(params))
		copy(paramsFormat, params)
		stringValFormat := fmt.Sprintf("%v", jsonObj.Format)
		if stringValFormat == "" {
			return nil, liberrors.NewInvalid("mandatory field 'format' of 'EnterprisesEnterpriseSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsFormat = append(paramsFormat, stringValFormat)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionFormat", paramsFormat...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/format"), paramsFormat...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mcc string
	_, unchangedMcc := unchangedAttrs["mcc"]
	if !unchangedMcc { // Mandatory leaf

		paramsMcc := make([]string, len(params))
		copy(paramsMcc, params)
		stringValMcc := fmt.Sprintf("%v", jsonObj.Mcc)
		if stringValMcc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mcc' of 'EnterprisesEnterpriseSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMcc = append(paramsMcc, stringValMcc)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionMcc", paramsMcc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mcc"), paramsMcc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mnc string
	_, unchangedMnc := unchangedAttrs["mnc"]
	if !unchangedMnc { // Mandatory leaf

		paramsMnc := make([]string, len(params))
		copy(paramsMnc, params)
		stringValMnc := fmt.Sprintf("%v", jsonObj.Mnc)
		if stringValMnc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mnc' of 'EnterprisesEnterpriseSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMnc = append(paramsMnc, stringValMnc)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteImsiDefinitionMnc", paramsMnc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mnc"), paramsMnc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteImsiDefinition", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteIpDomain converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteIpDomain(
	jsonObj *types.EnterprisesEnterpriseSiteIpDomain, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: admin-status string
	if jsonObj.AdminStatus != nil { // Optional leaf

		paramsAdminStatus := make([]string, len(params))
		copy(paramsAdminStatus, params)
		stringValAdminStatus := fmt.Sprintf("%v", *jsonObj.AdminStatus)

		paramsAdminStatus = append(paramsAdminStatus, stringValAdminStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainAdminStatus", paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/admin-status"), paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dnn string
	_, unchangedDnn := unchangedAttrs["dnn"]
	if !unchangedDnn { // Mandatory leaf

		paramsDnn := make([]string, len(params))
		copy(paramsDnn, params)
		stringValDnn := fmt.Sprintf("%v", jsonObj.Dnn)
		if stringValDnn == "" {
			return nil, liberrors.NewInvalid("mandatory field 'dnn' of 'EnterprisesEnterpriseSiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsDnn = append(paramsDnn, stringValDnn)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDnn", paramsDnn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dnn"), paramsDnn...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-primary string
	if jsonObj.DnsPrimary != nil { // Optional leaf

		paramsDnsPrimary := make([]string, len(params))
		copy(paramsDnsPrimary, params)
		stringValDnsPrimary := fmt.Sprintf("%v", *jsonObj.DnsPrimary)

		paramsDnsPrimary = append(paramsDnsPrimary, stringValDnsPrimary)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDnsPrimary", paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-primary"), paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-secondary string
	if jsonObj.DnsSecondary != nil { // Optional leaf

		paramsDnsSecondary := make([]string, len(params))
		copy(paramsDnsSecondary, params)
		stringValDnsSecondary := fmt.Sprintf("%v", *jsonObj.DnsSecondary)

		paramsDnsSecondary = append(paramsDnsSecondary, stringValDnsSecondary)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainDnsSecondary", paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-secondary"), paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: ip-id string
	_, unchangedIpId := unchangedAttrs["ip-id"]
	if !unchangedIpId { // Mandatory leaf

		paramsIpId := make([]string, len(params))
		copy(paramsIpId, params)
		stringValIpId := fmt.Sprintf("%v", jsonObj.IpId)
		if stringValIpId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'ip-id' of 'EnterprisesEnterpriseSiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsIpId = append(paramsIpId, stringValIpId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainIpId", paramsIpId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-id"), paramsIpId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mtu int
	if jsonObj.Mtu != nil { // Optional leaf

		paramsMtu := make([]string, len(params))
		copy(paramsMtu, params)
		stringValMtu := fmt.Sprintf("%v", *jsonObj.Mtu)

		paramsMtu = append(paramsMtu, stringValMtu)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainMtu", paramsMtu...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mtu"), paramsMtu...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: subnet string
	_, unchangedSubnet := unchangedAttrs["subnet"]
	if !unchangedSubnet { // Mandatory leaf

		paramsSubnet := make([]string, len(params))
		copy(paramsSubnet, params)
		stringValSubnet := fmt.Sprintf("%v", jsonObj.Subnet)
		if stringValSubnet == "" {
			return nil, liberrors.NewInvalid("mandatory field 'subnet' of 'EnterprisesEnterpriseSiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsSubnet = append(paramsSubnet, stringValSubnet)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteIpDomainSubnet", paramsSubnet...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/subnet"), paramsSubnet...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteIpDomain", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteMonitoring converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteMonitoring(
	jsonObj *types.EnterprisesEnterpriseSiteMonitoring, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: edge-cluster-prometheus-url string
	if jsonObj.EdgeClusterPrometheusUrl != nil { // Optional leaf

		paramsEdgeClusterPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeClusterPrometheusUrl, params)
		stringValEdgeClusterPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeClusterPrometheusUrl)

		paramsEdgeClusterPrometheusUrl = append(paramsEdgeClusterPrometheusUrl, stringValEdgeClusterPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeClusterPrometheusUrl", paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-cluster-prometheus-url"), paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: edge-device []EnterprisesEnterpriseSiteMonitoringEdgeDevice
	if jsonObj.EdgeDevice != nil { // Optional leaf

	}
	// Property: edge-monitoring-prometheus-url string
	if jsonObj.EdgeMonitoringPrometheusUrl != nil { // Optional leaf

		paramsEdgeMonitoringPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeMonitoringPrometheusUrl, params)
		stringValEdgeMonitoringPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeMonitoringPrometheusUrl)

		paramsEdgeMonitoringPrometheusUrl = append(paramsEdgeMonitoringPrometheusUrl, stringValEdgeMonitoringPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeMonitoringPrometheusUrl", paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-monitoring-prometheus-url"), paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: edge-device []EnterprisesEnterpriseSiteMonitoringEdgeDevice
	if jsonObj.EdgeDevice != nil {
		for _, item := range *jsonObj.EdgeDevice {
			item := item //Pinning
			paramsEdgeDevice := make([]string, len(params))
			copy(paramsEdgeDevice, params)
			paramsEdgeDevice = append(paramsEdgeDevice, "unknown_id")
			updatesEdgeDevice, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDevice(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "edge-device"), paramsEdgeDevice...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEdgeDevice...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDevice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteMonitoringEdgeDevice(
	jsonObj *types.EnterprisesEnterpriseSiteMonitoringEdgeDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeDeviceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeDeviceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: edge-device-id string
	_, unchangedEdgeDeviceId := unchangedAttrs["edge-device-id"]
	if !unchangedEdgeDeviceId { // Mandatory leaf

		paramsEdgeDeviceId := make([]string, len(params))
		copy(paramsEdgeDeviceId, params)
		stringValEdgeDeviceId := fmt.Sprintf("%v", jsonObj.EdgeDeviceId)
		if stringValEdgeDeviceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'edge-device-id' of 'EnterprisesEnterpriseSiteMonitoringEdgeDevice' must be provided or added to 'unchanged'")
		}
		paramsEdgeDeviceId = append(paramsEdgeDeviceId, stringValEdgeDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteMonitoringEdgeDeviceEdgeDeviceId", paramsEdgeDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-device-id"), paramsEdgeDeviceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteMonitoringEdgeDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRule converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRule(
	jsonObj *types.EnterprisesEnterpriseSitePriorityTrafficRule, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: application string
	_, unchangedApplication := unchangedAttrs["application"]
	if !unchangedApplication { // Mandatory leaf

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)
		if stringValApplication == "" {
			return nil, liberrors.NewInvalid("mandatory field 'application' of 'EnterprisesEnterpriseSitePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		stringValDevice := fmt.Sprintf("%v", jsonObj.Device)
		if stringValDevice == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device' of 'EnterprisesEnterpriseSitePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsDevice = append(paramsDevice, stringValDevice)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint string
	_, unchangedEndpoint := unchangedAttrs["endpoint"]
	if !unchangedEndpoint { // Mandatory leaf

		paramsEndpoint := make([]string, len(params))
		copy(paramsEndpoint, params)
		stringValEndpoint := fmt.Sprintf("%v", jsonObj.Endpoint)
		if stringValEndpoint == "" {
			return nil, liberrors.NewInvalid("mandatory field 'endpoint' of 'EnterprisesEnterpriseSitePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsEndpoint = append(paramsEndpoint, stringValEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleEndpoint", paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint"), paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: gbr EnterprisesEnterpriseSitePriorityTrafficRuleGbr
	if jsonObj.Gbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRuleGbr(
			jsonObj.Gbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "gbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: mbr EnterprisesEnterpriseSitePriorityTrafficRuleMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRuleMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: ptr-id string
	_, unchangedPtrId := unchangedAttrs["ptr-id"]
	if !unchangedPtrId { // Mandatory leaf

		paramsPtrId := make([]string, len(params))
		copy(paramsPtrId, params)
		stringValPtrId := fmt.Sprintf("%v", jsonObj.PtrId)
		if stringValPtrId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'ptr-id' of 'EnterprisesEnterpriseSitePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsPtrId = append(paramsPtrId, stringValPtrId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRulePtrId", paramsPtrId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ptr-id"), paramsPtrId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil { // Optional leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)

		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSitePriorityTrafficRule", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRuleGbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRuleGbr(
	jsonObj *types.EnterprisesEnterpriseSitePriorityTrafficRuleGbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleGbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleGbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSitePriorityTrafficRuleGbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRuleMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSitePriorityTrafficRuleMbr(
	jsonObj *types.EnterprisesEnterpriseSitePriorityTrafficRuleMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSitePriorityTrafficRuleMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSitePriorityTrafficRuleMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSimCard converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSimCard(
	jsonObj *types.EnterprisesEnterpriseSiteSimCard, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: iccid int64
	if jsonObj.Iccid != nil { // Optional leaf

		paramsIccid := make([]string, len(params))
		copy(paramsIccid, params)
		stringValIccid := fmt.Sprintf("%v", *jsonObj.Iccid)

		paramsIccid = append(paramsIccid, stringValIccid)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardIccid", paramsIccid...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/iccid"), paramsIccid...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi int64
	if jsonObj.Imsi != nil { // Optional leaf

		paramsImsi := make([]string, len(params))
		copy(paramsImsi, params)
		stringValImsi := fmt.Sprintf("%v", *jsonObj.Imsi)

		paramsImsi = append(paramsImsi, stringValImsi)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardImsi", paramsImsi...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi"), paramsImsi...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sim-id string
	_, unchangedSimId := unchangedAttrs["sim-id"]
	if !unchangedSimId { // Mandatory leaf

		paramsSimId := make([]string, len(params))
		copy(paramsSimId, params)
		stringValSimId := fmt.Sprintf("%v", jsonObj.SimId)
		if stringValSimId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'sim-id' of 'EnterprisesEnterpriseSiteSimCard' must be provided or added to 'unchanged'")
		}
		paramsSimId = append(paramsSimId, stringValSimId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSimCardSimId", paramsSimId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sim-id"), paramsSimId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSimCard", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSlice converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSlice(
	jsonObj *types.EnterprisesEnterpriseSiteSlice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'EnterprisesEnterpriseSiteSlice' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device-group []EnterprisesEnterpriseSiteSliceDeviceGroup
	if jsonObj.DeviceGroup != nil { // Optional leaf

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: filter []EnterprisesEnterpriseSiteSliceFilter
	if jsonObj.Filter != nil { // Optional leaf

	}
	// Property: mbr EnterprisesEnterpriseSiteSliceMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseSiteSliceMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sd int32
	_, unchangedSd := unchangedAttrs["sd"]
	if !unchangedSd { // Mandatory leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: slice-id string
	_, unchangedSliceId := unchangedAttrs["slice-id"]
	if !unchangedSliceId { // Mandatory leaf

		paramsSliceId := make([]string, len(params))
		copy(paramsSliceId, params)
		stringValSliceId := fmt.Sprintf("%v", jsonObj.SliceId)
		if stringValSliceId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'slice-id' of 'EnterprisesEnterpriseSiteSlice' must be provided or added to 'unchanged'")
		}
		paramsSliceId = append(paramsSliceId, stringValSliceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceSliceId", paramsSliceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/slice-id"), paramsSliceId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sst int
	_, unchangedSst := unchangedAttrs["sst"]
	if !unchangedSst { // Mandatory leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: upf string
	if jsonObj.Upf != nil { // Optional leaf

		paramsUpf := make([]string, len(params))
		copy(paramsUpf, params)
		stringValUpf := fmt.Sprintf("%v", *jsonObj.Upf)

		paramsUpf = append(paramsUpf, stringValUpf)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceUpf", paramsUpf...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf"), paramsUpf...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: device-group []EnterprisesEnterpriseSiteSliceDeviceGroup
	if jsonObj.DeviceGroup != nil {
		for _, item := range *jsonObj.DeviceGroup {
			item := item //Pinning
			paramsDeviceGroup := make([]string, len(params))
			copy(paramsDeviceGroup, params)
			paramsDeviceGroup = append(paramsDeviceGroup, "unknown_id")
			updatesDeviceGroup, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroup(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device-group"), paramsDeviceGroup...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDeviceGroup...)
		}
	}

	// Property: filter []EnterprisesEnterpriseSiteSliceFilter
	if jsonObj.Filter != nil {
		for _, item := range *jsonObj.Filter {
			item := item //Pinning
			paramsFilter := make([]string, len(params))
			copy(paramsFilter, params)
			paramsFilter = append(paramsFilter, "unknown_id")
			updatesFilter, err :=
				EncodeToGnmiEnterprisesEnterpriseSiteSliceFilter(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "filter"), paramsFilter...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesFilter...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSlice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceDeviceGroup(
	jsonObj *types.EnterprisesEnterpriseSiteSliceDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-group string
	_, unchangedDeviceGroup := unchangedAttrs["device-group"]
	if !unchangedDeviceGroup { // Mandatory leaf

		paramsDeviceGroup := make([]string, len(params))
		copy(paramsDeviceGroup, params)
		stringValDeviceGroup := fmt.Sprintf("%v", jsonObj.DeviceGroup)
		if stringValDeviceGroup == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device-group' of 'EnterprisesEnterpriseSiteSliceDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsDeviceGroup = append(paramsDeviceGroup, stringValDeviceGroup)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDeviceGroupDeviceGroup", paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-group"), paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceDeviceGroupEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSliceDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceFilter converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceFilter(
	jsonObj *types.EnterprisesEnterpriseSiteSliceFilter, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: allow bool
	if jsonObj.Allow != nil { // Optional leaf

		paramsAllow := make([]string, len(params))
		copy(paramsAllow, params)
		stringValAllow := fmt.Sprintf("%v", *jsonObj.Allow)

		paramsAllow = append(paramsAllow, stringValAllow)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceFilterAllow", paramsAllow...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/allow"), paramsAllow...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: application string
	_, unchangedApplication := unchangedAttrs["application"]
	if !unchangedApplication { // Mandatory leaf

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)
		if stringValApplication == "" {
			return nil, liberrors.NewInvalid("mandatory field 'application' of 'EnterprisesEnterpriseSiteSliceFilter' must be provided or added to 'unchanged'")
		}
		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceFilterApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: priority int
	if jsonObj.Priority != nil { // Optional leaf

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)

		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceFilterPriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSliceFilter", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSliceMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSliceMbr(
	jsonObj *types.EnterprisesEnterpriseSiteSliceMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSliceMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSliceMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteSmallCell converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteSmallCell(
	jsonObj *types.EnterprisesEnterpriseSiteSmallCell, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if jsonObj.Address != nil { // Optional leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", *jsonObj.Address)

		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: small-cell-id string
	_, unchangedSmallCellId := unchangedAttrs["small-cell-id"]
	if !unchangedSmallCellId { // Mandatory leaf

		paramsSmallCellId := make([]string, len(params))
		copy(paramsSmallCellId, params)
		stringValSmallCellId := fmt.Sprintf("%v", jsonObj.SmallCellId)
		if stringValSmallCellId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'small-cell-id' of 'EnterprisesEnterpriseSiteSmallCell' must be provided or added to 'unchanged'")
		}
		paramsSmallCellId = append(paramsSmallCellId, stringValSmallCellId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellSmallCellId", paramsSmallCellId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/small-cell-id"), paramsSmallCellId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: tac string
	_, unchangedTac := unchangedAttrs["tac"]
	if !unchangedTac { // Mandatory leaf

		paramsTac := make([]string, len(params))
		copy(paramsTac, params)
		stringValTac := fmt.Sprintf("%v", jsonObj.Tac)
		if stringValTac == "" {
			return nil, liberrors.NewInvalid("mandatory field 'tac' of 'EnterprisesEnterpriseSiteSmallCell' must be provided or added to 'unchanged'")
		}
		paramsTac = append(paramsTac, stringValTac)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteSmallCellTac", paramsTac...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tac"), paramsTac...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteSmallCell", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseSiteUpf converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseSiteUpf(
	jsonObj *types.EnterprisesEnterpriseSiteUpf, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'EnterprisesEnterpriseSiteUpf' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: config-endpoint string
	if jsonObj.ConfigEndpoint != nil { // Optional leaf

		paramsConfigEndpoint := make([]string, len(params))
		copy(paramsConfigEndpoint, params)
		stringValConfigEndpoint := fmt.Sprintf("%v", *jsonObj.ConfigEndpoint)

		paramsConfigEndpoint = append(paramsConfigEndpoint, stringValConfigEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfConfigEndpoint", paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/config-endpoint"), paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port int
	_, unchangedPort := unchangedAttrs["port"]
	if !unchangedPort { // Mandatory leaf

		paramsPort := make([]string, len(params))
		copy(paramsPort, params)
		stringValPort := fmt.Sprintf("%v", jsonObj.Port)

		paramsPort = append(paramsPort, stringValPort)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfPort", paramsPort...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port"), paramsPort...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: upf-id string
	_, unchangedUpfId := unchangedAttrs["upf-id"]
	if !unchangedUpfId { // Mandatory leaf

		paramsUpfId := make([]string, len(params))
		copy(paramsUpfId, params)
		stringValUpfId := fmt.Sprintf("%v", jsonObj.UpfId)
		if stringValUpfId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'upf-id' of 'EnterprisesEnterpriseSiteUpf' must be provided or added to 'unchanged'")
		}
		paramsUpfId = append(paramsUpfId, stringValUpfId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseSiteUpfUpfId", paramsUpfId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf-id"), paramsUpfId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseSiteUpf", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTemplate converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseTemplate(
	jsonObj *types.EnterprisesEnterpriseTemplate, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'EnterprisesEnterpriseTemplate' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mbr EnterprisesEnterpriseTemplateMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiEnterprisesEnterpriseTemplateMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sd int32
	if jsonObj.Sd != nil { // Optional leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", *jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sst int
	if jsonObj.Sst != nil { // Optional leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", *jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: tp-id string
	_, unchangedTpId := unchangedAttrs["tp-id"]
	if !unchangedTpId { // Mandatory leaf

		paramsTpId := make([]string, len(params))
		copy(paramsTpId, params)
		stringValTpId := fmt.Sprintf("%v", jsonObj.TpId)
		if stringValTpId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'tp-id' of 'EnterprisesEnterpriseTemplate' must be provided or added to 'unchanged'")
		}
		paramsTpId = append(paramsTpId, stringValTpId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateTpId", paramsTpId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tp-id"), paramsTpId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseTemplate", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTemplateMbr converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseTemplateMbr(
	jsonObj *types.EnterprisesEnterpriseTemplateMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTemplateMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseTemplateMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprisesEnterpriseTrafficClass converts OAPI to gNMI.
func EncodeToGnmiEnterprisesEnterpriseTrafficClass(
	jsonObj *types.EnterprisesEnterpriseTrafficClass, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: arp int
	if jsonObj.Arp != nil { // Optional leaf

		paramsArp := make([]string, len(params))
		copy(paramsArp, params)
		stringValArp := fmt.Sprintf("%v", *jsonObj.Arp)

		paramsArp = append(paramsArp, stringValArp)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassArp", paramsArp...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/arp"), paramsArp...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pdb int
	if jsonObj.Pdb != nil { // Optional leaf

		paramsPdb := make([]string, len(params))
		copy(paramsPdb, params)
		stringValPdb := fmt.Sprintf("%v", *jsonObj.Pdb)

		paramsPdb = append(paramsPdb, stringValPdb)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassPdb", paramsPdb...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pdb"), paramsPdb...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pelr int
	if jsonObj.Pelr != nil { // Optional leaf

		paramsPelr := make([]string, len(params))
		copy(paramsPelr, params)
		stringValPelr := fmt.Sprintf("%v", *jsonObj.Pelr)

		paramsPelr = append(paramsPelr, stringValPelr)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassPelr", paramsPelr...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pelr"), paramsPelr...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qci int
	if jsonObj.Qci != nil { // Optional leaf

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)

		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: tc-id string
	_, unchangedTcId := unchangedAttrs["tc-id"]
	if !unchangedTcId { // Mandatory leaf

		paramsTcId := make([]string, len(params))
		copy(paramsTcId, params)
		stringValTcId := fmt.Sprintf("%v", jsonObj.TcId)
		if stringValTcId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'tc-id' of 'EnterprisesEnterpriseTrafficClass' must be provided or added to 'unchanged'")
		}
		paramsTcId = append(paramsTcId, stringValTcId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterprisesEnterpriseTrafficClassTcId", paramsTcId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tc-id"), paramsTcId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterprisesEnterpriseTrafficClass", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

//Ignoring Target

//Ignoring RequestBodyConnectivityServices

//Ignoring RequestBodyConnectivityServicesConnectivityService

//Ignoring RequestBodyEnterprises

//Ignoring RequestBodyEnterprisesEnterprise

//Ignoring RequestBodyEnterprisesEnterpriseApplication

//Ignoring RequestBodyEnterprisesEnterpriseApplicationEndpoint

//Ignoring RequestBodyEnterprisesEnterpriseApplicationEndpointMbr

//Ignoring RequestBodyEnterprisesEnterpriseConnectivityService

//Ignoring RequestBodyEnterprisesEnterpriseSite

//Ignoring RequestBodyEnterprisesEnterpriseSiteDevice

//Ignoring RequestBodyEnterprisesEnterpriseSiteDeviceGroup

//Ignoring RequestBodyEnterprisesEnterpriseSiteDeviceGroupDevice

//Ignoring RequestBodyEnterprisesEnterpriseSiteDeviceGroupMbr

//Ignoring RequestBodyEnterprisesEnterpriseSiteImsiDefinition

//Ignoring RequestBodyEnterprisesEnterpriseSiteIpDomain

//Ignoring RequestBodyEnterprisesEnterpriseSiteMonitoring

//Ignoring RequestBodyEnterprisesEnterpriseSiteMonitoringEdgeDevice

//Ignoring RequestBodyEnterprisesEnterpriseSitePriorityTrafficRule

//Ignoring RequestBodyEnterprisesEnterpriseSitePriorityTrafficRuleGbr

//Ignoring RequestBodyEnterprisesEnterpriseSitePriorityTrafficRuleMbr

//Ignoring RequestBodyEnterprisesEnterpriseSiteSimCard

//Ignoring RequestBodyEnterprisesEnterpriseSiteSlice

//Ignoring RequestBodyEnterprisesEnterpriseSiteSliceDeviceGroup

//Ignoring RequestBodyEnterprisesEnterpriseSiteSliceFilter

//Ignoring RequestBodyEnterprisesEnterpriseSiteSliceMbr

//Ignoring RequestBodyEnterprisesEnterpriseSiteSmallCell

//Ignoring RequestBodyEnterprisesEnterpriseSiteUpf

//Ignoring RequestBodyEnterprisesEnterpriseTemplate

//Ignoring RequestBodyEnterprisesEnterpriseTemplateMbr

//Ignoring RequestBodyEnterprisesEnterpriseTrafficClass

// Not generating param-types
// Not generating request-bodies

// Not generating additional-properties
// Not generating additional-properties
