// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	"reflect"
	"regexp"

	"github.com/onosproject/aether-roc-api/pkg/aether_2_0_0/types"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	externalRef0 "github.com/onosproject/config-models/modelplugin/aether-2.0.0/aether_2_0_0"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

// EncodeToGnmiAccessProfile converts OAPI to gNMI.
func EncodeToGnmiAccessProfile(
	jsonObj *types.AccessProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { access-profile {[]AccessProfileAccessProfile  0xc0002ec000 map[] [] false <nil> [] false} false false}
	if jsonObj.AccessProfile != nil {

	}

	//Property: { access-profile {[]AccessProfileAccessProfile  0xc0002ec000 map[] [] false <nil> [] false} false false}
	if jsonObj.AccessProfile != nil {
		for _, item := range *jsonObj.AccessProfile {
			item := item //Pinning
			paramsAccessProfile := make([]string, len(params))
			copy(paramsAccessProfile, params)
			paramsAccessProfile = append(paramsAccessProfile, "unknown_id")
			updatesAccessProfile, err :=
				EncodeToGnmiAccessProfileAccessProfile(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "access-profile"), paramsAccessProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesAccessProfile...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "AccessProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiAccessProfileAccessProfile converts OAPI to gNMI.
func EncodeToGnmiAccessProfileAccessProfile(
	jsonObj *types.AccessProfileAccessProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { description {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { filter {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Filter != nil {

		paramsFilter := make([]string, len(params))
		copy(paramsFilter, params)
		stringValFilter := fmt.Sprintf("%v", *jsonObj.Filter)
		paramsFilter = append(paramsFilter, stringValFilter)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileFilter", paramsFilter...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/filter"), paramsFilter...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { type {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Type != nil {

		paramsType := make([]string, len(params))
		copy(paramsType, params)
		stringValType := fmt.Sprintf("%v", *jsonObj.Type)
		paramsType = append(paramsType, stringValType)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileType", paramsType...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/type"), paramsType...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "AccessProfileAccessProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

//Ignoring AdditionalPropertyTarget

// EncodeToGnmiApnProfile converts OAPI to gNMI.
func EncodeToGnmiApnProfile(
	jsonObj *types.ApnProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { apn-profile {[]ApnProfileApnProfile  0xc0002ec380 map[] [] false <nil> [] false} false false}
	if jsonObj.ApnProfile != nil {

	}

	//Property: { apn-profile {[]ApnProfileApnProfile  0xc0002ec380 map[] [] false <nil> [] false} false false}
	if jsonObj.ApnProfile != nil {
		for _, item := range *jsonObj.ApnProfile {
			item := item //Pinning
			paramsApnProfile := make([]string, len(params))
			copy(paramsApnProfile, params)
			paramsApnProfile = append(paramsApnProfile, "unknown_id")
			updatesApnProfile, err :=
				EncodeToGnmiApnProfileApnProfile(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "apn-profile"), paramsApnProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesApnProfile...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApnProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiApnProfileApnProfile converts OAPI to gNMI.
func EncodeToGnmiApnProfileApnProfile(
	jsonObj *types.ApnProfileApnProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { apn-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ApnName != nil {

		paramsApnName := make([]string, len(params))
		copy(paramsApnName, params)
		stringValApnName := fmt.Sprintf("%v", *jsonObj.ApnName)
		paramsApnName = append(paramsApnName, stringValApnName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileApnName", paramsApnName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/apn-name"), paramsApnName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { description {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { dns-primary {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DnsPrimary != nil {

		paramsDnsPrimary := make([]string, len(params))
		copy(paramsDnsPrimary, params)
		stringValDnsPrimary := fmt.Sprintf("%v", *jsonObj.DnsPrimary)
		paramsDnsPrimary = append(paramsDnsPrimary, stringValDnsPrimary)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDnsPrimary", paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-primary"), paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { dns-secondary {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DnsSecondary != nil {

		paramsDnsSecondary := make([]string, len(params))
		copy(paramsDnsSecondary, params)
		stringValDnsSecondary := fmt.Sprintf("%v", *jsonObj.DnsSecondary)
		paramsDnsSecondary = append(paramsDnsSecondary, stringValDnsSecondary)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDnsSecondary", paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-secondary"), paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { gx-enabled {bool  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.GxEnabled != nil {

		paramsGxEnabled := make([]string, len(params))
		copy(paramsGxEnabled, params)
		stringValGxEnabled := fmt.Sprintf("%v", *jsonObj.GxEnabled)
		paramsGxEnabled = append(paramsGxEnabled, stringValGxEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileGxEnabled", paramsGxEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/gx-enabled"), paramsGxEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { mtu {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Mtu != nil {

		paramsMtu := make([]string, len(params))
		copy(paramsMtu, params)
		stringValMtu := fmt.Sprintf("%v", *jsonObj.Mtu)
		paramsMtu = append(paramsMtu, stringValMtu)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileMtu", paramsMtu...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mtu"), paramsMtu...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApnProfileApnProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityService(
	jsonObj *types.ConnectivityService, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { connectivity-service {[]ConnectivityServiceConnectivityService  0xc0002ec700 map[] [] false <nil> [] false} false false}
	if jsonObj.ConnectivityService != nil {

	}

	//Property: { connectivity-service {[]ConnectivityServiceConnectivityService  0xc0002ec700 map[] [] false <nil> [] false} false false}
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiConnectivityServiceConnectivityService(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityServiceConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityServiceConnectivityService(
	jsonObj *types.ConnectivityServiceConnectivityService, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { description {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { hss-endpoint {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.HssEndpoint != nil {

		paramsHssEndpoint := make([]string, len(params))
		copy(paramsHssEndpoint, params)
		stringValHssEndpoint := fmt.Sprintf("%v", *jsonObj.HssEndpoint)
		paramsHssEndpoint = append(paramsHssEndpoint, stringValHssEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceHssEndpoint", paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/hss-endpoint"), paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { spgwc-endpoint {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.SpgwcEndpoint != nil {

		paramsSpgwcEndpoint := make([]string, len(params))
		copy(paramsSpgwcEndpoint, params)
		stringValSpgwcEndpoint := fmt.Sprintf("%v", *jsonObj.SpgwcEndpoint)
		paramsSpgwcEndpoint = append(paramsSpgwcEndpoint, stringValSpgwcEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceSpgwcEndpoint", paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/spgwc-endpoint"), paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServiceConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterprise(
	jsonObj *types.Enterprise, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { enterprise {[]EnterpriseEnterprise  0xc0002eca80 map[] [] false <nil> [] false} false false}
	if jsonObj.Enterprise != nil {

	}

	//Property: { enterprise {[]EnterpriseEnterprise  0xc0002eca80 map[] [] false <nil> [] false} false false}
	if jsonObj.Enterprise != nil {
		for _, item := range *jsonObj.Enterprise {
			item := item //Pinning
			paramsEnterprise := make([]string, len(params))
			copy(paramsEnterprise, params)
			paramsEnterprise = append(paramsEnterprise, "unknown_id")
			updatesEnterprise, err :=
				EncodeToGnmiEnterpriseEnterprise(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "enterprise"), paramsEnterprise...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEnterprise...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "Enterprise", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterprise(
	jsonObj *types.EnterpriseEnterprise, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { connectivity-service {[]EnterpriseEnterpriseConnectivityService  0xc0002ecc80 map[] [] false <nil> [] false} false false}
	if jsonObj.ConnectivityService != nil {

	}
	//Property: { description {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	//Property: { connectivity-service {[]EnterpriseEnterpriseConnectivityService  0xc0002ecc80 map[] [] false <nil> [] false} false false}
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiEnterpriseEnterpriseConnectivityService(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterprise", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterpriseConnectivityService converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterpriseConnectivityService(
	jsonObj *types.EnterpriseEnterpriseConnectivityService, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { connectivity-service {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ConnectivityService != nil {

		paramsConnectivityService := make([]string, len(params))
		copy(paramsConnectivityService, params)
		stringValConnectivityService := fmt.Sprintf("%v", *jsonObj.ConnectivityService)
		paramsConnectivityService = append(paramsConnectivityService, stringValConnectivityService)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceConnectivityService", paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connectivity-service"), paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { enabled {bool  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Enabled != nil {

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)
		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterpriseConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfile converts OAPI to gNMI.
func EncodeToGnmiQosProfile(
	jsonObj *types.QosProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { qos-profile {[]QosProfileQosProfile  0xc0002eda00 map[] [] false <nil> [] false} false false}
	if jsonObj.QosProfile != nil {

	}

	//Property: { qos-profile {[]QosProfileQosProfile  0xc0002eda00 map[] [] false <nil> [] false} false false}
	if jsonObj.QosProfile != nil {
		for _, item := range *jsonObj.QosProfile {
			item := item //Pinning
			paramsQosProfile := make([]string, len(params))
			copy(paramsQosProfile, params)
			paramsQosProfile = append(paramsQosProfile, "unknown_id")
			updatesQosProfile, err :=
				EncodeToGnmiQosProfileQosProfile(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "qos-profile"), paramsQosProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesQosProfile...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfileQosProfile converts OAPI to gNMI.
func EncodeToGnmiQosProfileQosProfile(
	jsonObj *types.QosProfileQosProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { apn-ambr {QosProfileQosProfileApnAmbr  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ApnAmbr != nil {

		update, err := EncodeToGnmiQosProfileQosProfileApnAmbr(
			jsonObj.ApnAmbr, false, target,
			fmt.Sprintf("%s/%s", parentPath, "apn-ambr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	//Property: { arp {QosProfileQosProfileArp  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Arp != nil {

		update, err := EncodeToGnmiQosProfileQosProfileArp(
			jsonObj.Arp, false, target,
			fmt.Sprintf("%s/%s", parentPath, "arp"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	//Property: { description {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { qci {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Qci != nil {

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)
		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfileQosProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfileQosProfileApnAmbr converts OAPI to gNMI.
func EncodeToGnmiQosProfileQosProfileApnAmbr(
	jsonObj *types.QosProfileQosProfileApnAmbr, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { downlink {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileApnAmbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { uplink {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileApnAmbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfileQosProfileApnAmbr", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfileQosProfileArp converts OAPI to gNMI.
func EncodeToGnmiQosProfileQosProfileArp(
	jsonObj *types.QosProfileQosProfileArp, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { preemption-capability {bool  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.PreemptionCapability != nil {

		paramsPreemptionCapability := make([]string, len(params))
		copy(paramsPreemptionCapability, params)
		stringValPreemptionCapability := fmt.Sprintf("%v", *jsonObj.PreemptionCapability)
		paramsPreemptionCapability = append(paramsPreemptionCapability, stringValPreemptionCapability)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileArpPreemptionCapability", paramsPreemptionCapability...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/preemption-capability"), paramsPreemptionCapability...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { preemption-vulnerability {bool  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.PreemptionVulnerability != nil {

		paramsPreemptionVulnerability := make([]string, len(params))
		copy(paramsPreemptionVulnerability, params)
		stringValPreemptionVulnerability := fmt.Sprintf("%v", *jsonObj.PreemptionVulnerability)
		paramsPreemptionVulnerability = append(paramsPreemptionVulnerability, stringValPreemptionVulnerability)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileArpPreemptionVulnerability", paramsPreemptionVulnerability...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/preemption-vulnerability"), paramsPreemptionVulnerability...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { priority {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Priority != nil {

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)
		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileArpPriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfileQosProfileArp", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiSecurityProfile converts OAPI to gNMI.
func EncodeToGnmiSecurityProfile(
	jsonObj *types.SecurityProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { security-profile {[]SecurityProfileSecurityProfile  0xc0002edf80 map[] [] false <nil> [] false} false false}
	if jsonObj.SecurityProfile != nil {

	}

	//Property: { security-profile {[]SecurityProfileSecurityProfile  0xc0002edf80 map[] [] false <nil> [] false} false false}
	if jsonObj.SecurityProfile != nil {
		for _, item := range *jsonObj.SecurityProfile {
			item := item //Pinning
			paramsSecurityProfile := make([]string, len(params))
			copy(paramsSecurityProfile, params)
			paramsSecurityProfile = append(paramsSecurityProfile, "unknown_id")
			updatesSecurityProfile, err :=
				EncodeToGnmiSecurityProfileSecurityProfile(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "security-profile"), paramsSecurityProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSecurityProfile...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "SecurityProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiSecurityProfileSecurityProfile converts OAPI to gNMI.
func EncodeToGnmiSecurityProfileSecurityProfile(
	jsonObj *types.SecurityProfileSecurityProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { description {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { key {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Key != nil {

		paramsKey := make([]string, len(params))
		copy(paramsKey, params)
		stringValKey := fmt.Sprintf("%v", *jsonObj.Key)
		paramsKey = append(paramsKey, stringValKey)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileKey", paramsKey...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/key"), paramsKey...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { opc {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Opc != nil {

		paramsOpc := make([]string, len(params))
		copy(paramsOpc, params)
		stringValOpc := fmt.Sprintf("%v", *jsonObj.Opc)
		paramsOpc = append(paramsOpc, stringValOpc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileOpc", paramsOpc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/opc"), paramsOpc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { sqn {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Sqn != nil {

		paramsSqn := make([]string, len(params))
		copy(paramsSqn, params)
		stringValSqn := fmt.Sprintf("%v", *jsonObj.Sqn)
		paramsSqn = append(paramsSqn, stringValSqn)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileSqn", paramsSqn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sqn"), paramsSqn...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "SecurityProfileSecurityProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriber converts OAPI to gNMI.
func EncodeToGnmiSubscriber(
	jsonObj *types.Subscriber, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { ue {[]SubscriberUe  0xc0005c4f80 map[] [] false <nil> [] false} false false}
	if jsonObj.Ue != nil {

	}

	//Property: { ue {[]SubscriberUe  0xc0005c4f80 map[] [] false <nil> [] false} false false}
	if jsonObj.Ue != nil {
		for _, item := range *jsonObj.Ue {
			item := item //Pinning
			paramsUe := make([]string, len(params))
			copy(paramsUe, params)
			paramsUe = append(paramsUe, "unknown_id")
			updatesUe, err :=
				EncodeToGnmiSubscriberUe(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "ue"), paramsUe...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesUe...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "Subscriber", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUe converts OAPI to gNMI.
func EncodeToGnmiSubscriberUe(
	jsonObj *types.SubscriberUe, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { enabled {bool  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Enabled != nil {

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)
		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { enterprise {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Enterprise != nil {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", *jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: {For choice imsi:range imsi-range-from {int64  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ImsiRangeFrom != nil {

		paramsImsiRangeFrom := make([]string, len(params))
		copy(paramsImsiRangeFrom, params)
		stringValImsiRangeFrom := fmt.Sprintf("%v", *jsonObj.ImsiRangeFrom)
		paramsImsiRangeFrom = append(paramsImsiRangeFrom, stringValImsiRangeFrom)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeImsiRangeFrom", paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-from"), paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: {For choice imsi:range imsi-range-to {int64  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ImsiRangeTo != nil {

		paramsImsiRangeTo := make([]string, len(params))
		copy(paramsImsiRangeTo, params)
		stringValImsiRangeTo := fmt.Sprintf("%v", *jsonObj.ImsiRangeTo)
		paramsImsiRangeTo = append(paramsImsiRangeTo, stringValImsiRangeTo)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeImsiRangeTo", paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-to"), paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: {For choice imsi:wildcard imsi-wildcard {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ImsiWildcard != nil {

		paramsImsiWildcard := make([]string, len(params))
		copy(paramsImsiWildcard, params)
		stringValImsiWildcard := fmt.Sprintf("%v", *jsonObj.ImsiWildcard)
		paramsImsiWildcard = append(paramsImsiWildcard, stringValImsiWildcard)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeImsiWildcard", paramsImsiWildcard...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-wildcard"), paramsImsiWildcard...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { priority {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Priority != nil {

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)
		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUePriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { profiles {SubscriberUeProfiles  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Profiles != nil {

		update, err := EncodeToGnmiSubscriberUeProfiles(
			jsonObj.Profiles, false, target,
			fmt.Sprintf("%s/%s", parentPath, "profiles"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	//Property: { requested-apn {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.RequestedApn != nil {

		paramsRequestedApn := make([]string, len(params))
		copy(paramsRequestedApn, params)
		stringValRequestedApn := fmt.Sprintf("%v", *jsonObj.RequestedApn)
		paramsRequestedApn = append(paramsRequestedApn, stringValRequestedApn)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeRequestedApn", paramsRequestedApn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/requested-apn"), paramsRequestedApn...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { serving-plmn {SubscriberUeServingPlmn  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ServingPlmn != nil {

		update, err := EncodeToGnmiSubscriberUeServingPlmn(
			jsonObj.ServingPlmn, false, target,
			fmt.Sprintf("%s/%s", parentPath, "serving-plmn"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUe", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUeProfiles converts OAPI to gNMI.
func EncodeToGnmiSubscriberUeProfiles(
	jsonObj *types.SubscriberUeProfiles, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { access-profile {[]SubscriberUeProfilesAccessProfile  0xc0005c5280 map[] [] false <nil> [] false} false false}
	if jsonObj.AccessProfile != nil {

	}
	//Property: { apn-profile {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.ApnProfile != nil {

		paramsApnProfile := make([]string, len(params))
		copy(paramsApnProfile, params)
		stringValApnProfile := fmt.Sprintf("%v", *jsonObj.ApnProfile)
		paramsApnProfile = append(paramsApnProfile, stringValApnProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesApnProfile", paramsApnProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/apn-profile"), paramsApnProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { qos-profile {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.QosProfile != nil {

		paramsQosProfile := make([]string, len(params))
		copy(paramsQosProfile, params)
		stringValQosProfile := fmt.Sprintf("%v", *jsonObj.QosProfile)
		paramsQosProfile = append(paramsQosProfile, stringValQosProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesQosProfile", paramsQosProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qos-profile"), paramsQosProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { security-profile {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.SecurityProfile != nil {

		paramsSecurityProfile := make([]string, len(params))
		copy(paramsSecurityProfile, params)
		stringValSecurityProfile := fmt.Sprintf("%v", *jsonObj.SecurityProfile)
		paramsSecurityProfile = append(paramsSecurityProfile, stringValSecurityProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesSecurityProfile", paramsSecurityProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/security-profile"), paramsSecurityProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { up-profile {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.UpProfile != nil {

		paramsUpProfile := make([]string, len(params))
		copy(paramsUpProfile, params)
		stringValUpProfile := fmt.Sprintf("%v", *jsonObj.UpProfile)
		paramsUpProfile = append(paramsUpProfile, stringValUpProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesUpProfile", paramsUpProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/up-profile"), paramsUpProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	//Property: { access-profile {[]SubscriberUeProfilesAccessProfile  0xc0005c5280 map[] [] false <nil> [] false} false false}
	if jsonObj.AccessProfile != nil {
		for _, item := range *jsonObj.AccessProfile {
			item := item //Pinning
			paramsAccessProfile := make([]string, len(params))
			copy(paramsAccessProfile, params)
			paramsAccessProfile = append(paramsAccessProfile, "unknown_id")
			updatesAccessProfile, err :=
				EncodeToGnmiSubscriberUeProfilesAccessProfile(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "access-profile"), paramsAccessProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesAccessProfile...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUeProfiles", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUeProfilesAccessProfile converts OAPI to gNMI.
func EncodeToGnmiSubscriberUeProfilesAccessProfile(
	jsonObj *types.SubscriberUeProfilesAccessProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { access-profile {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.AccessProfile != nil {

		paramsAccessProfile := make([]string, len(params))
		copy(paramsAccessProfile, params)
		stringValAccessProfile := fmt.Sprintf("%v", *jsonObj.AccessProfile)
		paramsAccessProfile = append(paramsAccessProfile, stringValAccessProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesAccessProfileAccessProfile", paramsAccessProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/access-profile"), paramsAccessProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { allowed {bool  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Allowed != nil {

		paramsAllowed := make([]string, len(params))
		copy(paramsAllowed, params)
		stringValAllowed := fmt.Sprintf("%v", *jsonObj.Allowed)
		paramsAllowed = append(paramsAllowed, stringValAllowed)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesAccessProfileAllowed", paramsAllowed...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/allowed"), paramsAllowed...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUeProfilesAccessProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUeServingPlmn converts OAPI to gNMI.
func EncodeToGnmiSubscriberUeServingPlmn(
	jsonObj *types.SubscriberUeServingPlmn, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { mcc {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Mcc != nil {

		paramsMcc := make([]string, len(params))
		copy(paramsMcc, params)
		stringValMcc := fmt.Sprintf("%v", *jsonObj.Mcc)
		paramsMcc = append(paramsMcc, stringValMcc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeServingPlmnMcc", paramsMcc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mcc"), paramsMcc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { mnc {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Mnc != nil {

		paramsMnc := make([]string, len(params))
		copy(paramsMnc, params)
		stringValMnc := fmt.Sprintf("%v", *jsonObj.Mnc)
		paramsMnc = append(paramsMnc, stringValMnc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeServingPlmnMnc", paramsMnc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mnc"), paramsMnc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { tac {int32  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Tac != nil {

		paramsTac := make([]string, len(params))
		copy(paramsTac, params)
		stringValTac := fmt.Sprintf("%v", *jsonObj.Tac)
		paramsTac = append(paramsTac, stringValTac)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeServingPlmnTac", paramsTac...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tac"), paramsTac...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUeServingPlmn", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiUpProfile converts OAPI to gNMI.
func EncodeToGnmiUpProfile(
	jsonObj *types.UpProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { up-profile {[]UpProfileUpProfile  0xc0005c5700 map[] [] false <nil> [] false} false false}
	if jsonObj.UpProfile != nil {

	}

	//Property: { up-profile {[]UpProfileUpProfile  0xc0005c5700 map[] [] false <nil> [] false} false false}
	if jsonObj.UpProfile != nil {
		for _, item := range *jsonObj.UpProfile {
			item := item //Pinning
			paramsUpProfile := make([]string, len(params))
			copy(paramsUpProfile, params)
			paramsUpProfile = append(paramsUpProfile, "unknown_id")
			updatesUpProfile, err :=
				EncodeToGnmiUpProfileUpProfile(&item, true, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "up-profile"), paramsUpProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesUpProfile...)
		}
	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "UpProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

// EncodeToGnmiUpProfileUpProfile converts OAPI to gNMI.
func EncodeToGnmiUpProfileUpProfile(
	jsonObj *types.UpProfileUpProfile, needKey bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	//Property: { access-control {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.AccessControl != nil {

		paramsAccessControl := make([]string, len(params))
		copy(paramsAccessControl, params)
		stringValAccessControl := fmt.Sprintf("%v", *jsonObj.AccessControl)
		paramsAccessControl = append(paramsAccessControl, stringValAccessControl)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileAccessControl", paramsAccessControl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/access-control"), paramsAccessControl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { description {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { display-name {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { id {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	//Property: { user-plane {string  <nil> map[] [] false <nil> [] false} false false}
	if jsonObj.UserPlane != nil {

		paramsUserPlane := make([]string, len(params))
		copy(paramsUserPlane, params)
		stringValUserPlane := fmt.Sprintf("%v", *jsonObj.UserPlane)
		paramsUserPlane = append(paramsUserPlane, stringValUserPlane)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileUserPlane", paramsUserPlane...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/user-plane"), paramsUserPlane...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey {
		reflectKey, err := utils.FindModelPluginObject(mp, "UpProfileUpProfile", params...)
		if err != nil {
			return nil, err
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for _, u := range updates {
				if err := utils.ReplaceUnknownKey(u, k, v, "unknown_key", "unknown_id"); err != nil {
					return nil, err
				}
			}
		}
	}
	return updates, nil
}

//Ignoring Target

//Ignoring RequestBodyAccessProfile

//Ignoring RequestBodyAccessProfileAccessProfile

//Ignoring RequestBodyApnProfile

//Ignoring RequestBodyApnProfileApnProfile

//Ignoring RequestBodyConnectivityService

//Ignoring RequestBodyConnectivityServiceConnectivityService

//Ignoring RequestBodyEnterprise

//Ignoring RequestBodyEnterpriseEnterprise

//Ignoring RequestBodyEnterpriseEnterpriseConnectivityService

//Ignoring RequestBodyQosProfile

//Ignoring RequestBodyQosProfileQosProfile

//Ignoring RequestBodyQosProfileQosProfileApnAmbr

//Ignoring RequestBodyQosProfileQosProfileArp

//Ignoring RequestBodySecurityProfile

//Ignoring RequestBodySecurityProfileSecurityProfile

//Ignoring RequestBodySubscriber

//Ignoring RequestBodySubscriberUe

//Ignoring RequestBodySubscriberUeProfiles

//Ignoring RequestBodySubscriberUeProfilesAccessProfile

//Ignoring RequestBodySubscriberUeServingPlmn

//Ignoring RequestBodyUpProfile

//Ignoring RequestBodyUpProfileUpProfile

// Not generating param-types
// Not generating request-bodies

// Not generating additional-properties
// Not generating additional-properties
