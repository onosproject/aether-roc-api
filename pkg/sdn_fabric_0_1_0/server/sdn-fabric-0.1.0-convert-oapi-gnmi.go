// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	"github.com/onosproject/aether-roc-api/pkg/utils"
	externalRef0 "github.com/onosproject/config-models/models/sdn-fabric-0.1.x/api"
	"github.com/onosproject/aether-roc-api/pkg/sdn_fabric_0_1_0/types"
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	// Not generating constants
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	// Not generating constants
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	"reflect"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertiesUnchTarget

//Ignoring AdditionalPropertyUnchanged

// EncodeToGnmiRoute converts OAPI to gNMI.
func EncodeToGnmiRoute(
	jsonObj *types.Route, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: nexthop RouteNexthopList
	if jsonObj.Nexthop != nil { // Optional leaf

		update, err := EncodeToGnmiRouteNexthopList(
			jsonObj.Nexthop, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "nexthop"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: prefix string
	_, unchangedPrefix := unchangedAttrs["prefix"]
	if !unchangedPrefix { // Mandatory leaf

		paramsPrefix := make([]string, len(params))
		copy(paramsPrefix, params)
		stringValPrefix := fmt.Sprintf("%v", jsonObj.Prefix)
		if stringValPrefix == "" {
			return nil, liberrors.NewInvalid("mandatory field 'prefix' of 'Route' must be provided or added to 'unchanged'")
		}
		paramsPrefix = append(paramsPrefix, stringValPrefix)
		mpField, err := utils.CreateModelPluginObject(&mp, "RoutePrefix", paramsPrefix...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/prefix"), paramsPrefix...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: route-id ListKey
	_, unchangedRouteId := unchangedAttrs["route-id"]
	if !unchangedRouteId { // Mandatory leaf

		paramsRouteId := make([]string, len(params))
		copy(paramsRouteId, params)
		stringValRouteId := fmt.Sprintf("%v", jsonObj.RouteId)

		paramsRouteId = append(paramsRouteId, stringValRouteId)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteRouteId", paramsRouteId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/route-id"), paramsRouteId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Route", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRouteList converts OAPI List to gNMI List.
func EncodeToGnmiRouteList(
	jsonObj *types.RouteList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiRoute(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiRouteNexthop converts OAPI to gNMI.
func EncodeToGnmiRouteNexthop(
	jsonObj *types.RouteNexthop, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'RouteNexthop' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteNexthopAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: index ListKey
	_, unchangedIndex := unchangedAttrs["index"]
	if !unchangedIndex { // Mandatory leaf

		paramsIndex := make([]string, len(params))
		copy(paramsIndex, params)
		stringValIndex := fmt.Sprintf("%v", jsonObj.Index)

		paramsIndex = append(paramsIndex, stringValIndex)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteNexthopIndex", paramsIndex...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/index"), paramsIndex...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "RouteNexthop", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRouteNexthopList converts OAPI List to gNMI List.
func EncodeToGnmiRouteNexthopList(
	jsonObj *types.RouteNexthopList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiRouteNexthop(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitch converts OAPI to gNMI.
func EncodeToGnmiSwitch(
	jsonObj *types.Switch, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute SwitchAttributeList
	if jsonObj.Attribute != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchAttributeList(
			jsonObj.Attribute, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "attribute"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: dhcp-connect-point SwitchDhcpConnectPointList
	if jsonObj.DhcpConnectPoint != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchDhcpConnectPointList(
			jsonObj.DhcpConnectPoint, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "dhcp-connect-point"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: management SwitchManagement
	if jsonObj.Management != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchManagement(
			jsonObj.Management, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "management"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: model string
	_, unchangedModel := unchangedAttrs["model"]
	if !unchangedModel { // Mandatory leaf

		paramsModel := make([]string, len(params))
		copy(paramsModel, params)
		stringValModel := fmt.Sprintf("%v", jsonObj.Model)
		if stringValModel == "" {
			return nil, liberrors.NewInvalid("mandatory field 'model' of 'Switch' must be provided or added to 'unchanged'")
		}
		paramsModel = append(paramsModel, stringValModel)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModel", paramsModel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model"), paramsModel...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: port SwitchPortList
	if jsonObj.Port != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchPortList(
			jsonObj.Port, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "port"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: role string
	_, unchangedRole := unchangedAttrs["role"]
	if !unchangedRole { // Mandatory leaf

		paramsRole := make([]string, len(params))
		copy(paramsRole, params)
		paramsRole = append(paramsRole, (string)(jsonObj.Role))
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchRole", paramsRole...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/role"), paramsRole...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: switch-id ListKey
	_, unchangedSwitchId := unchangedAttrs["switch-id"]
	if !unchangedSwitchId { // Mandatory leaf

		paramsSwitchId := make([]string, len(params))
		copy(paramsSwitchId, params)
		stringValSwitchId := fmt.Sprintf("%v", jsonObj.SwitchId)

		paramsSwitchId = append(paramsSwitchId, stringValSwitchId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchId", paramsSwitchId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/switch-id"), paramsSwitchId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: switch-pair SwitchSwitchPair
	if jsonObj.SwitchPair != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchSwitchPair(
			jsonObj.SwitchPair, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "switch-pair"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: vlan SwitchVlanList
	if jsonObj.Vlan != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchVlanList(
			jsonObj.Vlan, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "vlan"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Switch", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchRole converts OAPI to gNMI.
func EncodeToGnmiSwitchRole(
	jsonObj *types.SwitchRole, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchRole", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModel converts OAPI to gNMI.
func EncodeToGnmiSwitchModel(
	jsonObj *types.SwitchModel, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute SwitchModelAttributeList
	if jsonObj.Attribute != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchModelAttributeList(
			jsonObj.Attribute, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "attribute"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: form-factor string
	_, unchangedFormFactor := unchangedAttrs["form-factor"]
	if !unchangedFormFactor { // Mandatory leaf

		paramsFormFactor := make([]string, len(params))
		copy(paramsFormFactor, params)
		paramsFormFactor = append(paramsFormFactor, (string)(jsonObj.FormFactor))
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelFormFactor", paramsFormFactor...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/form-factor"), paramsFormFactor...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: pipeline string
	if jsonObj.Pipeline != nil { // Optional leaf

		paramsPipeline := make([]string, len(params))
		copy(paramsPipeline, params)
		paramsPipeline = append(paramsPipeline, (string)(*jsonObj.Pipeline))
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPipeline", paramsPipeline...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/pipeline"), paramsPipeline...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: port SwitchModelPortList
	if jsonObj.Port != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchModelPortList(
			jsonObj.Port, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "port"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: switch-model-id ListKey
	_, unchangedSwitchModelId := unchangedAttrs["switch-model-id"]
	if !unchangedSwitchModelId { // Mandatory leaf

		paramsSwitchModelId := make([]string, len(params))
		copy(paramsSwitchModelId, params)
		stringValSwitchModelId := fmt.Sprintf("%v", jsonObj.SwitchModelId)

		paramsSwitchModelId = append(paramsSwitchModelId, stringValSwitchModelId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelSwitchModelId", paramsSwitchModelId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/switch-model-id"), paramsSwitchModelId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModel", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelFormFactor converts OAPI to gNMI.
func EncodeToGnmiSwitchModelFormFactor(
	jsonObj *types.SwitchModelFormFactor, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModelFormFactor", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelPipeline converts OAPI to gNMI.
func EncodeToGnmiSwitchModelPipeline(
	jsonObj *types.SwitchModelPipeline, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModelPipeline", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelAttribute converts OAPI to gNMI.
func EncodeToGnmiSwitchModelAttribute(
	jsonObj *types.SwitchModelAttribute, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute-key ListKey
	_, unchangedAttributeKey := unchangedAttrs["attribute-key"]
	if !unchangedAttributeKey { // Mandatory leaf

		paramsAttributeKey := make([]string, len(params))
		copy(paramsAttributeKey, params)
		stringValAttributeKey := fmt.Sprintf("%v", jsonObj.AttributeKey)

		paramsAttributeKey = append(paramsAttributeKey, stringValAttributeKey)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelAttributeAttributeKey", paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/attribute-key"), paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: value string
	_, unchangedValue := unchangedAttrs["value"]
	if !unchangedValue { // Mandatory leaf

		paramsValue := make([]string, len(params))
		copy(paramsValue, params)
		stringValValue := fmt.Sprintf("%v", jsonObj.Value)
		if stringValValue == "" {
			return nil, liberrors.NewInvalid("mandatory field 'value' of 'SwitchModelAttribute' must be provided or added to 'unchanged'")
		}
		paramsValue = append(paramsValue, stringValValue)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelAttributeValue", paramsValue...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/value"), paramsValue...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModelAttribute", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelAttributeList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchModelAttributeList(
	jsonObj *types.SwitchModelAttributeList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchModelAttribute(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchModelList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchModelList(
	jsonObj *types.SwitchModelList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchModel(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchModelPort converts OAPI to gNMI.
func EncodeToGnmiSwitchModelPort(
	jsonObj *types.SwitchModelPort, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: cage-number ListKey
	_, unchangedCageNumber := unchangedAttrs["cage-number"]
	if !unchangedCageNumber { // Mandatory leaf

		paramsCageNumber := make([]string, len(params))
		copy(paramsCageNumber, params)
		stringValCageNumber := fmt.Sprintf("%v", jsonObj.CageNumber)

		paramsCageNumber = append(paramsCageNumber, stringValCageNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortCageNumber", paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/cage-number"), paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: channel-number ListKey
	_, unchangedChannelNumber := unchangedAttrs["channel-number"]
	if !unchangedChannelNumber { // Mandatory leaf

		paramsChannelNumber := make([]string, len(params))
		copy(paramsChannelNumber, params)
		stringValChannelNumber := fmt.Sprintf("%v", jsonObj.ChannelNumber)

		paramsChannelNumber = append(paramsChannelNumber, stringValChannelNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortChannelNumber", paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/channel-number"), paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: speeds SwitchModelPortSpeeds
	if jsonObj.Speeds != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchModelPortSpeeds(
			jsonObj.Speeds, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "speeds"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModelPort", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelPortList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchModelPortList(
	jsonObj *types.SwitchModelPortList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchModelPort(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchModelPortSpeeds converts OAPI to gNMI.
func EncodeToGnmiSwitchModelPortSpeeds(
	jsonObj *types.SwitchModelPortSpeeds, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModelPortSpeeds", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchAttribute converts OAPI to gNMI.
func EncodeToGnmiSwitchAttribute(
	jsonObj *types.SwitchAttribute, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute-key ListKey
	_, unchangedAttributeKey := unchangedAttrs["attribute-key"]
	if !unchangedAttributeKey { // Mandatory leaf

		paramsAttributeKey := make([]string, len(params))
		copy(paramsAttributeKey, params)
		stringValAttributeKey := fmt.Sprintf("%v", jsonObj.AttributeKey)

		paramsAttributeKey = append(paramsAttributeKey, stringValAttributeKey)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchAttributeAttributeKey", paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/attribute-key"), paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: value string
	_, unchangedValue := unchangedAttrs["value"]
	if !unchangedValue { // Mandatory leaf

		paramsValue := make([]string, len(params))
		copy(paramsValue, params)
		stringValValue := fmt.Sprintf("%v", jsonObj.Value)
		if stringValValue == "" {
			return nil, liberrors.NewInvalid("mandatory field 'value' of 'SwitchAttribute' must be provided or added to 'unchanged'")
		}
		paramsValue = append(paramsValue, stringValValue)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchAttributeValue", paramsValue...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/value"), paramsValue...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchAttribute", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchAttributeList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchAttributeList(
	jsonObj *types.SwitchAttributeList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchAttribute(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchDhcpConnectPoint converts OAPI to gNMI.
func EncodeToGnmiSwitchDhcpConnectPoint(
	jsonObj *types.SwitchDhcpConnectPoint, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connect-point SwitchDhcpConnectPointConnectPoint
	if jsonObj.ConnectPoint != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchDhcpConnectPointConnectPoint(
			jsonObj.ConnectPoint, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "connect-point"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: dhcp-id ListKey
	_, unchangedDhcpId := unchangedAttrs["dhcp-id"]
	if !unchangedDhcpId { // Mandatory leaf

		paramsDhcpId := make([]string, len(params))
		copy(paramsDhcpId, params)
		stringValDhcpId := fmt.Sprintf("%v", jsonObj.DhcpId)

		paramsDhcpId = append(paramsDhcpId, stringValDhcpId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchDhcpConnectPointDhcpId", paramsDhcpId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dhcp-id"), paramsDhcpId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchDhcpConnectPoint", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchDhcpConnectPointConnectPoint converts OAPI to gNMI.
func EncodeToGnmiSwitchDhcpConnectPointConnectPoint(
	jsonObj *types.SwitchDhcpConnectPointConnectPoint, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchDhcpConnectPointConnectPoint", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchDhcpConnectPointList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchDhcpConnectPointList(
	jsonObj *types.SwitchDhcpConnectPointList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchDhcpConnectPoint(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchList(
	jsonObj *types.SwitchList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitch(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchManagement converts OAPI to gNMI.
func EncodeToGnmiSwitchManagement(
	jsonObj *types.SwitchManagement, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if jsonObj.Address != nil { // Optional leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", *jsonObj.Address)

		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchManagementAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: port-number int
	if jsonObj.PortNumber != nil { // Optional leaf

		paramsPortNumber := make([]string, len(params))
		copy(paramsPortNumber, params)
		stringValPortNumber := fmt.Sprintf("%v", *jsonObj.PortNumber)

		paramsPortNumber = append(paramsPortNumber, stringValPortNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchManagementPortNumber", paramsPortNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-number"), paramsPortNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchManagement", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchPort converts OAPI to gNMI.
func EncodeToGnmiSwitchPort(
	jsonObj *types.SwitchPort, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: cage-number ListKey
	_, unchangedCageNumber := unchangedAttrs["cage-number"]
	if !unchangedCageNumber { // Mandatory leaf

		paramsCageNumber := make([]string, len(params))
		copy(paramsCageNumber, params)
		stringValCageNumber := fmt.Sprintf("%v", jsonObj.CageNumber)

		paramsCageNumber = append(paramsCageNumber, stringValCageNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortCageNumber", paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/cage-number"), paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: channel-number ListKey
	_, unchangedChannelNumber := unchangedAttrs["channel-number"]
	if !unchangedChannelNumber { // Mandatory leaf

		paramsChannelNumber := make([]string, len(params))
		copy(paramsChannelNumber, params)
		stringValChannelNumber := fmt.Sprintf("%v", jsonObj.ChannelNumber)

		paramsChannelNumber = append(paramsChannelNumber, stringValChannelNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortChannelNumber", paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/channel-number"), paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: dhcp-connect-point string
	if jsonObj.DhcpConnectPoint != nil { // Optional leaf

		paramsDhcpConnectPoint := make([]string, len(params))
		copy(paramsDhcpConnectPoint, params)
		stringValDhcpConnectPoint := fmt.Sprintf("%v", *jsonObj.DhcpConnectPoint)

		paramsDhcpConnectPoint = append(paramsDhcpConnectPoint, stringValDhcpConnectPoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortDhcpConnectPoint", paramsDhcpConnectPoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dhcp-connect-point"), paramsDhcpConnectPoint...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: speed string
	if jsonObj.Speed != nil { // Optional leaf

		paramsSpeed := make([]string, len(params))
		copy(paramsSpeed, params)
		paramsSpeed = append(paramsSpeed, (string)(*jsonObj.Speed))
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortSpeed", paramsSpeed...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/speed"), paramsSpeed...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: vlans SwitchPortVlans
	if jsonObj.Vlans != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchPortVlans(
			jsonObj.Vlans, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "vlans"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchPort", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchPortSpeed converts OAPI to gNMI.
func EncodeToGnmiSwitchPortSpeed(
	jsonObj *types.SwitchPortSpeed, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchPortSpeed", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchPortList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchPortList(
	jsonObj *types.SwitchPortList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchPort(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchPortVlans converts OAPI to gNMI.
func EncodeToGnmiSwitchPortVlans(
	jsonObj *types.SwitchPortVlans, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: leaf-list-tagged []string
	if jsonObj.LeafListTagged != nil { // Optional leaf

		paramsLeafListTagged := make([]string, len(params))
		copy(paramsLeafListTagged, params)
		paramsLeafListTagged = append(paramsLeafListTagged, *jsonObj.LeafListTagged...)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortVlansTagged", paramsLeafListTagged...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tagged"), paramsLeafListTagged...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: untagged string
	if jsonObj.Untagged != nil { // Optional leaf

		paramsUntagged := make([]string, len(params))
		copy(paramsUntagged, params)
		stringValUntagged := fmt.Sprintf("%v", *jsonObj.Untagged)

		paramsUntagged = append(paramsUntagged, stringValUntagged)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortVlansUntagged", paramsUntagged...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/untagged"), paramsUntagged...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchPortVlans", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchSwitchPair converts OAPI to gNMI.
func EncodeToGnmiSwitchSwitchPair(
	jsonObj *types.SwitchSwitchPair, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: cage-number string
	if jsonObj.CageNumber != nil { // Optional leaf

		paramsCageNumber := make([]string, len(params))
		copy(paramsCageNumber, params)
		stringValCageNumber := fmt.Sprintf("%v", *jsonObj.CageNumber)

		paramsCageNumber = append(paramsCageNumber, stringValCageNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchPairCageNumber", paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/cage-number"), paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: channel-number string
	if jsonObj.ChannelNumber != nil { // Optional leaf

		paramsChannelNumber := make([]string, len(params))
		copy(paramsChannelNumber, params)
		stringValChannelNumber := fmt.Sprintf("%v", *jsonObj.ChannelNumber)

		paramsChannelNumber = append(paramsChannelNumber, stringValChannelNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchPairChannelNumber", paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/channel-number"), paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: paired-switch string
	if jsonObj.PairedSwitch != nil { // Optional leaf

		paramsPairedSwitch := make([]string, len(params))
		copy(paramsPairedSwitch, params)
		stringValPairedSwitch := fmt.Sprintf("%v", *jsonObj.PairedSwitch)

		paramsPairedSwitch = append(paramsPairedSwitch, stringValPairedSwitch)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchPairPairedSwitch", paramsPairedSwitch...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/paired-switch"), paramsPairedSwitch...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchSwitchPair", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchVlan converts OAPI to gNMI.
func EncodeToGnmiSwitchVlan(
	jsonObj *types.SwitchVlan, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: subnet string
	_, unchangedSubnet := unchangedAttrs["subnet"]
	if !unchangedSubnet { // Mandatory leaf

		paramsSubnet := make([]string, len(params))
		copy(paramsSubnet, params)
		stringValSubnet := fmt.Sprintf("%v", jsonObj.Subnet)
		if stringValSubnet == "" {
			return nil, liberrors.NewInvalid("mandatory field 'subnet' of 'SwitchVlan' must be provided or added to 'unchanged'")
		}
		paramsSubnet = append(paramsSubnet, stringValSubnet)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanSubnet", paramsSubnet...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/subnet"), paramsSubnet...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: vlan-id ListKey
	_, unchangedVlanId := unchangedAttrs["vlan-id"]
	if !unchangedVlanId { // Mandatory leaf

		paramsVlanId := make([]string, len(params))
		copy(paramsVlanId, params)
		stringValVlanId := fmt.Sprintf("%v", jsonObj.VlanId)

		paramsVlanId = append(paramsVlanId, stringValVlanId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanVlanId", paramsVlanId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/vlan-id"), paramsVlanId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchVlan", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchVlanList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchVlanList(
	jsonObj *types.SwitchVlanList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchVlan(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiFabricId converts OAPI to gNMI.
func EncodeToGnmiFabricId(
	jsonObj *types.FabricId, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "FabricId", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

//Ignoring RequestBodyRoute

//Ignoring RequestBodyRouteNexthop

//Ignoring RequestBodySwitch

//Ignoring RequestBodySwitchModel

//Ignoring RequestBodySwitchModelAttribute

//Ignoring RequestBodySwitchModelPort

//Ignoring RequestBodySwitchAttribute

//Ignoring RequestBodySwitchDhcpConnectPoint

//Ignoring RequestBodySwitchManagement

//Ignoring RequestBodySwitchPort

//Ignoring RequestBodySwitchPortVlans

//Ignoring RequestBodySwitchSwitchPair

//Ignoring RequestBodySwitchVlan

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating param-types
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating request-bodies

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
