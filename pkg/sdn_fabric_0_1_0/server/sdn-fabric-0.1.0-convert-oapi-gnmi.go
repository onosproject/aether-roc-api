// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	"github.com/onosproject/aether-roc-api/pkg/utils"
	externalRef0 "github.com/onosproject/config-models/models/sdn-fabric-0.1.x/api"
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	// Not generating constants
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	// Not generating constants
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	"reflect"
	"github.com/onosproject/aether-roc-api/pkg/sdn_fabric_0_1_0/types"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertiesUnchTarget

//Ignoring AdditionalPropertyUnchanged

// EncodeToGnmiDhcpServer converts OAPI to gNMI.
func EncodeToGnmiDhcpServer(
	jsonObj *types.DhcpServer, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'DhcpServer' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "DhcpServerAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "DhcpServerDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: dhcp-server-id ListKey
	_, unchangedDhcpServerId := unchangedAttrs["dhcp-server-id"]
	if !unchangedDhcpServerId { // Mandatory leaf

		paramsDhcpServerId := make([]string, len(params))
		copy(paramsDhcpServerId, params)
		stringValDhcpServerId := fmt.Sprintf("%v", jsonObj.DhcpServerId)

		paramsDhcpServerId = append(paramsDhcpServerId, stringValDhcpServerId)
		mpField, err := utils.CreateModelPluginObject(&mp, "DhcpServerDhcpServerId", paramsDhcpServerId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dhcp-server-id"), paramsDhcpServerId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "DhcpServerDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DhcpServer", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDhcpServerList converts OAPI List to gNMI List.
func EncodeToGnmiDhcpServerList(
	jsonObj *types.DhcpServerList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiDhcpServer(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiRoute converts OAPI to gNMI.
func EncodeToGnmiRoute(
	jsonObj *types.Route, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'Route' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: metric int
	_, unchangedMetric := unchangedAttrs["metric"]
	if !unchangedMetric { // Mandatory leaf

		paramsMetric := make([]string, len(params))
		copy(paramsMetric, params)
		stringValMetric := fmt.Sprintf("%v", jsonObj.Metric)

		paramsMetric = append(paramsMetric, stringValMetric)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteMetric", paramsMetric...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/metric"), paramsMetric...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: prefix string
	_, unchangedPrefix := unchangedAttrs["prefix"]
	if !unchangedPrefix { // Mandatory leaf

		paramsPrefix := make([]string, len(params))
		copy(paramsPrefix, params)
		stringValPrefix := fmt.Sprintf("%v", jsonObj.Prefix)
		if stringValPrefix == "" {
			return nil, liberrors.NewInvalid("mandatory field 'prefix' of 'Route' must be provided or added to 'unchanged'")
		}
		paramsPrefix = append(paramsPrefix, stringValPrefix)
		mpField, err := utils.CreateModelPluginObject(&mp, "RoutePrefix", paramsPrefix...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/prefix"), paramsPrefix...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: route-id ListKey
	_, unchangedRouteId := unchangedAttrs["route-id"]
	if !unchangedRouteId { // Mandatory leaf

		paramsRouteId := make([]string, len(params))
		copy(paramsRouteId, params)
		stringValRouteId := fmt.Sprintf("%v", jsonObj.RouteId)

		paramsRouteId = append(paramsRouteId, stringValRouteId)
		mpField, err := utils.CreateModelPluginObject(&mp, "RouteRouteId", paramsRouteId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/route-id"), paramsRouteId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Route", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiRouteList converts OAPI List to gNMI List.
func EncodeToGnmiRouteList(
	jsonObj *types.RouteList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiRoute(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitch converts OAPI to gNMI.
func EncodeToGnmiSwitch(
	jsonObj *types.Switch, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute SwitchAttributeList
	if jsonObj.Attribute != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchAttributeList(
			jsonObj.Attribute, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "attribute"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: management SwitchManagement
	if jsonObj.Management != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchManagement(
			jsonObj.Management, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "management"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: model-id string
	_, unchangedModelId := unchangedAttrs["model-id"]
	if !unchangedModelId { // Mandatory leaf

		paramsModelId := make([]string, len(params))
		copy(paramsModelId, params)
		stringValModelId := fmt.Sprintf("%v", jsonObj.ModelId)
		if stringValModelId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'model-id' of 'Switch' must be provided or added to 'unchanged'")
		}
		paramsModelId = append(paramsModelId, stringValModelId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelId", paramsModelId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/model-id"), paramsModelId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: port SwitchPortList
	if jsonObj.Port != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchPortList(
			jsonObj.Port, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "port"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: role string
	_, unchangedRole := unchangedAttrs["role"]
	if !unchangedRole { // Mandatory leaf

		paramsRole := make([]string, len(params))
		copy(paramsRole, params)
		paramsRole = append(paramsRole, (string)(jsonObj.Role))
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchRole", paramsRole...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/role"), paramsRole...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: state SwitchState
	if jsonObj.State != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchState(
			jsonObj.State, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: switch-id ListKey
	_, unchangedSwitchId := unchangedAttrs["switch-id"]
	if !unchangedSwitchId { // Mandatory leaf

		paramsSwitchId := make([]string, len(params))
		copy(paramsSwitchId, params)
		stringValSwitchId := fmt.Sprintf("%v", jsonObj.SwitchId)

		paramsSwitchId = append(paramsSwitchId, stringValSwitchId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchId", paramsSwitchId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/switch-id"), paramsSwitchId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: switch-pair SwitchSwitchPair
	if jsonObj.SwitchPair != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchSwitchPair(
			jsonObj.SwitchPair, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "switch-pair"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: vlan SwitchVlanList
	if jsonObj.Vlan != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchVlanList(
			jsonObj.Vlan, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "vlan"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Switch", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchRole converts OAPI to gNMI.
func EncodeToGnmiSwitchRole(
	jsonObj *types.SwitchRole, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "SwitchRole", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if fabricId != "" {
		update.Path.Target = string(fabricId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiSwitchModel converts OAPI to gNMI.
func EncodeToGnmiSwitchModel(
	jsonObj *types.SwitchModel, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute SwitchModelAttributeList
	if jsonObj.Attribute != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchModelAttributeList(
			jsonObj.Attribute, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "attribute"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: pipeline string
	_, unchangedPipeline := unchangedAttrs["pipeline"]
	if !unchangedPipeline { // Mandatory leaf

		paramsPipeline := make([]string, len(params))
		copy(paramsPipeline, params)
		paramsPipeline = append(paramsPipeline, (string)(jsonObj.Pipeline))
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPipeline", paramsPipeline...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/pipeline"), paramsPipeline...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: port SwitchModelPortList
	if jsonObj.Port != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchModelPortList(
			jsonObj.Port, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "port"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: switch-model-id ListKey
	_, unchangedSwitchModelId := unchangedAttrs["switch-model-id"]
	if !unchangedSwitchModelId { // Mandatory leaf

		paramsSwitchModelId := make([]string, len(params))
		copy(paramsSwitchModelId, params)
		stringValSwitchModelId := fmt.Sprintf("%v", jsonObj.SwitchModelId)

		paramsSwitchModelId = append(paramsSwitchModelId, stringValSwitchModelId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelSwitchModelId", paramsSwitchModelId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/switch-model-id"), paramsSwitchModelId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModel", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelPipeline converts OAPI to gNMI.
func EncodeToGnmiSwitchModelPipeline(
	jsonObj *types.SwitchModelPipeline, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPipeline", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if fabricId != "" {
		update.Path.Target = string(fabricId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiSwitchModelAttribute converts OAPI to gNMI.
func EncodeToGnmiSwitchModelAttribute(
	jsonObj *types.SwitchModelAttribute, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute-key ListKey
	_, unchangedAttributeKey := unchangedAttrs["attribute-key"]
	if !unchangedAttributeKey { // Mandatory leaf

		paramsAttributeKey := make([]string, len(params))
		copy(paramsAttributeKey, params)
		stringValAttributeKey := fmt.Sprintf("%v", jsonObj.AttributeKey)

		paramsAttributeKey = append(paramsAttributeKey, stringValAttributeKey)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelAttributeAttributeKey", paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/attribute-key"), paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: value string
	_, unchangedValue := unchangedAttrs["value"]
	if !unchangedValue { // Mandatory leaf

		paramsValue := make([]string, len(params))
		copy(paramsValue, params)
		stringValValue := fmt.Sprintf("%v", jsonObj.Value)
		if stringValValue == "" {
			return nil, liberrors.NewInvalid("mandatory field 'value' of 'SwitchModelAttribute' must be provided or added to 'unchanged'")
		}
		paramsValue = append(paramsValue, stringValValue)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelAttributeValue", paramsValue...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/value"), paramsValue...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModelAttribute", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelAttributeList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchModelAttributeList(
	jsonObj *types.SwitchModelAttributeList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchModelAttribute(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchModelList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchModelList(
	jsonObj *types.SwitchModelList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchModel(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchModelPort converts OAPI to gNMI.
func EncodeToGnmiSwitchModelPort(
	jsonObj *types.SwitchModelPort, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: cage-number int
	_, unchangedCageNumber := unchangedAttrs["cage-number"]
	if !unchangedCageNumber { // Mandatory leaf

		paramsCageNumber := make([]string, len(params))
		copy(paramsCageNumber, params)
		stringValCageNumber := fmt.Sprintf("%v", jsonObj.CageNumber)

		paramsCageNumber = append(paramsCageNumber, stringValCageNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortCageNumber", paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/cage-number"), paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: max-channel int
	if jsonObj.MaxChannel != nil { // Optional leaf

		paramsMaxChannel := make([]string, len(params))
		copy(paramsMaxChannel, params)
		stringValMaxChannel := fmt.Sprintf("%v", *jsonObj.MaxChannel)

		paramsMaxChannel = append(paramsMaxChannel, stringValMaxChannel)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortMaxChannel", paramsMaxChannel...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/max-channel"), paramsMaxChannel...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: speeds SwitchModelPortSpeeds
	if jsonObj.Speeds != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchModelPortSpeeds(
			jsonObj.Speeds, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "speeds"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchModelPort", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchModelPortList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchModelPortList(
	jsonObj *types.SwitchModelPortList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchModelPort(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchModelPortSpeeds converts OAPI to gNMI.
func EncodeToGnmiSwitchModelPortSpeeds(
	jsonObj *types.SwitchModelPortSpeeds, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "SwitchModelPortSpeeds", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if fabricId != "" {
		update.Path.Target = string(fabricId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiSwitchAttribute converts OAPI to gNMI.
func EncodeToGnmiSwitchAttribute(
	jsonObj *types.SwitchAttribute, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: attribute-key ListKey
	_, unchangedAttributeKey := unchangedAttrs["attribute-key"]
	if !unchangedAttributeKey { // Mandatory leaf

		paramsAttributeKey := make([]string, len(params))
		copy(paramsAttributeKey, params)
		stringValAttributeKey := fmt.Sprintf("%v", jsonObj.AttributeKey)

		paramsAttributeKey = append(paramsAttributeKey, stringValAttributeKey)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchAttributeAttributeKey", paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/attribute-key"), paramsAttributeKey...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: value string
	_, unchangedValue := unchangedAttrs["value"]
	if !unchangedValue { // Mandatory leaf

		paramsValue := make([]string, len(params))
		copy(paramsValue, params)
		stringValValue := fmt.Sprintf("%v", jsonObj.Value)
		if stringValValue == "" {
			return nil, liberrors.NewInvalid("mandatory field 'value' of 'SwitchAttribute' must be provided or added to 'unchanged'")
		}
		paramsValue = append(paramsValue, stringValValue)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchAttributeValue", paramsValue...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/value"), paramsValue...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchAttribute", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchAttributeList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchAttributeList(
	jsonObj *types.SwitchAttributeList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchAttribute(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchList(
	jsonObj *types.SwitchList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitch(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchManagement converts OAPI to gNMI.
func EncodeToGnmiSwitchManagement(
	jsonObj *types.SwitchManagement, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if jsonObj.Address != nil { // Optional leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", *jsonObj.Address)

		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchManagementAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: port-number int
	if jsonObj.PortNumber != nil { // Optional leaf

		paramsPortNumber := make([]string, len(params))
		copy(paramsPortNumber, params)
		stringValPortNumber := fmt.Sprintf("%v", *jsonObj.PortNumber)

		paramsPortNumber = append(paramsPortNumber, stringValPortNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchManagementPortNumber", paramsPortNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-number"), paramsPortNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchManagement", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchPort converts OAPI to gNMI.
func EncodeToGnmiSwitchPort(
	jsonObj *types.SwitchPort, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: cage-number int
	_, unchangedCageNumber := unchangedAttrs["cage-number"]
	if !unchangedCageNumber { // Mandatory leaf

		paramsCageNumber := make([]string, len(params))
		copy(paramsCageNumber, params)
		stringValCageNumber := fmt.Sprintf("%v", jsonObj.CageNumber)

		paramsCageNumber = append(paramsCageNumber, stringValCageNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortCageNumber", paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/cage-number"), paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: channel-number int
	_, unchangedChannelNumber := unchangedAttrs["channel-number"]
	if !unchangedChannelNumber { // Mandatory leaf

		paramsChannelNumber := make([]string, len(params))
		copy(paramsChannelNumber, params)
		stringValChannelNumber := fmt.Sprintf("%v", jsonObj.ChannelNumber)

		paramsChannelNumber = append(paramsChannelNumber, stringValChannelNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortChannelNumber", paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/channel-number"), paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: dhcp-connect-point SwitchPortDhcpConnectPoint
	if jsonObj.DhcpConnectPoint != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchPortDhcpConnectPoint(
			jsonObj.DhcpConnectPoint, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "dhcp-connect-point"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: speed string
	_, unchangedSpeed := unchangedAttrs["speed"]
	if !unchangedSpeed { // Mandatory leaf

		paramsSpeed := make([]string, len(params))
		copy(paramsSpeed, params)
		paramsSpeed = append(paramsSpeed, (string)(jsonObj.Speed))
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortSpeed", paramsSpeed...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/speed"), paramsSpeed...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: state SwitchPortState
	if jsonObj.State != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchPortState(
			jsonObj.State, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: vlans SwitchPortVlans
	if jsonObj.Vlans != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchPortVlans(
			jsonObj.Vlans, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "vlans"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchPort", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchPortSpeed converts OAPI to gNMI.
func EncodeToGnmiSwitchPortSpeed(
	jsonObj *types.SwitchPortSpeed, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortSpeed", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if fabricId != "" {
		update.Path.Target = string(fabricId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiSwitchPortDhcpConnectPoint converts OAPI to gNMI.
func EncodeToGnmiSwitchPortDhcpConnectPoint(
	jsonObj *types.SwitchPortDhcpConnectPoint, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortDhcpConnectPoint", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if fabricId != "" {
		update.Path.Target = string(fabricId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiSwitchPortList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchPortList(
	jsonObj *types.SwitchPortList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchPort(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchPortState converts OAPI to gNMI.
func EncodeToGnmiSwitchPortState(
	jsonObj *types.SwitchPortState, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: admin-status string
	if jsonObj.AdminStatus != nil { // Optional leaf

		paramsAdminStatus := make([]string, len(params))
		copy(paramsAdminStatus, params)
		stringValAdminStatus := fmt.Sprintf("%v", *jsonObj.AdminStatus)

		paramsAdminStatus = append(paramsAdminStatus, stringValAdminStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortStateAdminStatus", paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/admin-status"), paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: ifindex int32
	if jsonObj.Ifindex != nil { // Optional leaf

		paramsIfindex := make([]string, len(params))
		copy(paramsIfindex, params)
		stringValIfindex := fmt.Sprintf("%v", *jsonObj.Ifindex)

		paramsIfindex = append(paramsIfindex, stringValIfindex)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortStateIfindex", paramsIfindex...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ifindex"), paramsIfindex...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: last-change int64
	if jsonObj.LastChange != nil { // Optional leaf

		paramsLastChange := make([]string, len(params))
		copy(paramsLastChange, params)
		stringValLastChange := fmt.Sprintf("%v", *jsonObj.LastChange)

		paramsLastChange = append(paramsLastChange, stringValLastChange)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortStateLastChange", paramsLastChange...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/last-change"), paramsLastChange...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: oper-status string
	if jsonObj.OperStatus != nil { // Optional leaf

		paramsOperStatus := make([]string, len(params))
		copy(paramsOperStatus, params)
		stringValOperStatus := fmt.Sprintf("%v", *jsonObj.OperStatus)

		paramsOperStatus = append(paramsOperStatus, stringValOperStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortStateOperStatus", paramsOperStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/oper-status"), paramsOperStatus...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchPortState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchPortVlans converts OAPI to gNMI.
func EncodeToGnmiSwitchPortVlans(
	jsonObj *types.SwitchPortVlans, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: tagged []int
	if jsonObj.Tagged != nil { // Optional leaf

	}
	// Property: untagged int
	if jsonObj.Untagged != nil { // Optional leaf

		paramsUntagged := make([]string, len(params))
		copy(paramsUntagged, params)
		stringValUntagged := fmt.Sprintf("%v", *jsonObj.Untagged)

		paramsUntagged = append(paramsUntagged, stringValUntagged)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchPortVlansUntagged", paramsUntagged...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/untagged"), paramsUntagged...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchPortVlans", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchState converts OAPI to gNMI.
func EncodeToGnmiSwitchState(
	jsonObj *types.SwitchState, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connected string
	if jsonObj.Connected != nil { // Optional leaf

		paramsConnected := make([]string, len(params))
		copy(paramsConnected, params)
		stringValConnected := fmt.Sprintf("%v", *jsonObj.Connected)

		paramsConnected = append(paramsConnected, stringValConnected)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchStateConnected", paramsConnected...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connected"), paramsConnected...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: last-connected string
	if jsonObj.LastConnected != nil { // Optional leaf

		paramsLastConnected := make([]string, len(params))
		copy(paramsLastConnected, params)
		stringValLastConnected := fmt.Sprintf("%v", *jsonObj.LastConnected)

		paramsLastConnected = append(paramsLastConnected, stringValLastConnected)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchStateLastConnected", paramsLastConnected...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/last-connected"), paramsLastConnected...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchSwitchPair converts OAPI to gNMI.
func EncodeToGnmiSwitchSwitchPair(
	jsonObj *types.SwitchSwitchPair, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: paired-switch string
	if jsonObj.PairedSwitch != nil { // Optional leaf

		paramsPairedSwitch := make([]string, len(params))
		copy(paramsPairedSwitch, params)
		stringValPairedSwitch := fmt.Sprintf("%v", *jsonObj.PairedSwitch)

		paramsPairedSwitch = append(paramsPairedSwitch, stringValPairedSwitch)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchPairPairedSwitch", paramsPairedSwitch...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/paired-switch"), paramsPairedSwitch...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: pairing-port SwitchSwitchPairPairingPortList
	if jsonObj.PairingPort != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchSwitchPairPairingPortList(
			jsonObj.PairingPort, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "pairing-port"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchSwitchPair", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchSwitchPairPairingPort converts OAPI to gNMI.
func EncodeToGnmiSwitchSwitchPairPairingPort(
	jsonObj *types.SwitchSwitchPairPairingPort, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: cage-number int
	_, unchangedCageNumber := unchangedAttrs["cage-number"]
	if !unchangedCageNumber { // Mandatory leaf

		paramsCageNumber := make([]string, len(params))
		copy(paramsCageNumber, params)
		stringValCageNumber := fmt.Sprintf("%v", jsonObj.CageNumber)

		paramsCageNumber = append(paramsCageNumber, stringValCageNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchPairPairingPortCageNumber", paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/cage-number"), paramsCageNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: channel-number int
	_, unchangedChannelNumber := unchangedAttrs["channel-number"]
	if !unchangedChannelNumber { // Mandatory leaf

		paramsChannelNumber := make([]string, len(params))
		copy(paramsChannelNumber, params)
		stringValChannelNumber := fmt.Sprintf("%v", jsonObj.ChannelNumber)

		paramsChannelNumber = append(paramsChannelNumber, stringValChannelNumber)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchSwitchPairPairingPortChannelNumber", paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/channel-number"), paramsChannelNumber...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchSwitchPairPairingPort", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchSwitchPairPairingPortList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchSwitchPairPairingPortList(
	jsonObj *types.SwitchSwitchPairPairingPortList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchSwitchPairPairingPort(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchVlan converts OAPI to gNMI.
func EncodeToGnmiSwitchVlan(
	jsonObj *types.SwitchVlan, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}
	// Property: subnet SwitchVlanSubnet
	if jsonObj.Subnet != nil { // Optional leaf

		update, err := EncodeToGnmiSwitchVlanSubnet(
			jsonObj.Subnet, false, removeIndex, fabricId,
			fmt.Sprintf("%s/%s", parentPath, "subnet"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: vlan-id int
	_, unchangedVlanId := unchangedAttrs["vlan-id"]
	if !unchangedVlanId { // Mandatory leaf

		paramsVlanId := make([]string, len(params))
		copy(paramsVlanId, params)
		stringValVlanId := fmt.Sprintf("%v", jsonObj.VlanId)

		paramsVlanId = append(paramsVlanId, stringValVlanId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanVlanId", paramsVlanId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/vlan-id"), paramsVlanId...)
		if err != nil {
			return nil, err
		}
		if fabricId != "" {
			update.Path.Target = string(fabricId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SwitchVlan", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, keyMap); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSwitchVlanList converts OAPI List to gNMI List.
func EncodeToGnmiSwitchVlanList(
	jsonObj *types.SwitchVlanList, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSwitchVlan(&childObj, true, removeIndex, fabricId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSwitchVlanSubnet converts OAPI to gNMI.
func EncodeToGnmiSwitchVlanSubnet(
	jsonObj *types.SwitchVlanSubnet, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "SwitchVlanSubnet", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if fabricId != "" {
		update.Path.Target = string(fabricId)
	}
	updates = append(updates, update)
	return updates, nil
}

// EncodeToGnmiFabricId converts OAPI to gNMI.
func EncodeToGnmiFabricId(
	jsonObj *types.FabricId, needKey bool, removeIndex bool, fabricId types.FabricId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		fabricId = types.FabricId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Length of props is 0 - usually indicates a leaf list of complex type
	paramsLeafList := make([]string, len(params))
	copy(paramsLeafList, params)
	for _, listItem := range *jsonObj {
		paramsLeafList = append(paramsLeafList, fmt.Sprintf("%v", listItem))
	}

	mpField, err := utils.CreateModelPluginObject(&mp, "FabricId", paramsLeafList...)
	if err != nil {
		return nil, err
	}

	update, err := utils.UpdateForElement(mpField, parentPath, paramsLeafList...)
	if err != nil {
		return nil, err
	}
	if fabricId != "" {
		update.Path.Target = string(fabricId)
	}
	updates = append(updates, update)
	return updates, nil
}

//Ignoring RequestBodyDhcpServer

//Ignoring RequestBodyRoute

//Ignoring RequestBodySwitch

//Ignoring RequestBodySwitchModel

//Ignoring RequestBodySwitchModelAttribute

//Ignoring RequestBodySwitchModelPort

//Ignoring RequestBodySwitchAttribute

//Ignoring RequestBodySwitchManagement

//Ignoring RequestBodySwitchPort

//Ignoring RequestBodySwitchPortVlans

//Ignoring RequestBodySwitchSwitchPair

//Ignoring RequestBodySwitchSwitchPairPairingPort

//Ignoring RequestBodySwitchVlan

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating param-types
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating request-bodies

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
