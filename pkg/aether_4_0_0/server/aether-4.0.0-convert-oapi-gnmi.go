// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	"github.com/onosproject/aether-roc-api/pkg/aether_4_0_0/types"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	externalRef0 "github.com/onosproject/config-models/modelplugin/aether-4.0.0/aether_4_0_0"

	"reflect"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertyTarget

//Ignoring AdditionalPropertyUnchanged

// EncodeToGnmiApplication converts OAPI to gNMI.
func EncodeToGnmiApplication(
	jsonObj *types.Application, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: application []ApplicationApplication
	if jsonObj.Application != nil { // Optional leaf

	}

	// Property: application []ApplicationApplication
	if jsonObj.Application != nil {
		for _, item := range *jsonObj.Application {
			item := item //Pinning
			paramsApplication := make([]string, len(params))
			copy(paramsApplication, params)
			paramsApplication = append(paramsApplication, "unknown_id")
			updatesApplication, err :=
				EncodeToGnmiApplicationApplication(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "application"), paramsApplication...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesApplication...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Application", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationApplication converts OAPI to gNMI.
func EncodeToGnmiApplicationApplication(
	jsonObj *types.ApplicationApplication, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'ApplicationApplication' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: endpoint []ApplicationApplicationEndpoint
	if jsonObj.Endpoint != nil { // Optional leaf

	}
	// Property: enterprise string
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		if stringValEnterprise == "" {
			return nil, liberrors.NewInvalid("mandatory field 'enterprise' of 'ApplicationApplication' must be provided or added to 'unchanged'")
		}
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'ApplicationApplication' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: endpoint []ApplicationApplicationEndpoint
	if jsonObj.Endpoint != nil {
		for _, item := range *jsonObj.Endpoint {
			item := item //Pinning
			paramsEndpoint := make([]string, len(params))
			copy(paramsEndpoint, params)
			paramsEndpoint = append(paramsEndpoint, "unknown_id")
			updatesEndpoint, err :=
				EncodeToGnmiApplicationApplicationEndpoint(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "endpoint"), paramsEndpoint...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEndpoint...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApplicationApplication", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationApplicationEndpoint converts OAPI to gNMI.
func EncodeToGnmiApplicationApplicationEndpoint(
	jsonObj *types.ApplicationApplicationEndpoint, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: mbr ApplicationApplicationEndpointMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiApplicationApplicationEndpointMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: name string
	_, unchangedName := unchangedAttrs["name"]
	if !unchangedName { // Mandatory leaf

		paramsName := make([]string, len(params))
		copy(paramsName, params)
		stringValName := fmt.Sprintf("%v", jsonObj.Name)
		if stringValName == "" {
			return nil, liberrors.NewInvalid("mandatory field 'name' of 'ApplicationApplicationEndpoint' must be provided or added to 'unchanged'")
		}
		paramsName = append(paramsName, stringValName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointName", paramsName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/name"), paramsName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port-end int
	if jsonObj.PortEnd != nil { // Optional leaf

		paramsPortEnd := make([]string, len(params))
		copy(paramsPortEnd, params)
		stringValPortEnd := fmt.Sprintf("%v", *jsonObj.PortEnd)

		paramsPortEnd = append(paramsPortEnd, stringValPortEnd)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointPortEnd", paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-end"), paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port-start int
	_, unchangedPortStart := unchangedAttrs["port-start"]
	if !unchangedPortStart { // Mandatory leaf

		paramsPortStart := make([]string, len(params))
		copy(paramsPortStart, params)
		stringValPortStart := fmt.Sprintf("%v", jsonObj.PortStart)

		paramsPortStart = append(paramsPortStart, stringValPortStart)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointPortStart", paramsPortStart...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-start"), paramsPortStart...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: protocol string
	if jsonObj.Protocol != nil { // Optional leaf

		paramsProtocol := make([]string, len(params))
		copy(paramsProtocol, params)
		stringValProtocol := fmt.Sprintf("%v", *jsonObj.Protocol)

		paramsProtocol = append(paramsProtocol, stringValProtocol)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointProtocol", paramsProtocol...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/protocol"), paramsProtocol...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil { // Optional leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)

		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApplicationApplicationEndpoint", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationApplicationEndpointMbr converts OAPI to gNMI.
func EncodeToGnmiApplicationApplicationEndpointMbr(
	jsonObj *types.ApplicationApplicationEndpointMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationEndpointMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApplicationApplicationEndpointMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityService(
	jsonObj *types.ConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service []ConnectivityServiceConnectivityService
	if jsonObj.ConnectivityService != nil { // Optional leaf

	}

	// Property: connectivity-service []ConnectivityServiceConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiConnectivityServiceConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityServiceConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityServiceConnectivityService(
	jsonObj *types.ConnectivityServiceConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: acc-prometheus-url string
	if jsonObj.AccPrometheusUrl != nil { // Optional leaf

		paramsAccPrometheusUrl := make([]string, len(params))
		copy(paramsAccPrometheusUrl, params)
		stringValAccPrometheusUrl := fmt.Sprintf("%v", *jsonObj.AccPrometheusUrl)

		paramsAccPrometheusUrl = append(paramsAccPrometheusUrl, stringValAccPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceAccPrometheusUrl", paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/acc-prometheus-url"), paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: core-5g-endpoint string
	if jsonObj.Core5gEndpoint != nil { // Optional leaf

		paramsCore5gEndpoint := make([]string, len(params))
		copy(paramsCore5gEndpoint, params)
		stringValCore5gEndpoint := fmt.Sprintf("%v", *jsonObj.Core5gEndpoint)

		paramsCore5gEndpoint = append(paramsCore5gEndpoint, stringValCore5gEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceCore5gEndpoint", paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/core-5g-endpoint"), paramsCore5gEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: hss-endpoint string
	if jsonObj.HssEndpoint != nil { // Optional leaf

		paramsHssEndpoint := make([]string, len(params))
		copy(paramsHssEndpoint, params)
		stringValHssEndpoint := fmt.Sprintf("%v", *jsonObj.HssEndpoint)

		paramsHssEndpoint = append(paramsHssEndpoint, stringValHssEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceHssEndpoint", paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/hss-endpoint"), paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'ConnectivityServiceConnectivityService' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pcrf-endpoint string
	if jsonObj.PcrfEndpoint != nil { // Optional leaf

		paramsPcrfEndpoint := make([]string, len(params))
		copy(paramsPcrfEndpoint, params)
		stringValPcrfEndpoint := fmt.Sprintf("%v", *jsonObj.PcrfEndpoint)

		paramsPcrfEndpoint = append(paramsPcrfEndpoint, stringValPcrfEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServicePcrfEndpoint", paramsPcrfEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pcrf-endpoint"), paramsPcrfEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: spgwc-endpoint string
	if jsonObj.SpgwcEndpoint != nil { // Optional leaf

		paramsSpgwcEndpoint := make([]string, len(params))
		copy(paramsSpgwcEndpoint, params)
		stringValSpgwcEndpoint := fmt.Sprintf("%v", *jsonObj.SpgwcEndpoint)

		paramsSpgwcEndpoint = append(paramsSpgwcEndpoint, stringValSpgwcEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceSpgwcEndpoint", paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/spgwc-endpoint"), paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServiceConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiDeviceGroup(
	jsonObj *types.DeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-group []DeviceGroupDeviceGroup
	if jsonObj.DeviceGroup != nil { // Optional leaf

	}

	// Property: device-group []DeviceGroupDeviceGroup
	if jsonObj.DeviceGroup != nil {
		for _, item := range *jsonObj.DeviceGroup {
			item := item //Pinning
			paramsDeviceGroup := make([]string, len(params))
			copy(paramsDeviceGroup, params)
			paramsDeviceGroup = append(paramsDeviceGroup, "unknown_id")
			updatesDeviceGroup, err :=
				EncodeToGnmiDeviceGroupDeviceGroup(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device-group"), paramsDeviceGroup...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDeviceGroup...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroupDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiDeviceGroupDeviceGroup(
	jsonObj *types.DeviceGroupDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device DeviceGroupDeviceGroupDevice
	if jsonObj.Device != nil { // Optional leaf

		update, err := EncodeToGnmiDeviceGroupDeviceGroupDevice(
			jsonObj.Device, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "device"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'DeviceGroupDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsis []DeviceGroupDeviceGroupImsis
	if jsonObj.Imsis != nil { // Optional leaf

	}
	// Property: ip-domain string
	if jsonObj.IpDomain != nil { // Optional leaf

		paramsIpDomain := make([]string, len(params))
		copy(paramsIpDomain, params)
		stringValIpDomain := fmt.Sprintf("%v", *jsonObj.IpDomain)

		paramsIpDomain = append(paramsIpDomain, stringValIpDomain)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupIpDomain", paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-domain"), paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: site string
	_, unchangedSite := unchangedAttrs["site"]
	if !unchangedSite { // Mandatory leaf

		paramsSite := make([]string, len(params))
		copy(paramsSite, params)
		stringValSite := fmt.Sprintf("%v", jsonObj.Site)
		if stringValSite == "" {
			return nil, liberrors.NewInvalid("mandatory field 'site' of 'DeviceGroupDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsSite = append(paramsSite, stringValSite)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupSite", paramsSite...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/site"), paramsSite...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: imsis []DeviceGroupDeviceGroupImsis
	if jsonObj.Imsis != nil {
		for _, item := range *jsonObj.Imsis {
			item := item //Pinning
			paramsImsis := make([]string, len(params))
			copy(paramsImsis, params)
			paramsImsis = append(paramsImsis, "unknown_id")
			updatesImsis, err :=
				EncodeToGnmiDeviceGroupDeviceGroupImsis(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "imsis"), paramsImsis...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesImsis...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroupDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroupDeviceGroupDevice converts OAPI to gNMI.
func EncodeToGnmiDeviceGroupDeviceGroupDevice(
	jsonObj *types.DeviceGroupDeviceGroupDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: mbr DeviceGroupDeviceGroupDeviceMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiDeviceGroupDeviceGroupDeviceMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: traffic-class string
	_, unchangedTrafficClass := unchangedAttrs["traffic-class"]
	if !unchangedTrafficClass { // Mandatory leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", jsonObj.TrafficClass)
		if stringValTrafficClass == "" {
			return nil, liberrors.NewInvalid("mandatory field 'traffic-class' of 'DeviceGroupDeviceGroupDevice' must be provided or added to 'unchanged'")
		}
		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupDeviceTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroupDeviceGroupDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroupDeviceGroupDeviceMbr converts OAPI to gNMI.
func EncodeToGnmiDeviceGroupDeviceGroupDeviceMbr(
	jsonObj *types.DeviceGroupDeviceGroupDeviceMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	_, unchangedDownlink := unchangedAttrs["downlink"]
	if !unchangedDownlink { // Mandatory leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupDeviceMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	_, unchangedUplink := unchangedAttrs["uplink"]
	if !unchangedUplink { // Mandatory leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupDeviceMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroupDeviceGroupDeviceMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiDeviceGroupDeviceGroupImsis converts OAPI to gNMI.
func EncodeToGnmiDeviceGroupDeviceGroupImsis(
	jsonObj *types.DeviceGroupDeviceGroupImsis, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: imsi-range-from int64
	if jsonObj.ImsiRangeFrom != nil { // Optional leaf

		paramsImsiRangeFrom := make([]string, len(params))
		copy(paramsImsiRangeFrom, params)
		stringValImsiRangeFrom := fmt.Sprintf("%v", *jsonObj.ImsiRangeFrom)

		paramsImsiRangeFrom = append(paramsImsiRangeFrom, stringValImsiRangeFrom)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupImsisImsiRangeFrom", paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-from"), paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-range-to int64
	if jsonObj.ImsiRangeTo != nil { // Optional leaf

		paramsImsiRangeTo := make([]string, len(params))
		copy(paramsImsiRangeTo, params)
		stringValImsiRangeTo := fmt.Sprintf("%v", *jsonObj.ImsiRangeTo)

		paramsImsiRangeTo = append(paramsImsiRangeTo, stringValImsiRangeTo)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupImsisImsiRangeTo", paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-to"), paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: name string
	_, unchangedName := unchangedAttrs["name"]
	if !unchangedName { // Mandatory leaf

		paramsName := make([]string, len(params))
		copy(paramsName, params)
		stringValName := fmt.Sprintf("%v", jsonObj.Name)
		if stringValName == "" {
			return nil, liberrors.NewInvalid("mandatory field 'name' of 'DeviceGroupDeviceGroupImsis' must be provided or added to 'unchanged'")
		}
		paramsName = append(paramsName, stringValName)
		mpField, err := utils.CreateModelPluginObject(&mp, "DeviceGroupDeviceGroupImsisName", paramsName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/name"), paramsName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "DeviceGroupDeviceGroupImsis", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterprise(
	jsonObj *types.Enterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise []EnterpriseEnterprise
	if jsonObj.Enterprise != nil { // Optional leaf

	}

	// Property: enterprise []EnterpriseEnterprise
	if jsonObj.Enterprise != nil {
		for _, item := range *jsonObj.Enterprise {
			item := item //Pinning
			paramsEnterprise := make([]string, len(params))
			copy(paramsEnterprise, params)
			paramsEnterprise = append(paramsEnterprise, "unknown_id")
			updatesEnterprise, err :=
				EncodeToGnmiEnterpriseEnterprise(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "enterprise"), paramsEnterprise...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEnterprise...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Enterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterprise(
	jsonObj *types.EnterpriseEnterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service []EnterpriseEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil { // Optional leaf

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'EnterpriseEnterprise' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: connectivity-service []EnterpriseEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiEnterpriseEnterpriseConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterpriseConnectivityService converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterpriseConnectivityService(
	jsonObj *types.EnterpriseEnterpriseConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service string
	_, unchangedConnectivityService := unchangedAttrs["connectivity-service"]
	if !unchangedConnectivityService { // Mandatory leaf

		paramsConnectivityService := make([]string, len(params))
		copy(paramsConnectivityService, params)
		stringValConnectivityService := fmt.Sprintf("%v", jsonObj.ConnectivityService)
		if stringValConnectivityService == "" {
			return nil, liberrors.NewInvalid("mandatory field 'connectivity-service' of 'EnterpriseEnterpriseConnectivityService' must be provided or added to 'unchanged'")
		}
		paramsConnectivityService = append(paramsConnectivityService, stringValConnectivityService)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceConnectivityService", paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connectivity-service"), paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	if jsonObj.Enabled != nil { // Optional leaf

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)

		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterpriseConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiIpDomain converts OAPI to gNMI.
func EncodeToGnmiIpDomain(
	jsonObj *types.IpDomain, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: ip-domain []IpDomainIpDomain
	if jsonObj.IpDomain != nil { // Optional leaf

	}

	// Property: ip-domain []IpDomainIpDomain
	if jsonObj.IpDomain != nil {
		for _, item := range *jsonObj.IpDomain {
			item := item //Pinning
			paramsIpDomain := make([]string, len(params))
			copy(paramsIpDomain, params)
			paramsIpDomain = append(paramsIpDomain, "unknown_id")
			updatesIpDomain, err :=
				EncodeToGnmiIpDomainIpDomain(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "ip-domain"), paramsIpDomain...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesIpDomain...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "IpDomain", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiIpDomainIpDomain converts OAPI to gNMI.
func EncodeToGnmiIpDomainIpDomain(
	jsonObj *types.IpDomainIpDomain, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: admin-status string
	if jsonObj.AdminStatus != nil { // Optional leaf

		paramsAdminStatus := make([]string, len(params))
		copy(paramsAdminStatus, params)
		stringValAdminStatus := fmt.Sprintf("%v", *jsonObj.AdminStatus)

		paramsAdminStatus = append(paramsAdminStatus, stringValAdminStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainAdminStatus", paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/admin-status"), paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dnn string
	if jsonObj.Dnn != nil { // Optional leaf

		paramsDnn := make([]string, len(params))
		copy(paramsDnn, params)
		stringValDnn := fmt.Sprintf("%v", *jsonObj.Dnn)

		paramsDnn = append(paramsDnn, stringValDnn)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDnn", paramsDnn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dnn"), paramsDnn...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-primary string
	if jsonObj.DnsPrimary != nil { // Optional leaf

		paramsDnsPrimary := make([]string, len(params))
		copy(paramsDnsPrimary, params)
		stringValDnsPrimary := fmt.Sprintf("%v", *jsonObj.DnsPrimary)

		paramsDnsPrimary = append(paramsDnsPrimary, stringValDnsPrimary)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDnsPrimary", paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-primary"), paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-secondary string
	if jsonObj.DnsSecondary != nil { // Optional leaf

		paramsDnsSecondary := make([]string, len(params))
		copy(paramsDnsSecondary, params)
		stringValDnsSecondary := fmt.Sprintf("%v", *jsonObj.DnsSecondary)

		paramsDnsSecondary = append(paramsDnsSecondary, stringValDnsSecondary)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainDnsSecondary", paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-secondary"), paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		if stringValEnterprise == "" {
			return nil, liberrors.NewInvalid("mandatory field 'enterprise' of 'IpDomainIpDomain' must be provided or added to 'unchanged'")
		}
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'IpDomainIpDomain' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mtu int
	if jsonObj.Mtu != nil { // Optional leaf

		paramsMtu := make([]string, len(params))
		copy(paramsMtu, params)
		stringValMtu := fmt.Sprintf("%v", *jsonObj.Mtu)

		paramsMtu = append(paramsMtu, stringValMtu)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainMtu", paramsMtu...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mtu"), paramsMtu...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: subnet string
	_, unchangedSubnet := unchangedAttrs["subnet"]
	if !unchangedSubnet { // Mandatory leaf

		paramsSubnet := make([]string, len(params))
		copy(paramsSubnet, params)
		stringValSubnet := fmt.Sprintf("%v", jsonObj.Subnet)
		if stringValSubnet == "" {
			return nil, liberrors.NewInvalid("mandatory field 'subnet' of 'IpDomainIpDomain' must be provided or added to 'unchanged'")
		}
		paramsSubnet = append(paramsSubnet, stringValSubnet)
		mpField, err := utils.CreateModelPluginObject(&mp, "IpDomainIpDomainSubnet", paramsSubnet...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/subnet"), paramsSubnet...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "IpDomainIpDomain", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSite converts OAPI to gNMI.
func EncodeToGnmiSite(
	jsonObj *types.Site, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: site []SiteSite
	if jsonObj.Site != nil { // Optional leaf

	}

	// Property: site []SiteSite
	if jsonObj.Site != nil {
		for _, item := range *jsonObj.Site {
			item := item //Pinning
			paramsSite := make([]string, len(params))
			copy(paramsSite, params)
			paramsSite = append(paramsSite, "unknown_id")
			updatesSite, err :=
				EncodeToGnmiSiteSite(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "site"), paramsSite...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSite...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Site", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSite converts OAPI to gNMI.
func EncodeToGnmiSiteSite(
	jsonObj *types.SiteSite, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		if stringValEnterprise == "" {
			return nil, liberrors.NewInvalid("mandatory field 'enterprise' of 'SiteSite' must be provided or added to 'unchanged'")
		}
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'SiteSite' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-definition SiteSiteImsiDefinition
	if jsonObj.ImsiDefinition != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSiteImsiDefinition(
			jsonObj.ImsiDefinition, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "imsi-definition"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: monitoring SiteSiteMonitoring
	if jsonObj.Monitoring != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSiteMonitoring(
			jsonObj.Monitoring, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "monitoring"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: small-cell []SiteSiteSmallCell
	if jsonObj.SmallCell != nil { // Optional leaf

	}

	// Property: small-cell []SiteSiteSmallCell
	if jsonObj.SmallCell != nil {
		for _, item := range *jsonObj.SmallCell {
			item := item //Pinning
			paramsSmallCell := make([]string, len(params))
			copy(paramsSmallCell, params)
			paramsSmallCell = append(paramsSmallCell, "unknown_id")
			updatesSmallCell, err :=
				EncodeToGnmiSiteSiteSmallCell(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "small-cell"), paramsSmallCell...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSmallCell...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSite", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSiteImsiDefinition converts OAPI to gNMI.
func EncodeToGnmiSiteSiteImsiDefinition(
	jsonObj *types.SiteSiteImsiDefinition, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise int32
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)

		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: format string
	_, unchangedFormat := unchangedAttrs["format"]
	if !unchangedFormat { // Mandatory leaf

		paramsFormat := make([]string, len(params))
		copy(paramsFormat, params)
		stringValFormat := fmt.Sprintf("%v", jsonObj.Format)
		if stringValFormat == "" {
			return nil, liberrors.NewInvalid("mandatory field 'format' of 'SiteSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsFormat = append(paramsFormat, stringValFormat)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionFormat", paramsFormat...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/format"), paramsFormat...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mcc string
	_, unchangedMcc := unchangedAttrs["mcc"]
	if !unchangedMcc { // Mandatory leaf

		paramsMcc := make([]string, len(params))
		copy(paramsMcc, params)
		stringValMcc := fmt.Sprintf("%v", jsonObj.Mcc)
		if stringValMcc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mcc' of 'SiteSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMcc = append(paramsMcc, stringValMcc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionMcc", paramsMcc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mcc"), paramsMcc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mnc string
	_, unchangedMnc := unchangedAttrs["mnc"]
	if !unchangedMnc { // Mandatory leaf

		paramsMnc := make([]string, len(params))
		copy(paramsMnc, params)
		stringValMnc := fmt.Sprintf("%v", jsonObj.Mnc)
		if stringValMnc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mnc' of 'SiteSiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMnc = append(paramsMnc, stringValMnc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteImsiDefinitionMnc", paramsMnc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mnc"), paramsMnc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSiteImsiDefinition", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSiteMonitoring converts OAPI to gNMI.
func EncodeToGnmiSiteSiteMonitoring(
	jsonObj *types.SiteSiteMonitoring, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: edge-cluster-prometheus-url string
	if jsonObj.EdgeClusterPrometheusUrl != nil { // Optional leaf

		paramsEdgeClusterPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeClusterPrometheusUrl, params)
		stringValEdgeClusterPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeClusterPrometheusUrl)

		paramsEdgeClusterPrometheusUrl = append(paramsEdgeClusterPrometheusUrl, stringValEdgeClusterPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteMonitoringEdgeClusterPrometheusUrl", paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-cluster-prometheus-url"), paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: edge-device []SiteSiteMonitoringEdgeDevice
	if jsonObj.EdgeDevice != nil { // Optional leaf

	}
	// Property: edge-monitoring-prometheus-url string
	if jsonObj.EdgeMonitoringPrometheusUrl != nil { // Optional leaf

		paramsEdgeMonitoringPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeMonitoringPrometheusUrl, params)
		stringValEdgeMonitoringPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeMonitoringPrometheusUrl)

		paramsEdgeMonitoringPrometheusUrl = append(paramsEdgeMonitoringPrometheusUrl, stringValEdgeMonitoringPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteMonitoringEdgeMonitoringPrometheusUrl", paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-monitoring-prometheus-url"), paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: edge-device []SiteSiteMonitoringEdgeDevice
	if jsonObj.EdgeDevice != nil {
		for _, item := range *jsonObj.EdgeDevice {
			item := item //Pinning
			paramsEdgeDevice := make([]string, len(params))
			copy(paramsEdgeDevice, params)
			paramsEdgeDevice = append(paramsEdgeDevice, "unknown_id")
			updatesEdgeDevice, err :=
				EncodeToGnmiSiteSiteMonitoringEdgeDevice(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "edge-device"), paramsEdgeDevice...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEdgeDevice...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSiteMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSiteMonitoringEdgeDevice converts OAPI to gNMI.
func EncodeToGnmiSiteSiteMonitoringEdgeDevice(
	jsonObj *types.SiteSiteMonitoringEdgeDevice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteMonitoringEdgeDeviceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteMonitoringEdgeDeviceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: name string
	_, unchangedName := unchangedAttrs["name"]
	if !unchangedName { // Mandatory leaf

		paramsName := make([]string, len(params))
		copy(paramsName, params)
		stringValName := fmt.Sprintf("%v", jsonObj.Name)
		if stringValName == "" {
			return nil, liberrors.NewInvalid("mandatory field 'name' of 'SiteSiteMonitoringEdgeDevice' must be provided or added to 'unchanged'")
		}
		paramsName = append(paramsName, stringValName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteMonitoringEdgeDeviceName", paramsName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/name"), paramsName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSiteMonitoringEdgeDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSiteSmallCell converts OAPI to gNMI.
func EncodeToGnmiSiteSiteSmallCell(
	jsonObj *types.SiteSiteSmallCell, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if jsonObj.Address != nil { // Optional leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", *jsonObj.Address)

		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteSmallCellAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteSmallCellEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: name string
	_, unchangedName := unchangedAttrs["name"]
	if !unchangedName { // Mandatory leaf

		paramsName := make([]string, len(params))
		copy(paramsName, params)
		stringValName := fmt.Sprintf("%v", jsonObj.Name)
		if stringValName == "" {
			return nil, liberrors.NewInvalid("mandatory field 'name' of 'SiteSiteSmallCell' must be provided or added to 'unchanged'")
		}
		paramsName = append(paramsName, stringValName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteSmallCellName", paramsName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/name"), paramsName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: tac string
	_, unchangedTac := unchangedAttrs["tac"]
	if !unchangedTac { // Mandatory leaf

		paramsTac := make([]string, len(params))
		copy(paramsTac, params)
		stringValTac := fmt.Sprintf("%v", jsonObj.Tac)
		if stringValTac == "" {
			return nil, liberrors.NewInvalid("mandatory field 'tac' of 'SiteSiteSmallCell' must be provided or added to 'unchanged'")
		}
		paramsTac = append(paramsTac, stringValTac)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteSmallCellTac", paramsTac...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tac"), paramsTac...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSiteSmallCell", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTemplate converts OAPI to gNMI.
func EncodeToGnmiTemplate(
	jsonObj *types.Template, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: template []TemplateTemplate
	if jsonObj.Template != nil { // Optional leaf

	}

	// Property: template []TemplateTemplate
	if jsonObj.Template != nil {
		for _, item := range *jsonObj.Template {
			item := item //Pinning
			paramsTemplate := make([]string, len(params))
			copy(paramsTemplate, params)
			paramsTemplate = append(paramsTemplate, "unknown_id")
			updatesTemplate, err :=
				EncodeToGnmiTemplateTemplate(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "template"), paramsTemplate...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesTemplate...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Template", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTemplateTemplate converts OAPI to gNMI.
func EncodeToGnmiTemplateTemplate(
	jsonObj *types.TemplateTemplate, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'TemplateTemplate' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'TemplateTemplate' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sd int32
	if jsonObj.Sd != nil { // Optional leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", *jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: slice TemplateTemplateSlice
	if jsonObj.Slice != nil { // Optional leaf

		update, err := EncodeToGnmiTemplateTemplateSlice(
			jsonObj.Slice, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "slice"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sst int
	if jsonObj.Sst != nil { // Optional leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", *jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TemplateTemplate", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTemplateTemplateSlice converts OAPI to gNMI.
func EncodeToGnmiTemplateTemplateSlice(
	jsonObj *types.TemplateTemplateSlice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: mbr TemplateTemplateSliceMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiTemplateTemplateSliceMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TemplateTemplateSlice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTemplateTemplateSliceMbr converts OAPI to gNMI.
func EncodeToGnmiTemplateTemplateSliceMbr(
	jsonObj *types.TemplateTemplateSliceMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSliceMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSliceMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSliceMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateSliceMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TemplateTemplateSliceMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClass converts OAPI to gNMI.
func EncodeToGnmiTrafficClass(
	jsonObj *types.TrafficClass, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: traffic-class []TrafficClassTrafficClass
	if jsonObj.TrafficClass != nil { // Optional leaf

	}

	// Property: traffic-class []TrafficClassTrafficClass
	if jsonObj.TrafficClass != nil {
		for _, item := range *jsonObj.TrafficClass {
			item := item //Pinning
			paramsTrafficClass := make([]string, len(params))
			copy(paramsTrafficClass, params)
			paramsTrafficClass = append(paramsTrafficClass, "unknown_id")
			updatesTrafficClass, err :=
				EncodeToGnmiTrafficClassTrafficClass(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "traffic-class"), paramsTrafficClass...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesTrafficClass...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClass", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassTrafficClass converts OAPI to gNMI.
func EncodeToGnmiTrafficClassTrafficClass(
	jsonObj *types.TrafficClassTrafficClass, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: arp int
	if jsonObj.Arp != nil { // Optional leaf

		paramsArp := make([]string, len(params))
		copy(paramsArp, params)
		stringValArp := fmt.Sprintf("%v", *jsonObj.Arp)

		paramsArp = append(paramsArp, stringValArp)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassArp", paramsArp...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/arp"), paramsArp...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'TrafficClassTrafficClass' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pdb int
	if jsonObj.Pdb != nil { // Optional leaf

		paramsPdb := make([]string, len(params))
		copy(paramsPdb, params)
		stringValPdb := fmt.Sprintf("%v", *jsonObj.Pdb)

		paramsPdb = append(paramsPdb, stringValPdb)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassPdb", paramsPdb...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pdb"), paramsPdb...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pelr int
	if jsonObj.Pelr != nil { // Optional leaf

		paramsPelr := make([]string, len(params))
		copy(paramsPelr, params)
		stringValPelr := fmt.Sprintf("%v", *jsonObj.Pelr)

		paramsPelr = append(paramsPelr, stringValPelr)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassPelr", paramsPelr...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pelr"), paramsPelr...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qci int
	if jsonObj.Qci != nil { // Optional leaf

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)

		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClassTrafficClass", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiUpf converts OAPI to gNMI.
func EncodeToGnmiUpf(
	jsonObj *types.Upf, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: upf []UpfUpf
	if jsonObj.Upf != nil { // Optional leaf

	}

	// Property: upf []UpfUpf
	if jsonObj.Upf != nil {
		for _, item := range *jsonObj.Upf {
			item := item //Pinning
			paramsUpf := make([]string, len(params))
			copy(paramsUpf, params)
			paramsUpf = append(paramsUpf, "unknown_id")
			updatesUpf, err :=
				EncodeToGnmiUpfUpf(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "upf"), paramsUpf...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesUpf...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Upf", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiUpfUpf converts OAPI to gNMI.
func EncodeToGnmiUpfUpf(
	jsonObj *types.UpfUpf, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'UpfUpf' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: config-endpoint string
	if jsonObj.ConfigEndpoint != nil { // Optional leaf

		paramsConfigEndpoint := make([]string, len(params))
		copy(paramsConfigEndpoint, params)
		stringValConfigEndpoint := fmt.Sprintf("%v", *jsonObj.ConfigEndpoint)

		paramsConfigEndpoint = append(paramsConfigEndpoint, stringValConfigEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfConfigEndpoint", paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/config-endpoint"), paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		if stringValEnterprise == "" {
			return nil, liberrors.NewInvalid("mandatory field 'enterprise' of 'UpfUpf' must be provided or added to 'unchanged'")
		}
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'UpfUpf' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: port int
	_, unchangedPort := unchangedAttrs["port"]
	if !unchangedPort { // Mandatory leaf

		paramsPort := make([]string, len(params))
		copy(paramsPort, params)
		stringValPort := fmt.Sprintf("%v", jsonObj.Port)

		paramsPort = append(paramsPort, stringValPort)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfPort", paramsPort...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port"), paramsPort...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: site string
	_, unchangedSite := unchangedAttrs["site"]
	if !unchangedSite { // Mandatory leaf

		paramsSite := make([]string, len(params))
		copy(paramsSite, params)
		stringValSite := fmt.Sprintf("%v", jsonObj.Site)
		if stringValSite == "" {
			return nil, liberrors.NewInvalid("mandatory field 'site' of 'UpfUpf' must be provided or added to 'unchanged'")
		}
		paramsSite = append(paramsSite, stringValSite)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpfUpfSite", paramsSite...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/site"), paramsSite...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "UpfUpf", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcs converts OAPI to gNMI.
func EncodeToGnmiVcs(
	jsonObj *types.Vcs, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: vcs []VcsVcs
	if jsonObj.Vcs != nil { // Optional leaf

	}

	// Property: vcs []VcsVcs
	if jsonObj.Vcs != nil {
		for _, item := range *jsonObj.Vcs {
			item := item //Pinning
			paramsVcs := make([]string, len(params))
			copy(paramsVcs, params)
			paramsVcs = append(paramsVcs, "unknown_id")
			updatesVcs, err :=
				EncodeToGnmiVcsVcs(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "vcs"), paramsVcs...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesVcs...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Vcs", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcs converts OAPI to gNMI.
func EncodeToGnmiVcsVcs(
	jsonObj *types.VcsVcs, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'VcsVcs' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: device-group []VcsVcsDeviceGroup
	if jsonObj.DeviceGroup != nil { // Optional leaf

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)
		if stringValEnterprise == "" {
			return nil, liberrors.NewInvalid("mandatory field 'enterprise' of 'VcsVcs' must be provided or added to 'unchanged'")
		}
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: filter []VcsVcsFilter
	if jsonObj.Filter != nil { // Optional leaf

	}
	// Property: id string
	_, unchangedId := unchangedAttrs["id"]
	if !unchangedId { // Mandatory leaf

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", jsonObj.Id)
		if stringValId == "" {
			return nil, liberrors.NewInvalid("mandatory field 'id' of 'VcsVcs' must be provided or added to 'unchanged'")
		}
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sd int32
	_, unchangedSd := unchangedAttrs["sd"]
	if !unchangedSd { // Mandatory leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: site string
	_, unchangedSite := unchangedAttrs["site"]
	if !unchangedSite { // Mandatory leaf

		paramsSite := make([]string, len(params))
		copy(paramsSite, params)
		stringValSite := fmt.Sprintf("%v", jsonObj.Site)
		if stringValSite == "" {
			return nil, liberrors.NewInvalid("mandatory field 'site' of 'VcsVcs' must be provided or added to 'unchanged'")
		}
		paramsSite = append(paramsSite, stringValSite)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSite", paramsSite...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/site"), paramsSite...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: slice VcsVcsSlice
	if jsonObj.Slice != nil { // Optional leaf

		update, err := EncodeToGnmiVcsVcsSlice(
			jsonObj.Slice, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "slice"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sst int
	_, unchangedSst := unchangedAttrs["sst"]
	if !unchangedSst { // Mandatory leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: upf string
	if jsonObj.Upf != nil { // Optional leaf

		paramsUpf := make([]string, len(params))
		copy(paramsUpf, params)
		stringValUpf := fmt.Sprintf("%v", *jsonObj.Upf)

		paramsUpf = append(paramsUpf, stringValUpf)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsUpf", paramsUpf...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf"), paramsUpf...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: device-group []VcsVcsDeviceGroup
	if jsonObj.DeviceGroup != nil {
		for _, item := range *jsonObj.DeviceGroup {
			item := item //Pinning
			paramsDeviceGroup := make([]string, len(params))
			copy(paramsDeviceGroup, params)
			paramsDeviceGroup = append(paramsDeviceGroup, "unknown_id")
			updatesDeviceGroup, err :=
				EncodeToGnmiVcsVcsDeviceGroup(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "device-group"), paramsDeviceGroup...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesDeviceGroup...)
		}
	}

	// Property: filter []VcsVcsFilter
	if jsonObj.Filter != nil {
		for _, item := range *jsonObj.Filter {
			item := item //Pinning
			paramsFilter := make([]string, len(params))
			copy(paramsFilter, params)
			paramsFilter = append(paramsFilter, "unknown_id")
			updatesFilter, err :=
				EncodeToGnmiVcsVcsFilter(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "filter"), paramsFilter...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesFilter...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcs", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcsDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiVcsVcsDeviceGroup(
	jsonObj *types.VcsVcsDeviceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-group string
	_, unchangedDeviceGroup := unchangedAttrs["device-group"]
	if !unchangedDeviceGroup { // Mandatory leaf

		paramsDeviceGroup := make([]string, len(params))
		copy(paramsDeviceGroup, params)
		stringValDeviceGroup := fmt.Sprintf("%v", jsonObj.DeviceGroup)
		if stringValDeviceGroup == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device-group' of 'VcsVcsDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsDeviceGroup = append(paramsDeviceGroup, stringValDeviceGroup)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDeviceGroupDeviceGroup", paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-group"), paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsDeviceGroupEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcsDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcsFilter converts OAPI to gNMI.
func EncodeToGnmiVcsVcsFilter(
	jsonObj *types.VcsVcsFilter, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: allow bool
	if jsonObj.Allow != nil { // Optional leaf

		paramsAllow := make([]string, len(params))
		copy(paramsAllow, params)
		stringValAllow := fmt.Sprintf("%v", *jsonObj.Allow)

		paramsAllow = append(paramsAllow, stringValAllow)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsFilterAllow", paramsAllow...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/allow"), paramsAllow...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: application string
	_, unchangedApplication := unchangedAttrs["application"]
	if !unchangedApplication { // Mandatory leaf

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)
		if stringValApplication == "" {
			return nil, liberrors.NewInvalid("mandatory field 'application' of 'VcsVcsFilter' must be provided or added to 'unchanged'")
		}
		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsFilterApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: priority int
	if jsonObj.Priority != nil { // Optional leaf

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)

		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsFilterPriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcsFilter", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcsSlice converts OAPI to gNMI.
func EncodeToGnmiVcsVcsSlice(
	jsonObj *types.VcsVcsSlice, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: mbr VcsVcsSliceMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiVcsVcsSliceMbr(
			jsonObj.Mbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcsSlice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiVcsVcsSliceMbr converts OAPI to gNMI.
func EncodeToGnmiVcsVcsSliceMbr(
	jsonObj *types.VcsVcsSliceMbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		target = types.Target(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSliceMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSliceMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSliceMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "VcsVcsSliceMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "VcsVcsSliceMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

//Ignoring Target

//Ignoring RequestBodyApplication

//Ignoring RequestBodyApplicationApplication

//Ignoring RequestBodyApplicationApplicationEndpoint

//Ignoring RequestBodyApplicationApplicationEndpointMbr

//Ignoring RequestBodyConnectivityService

//Ignoring RequestBodyConnectivityServiceConnectivityService

//Ignoring RequestBodyDeviceGroup

//Ignoring RequestBodyDeviceGroupDeviceGroup

//Ignoring RequestBodyDeviceGroupDeviceGroupDevice

//Ignoring RequestBodyDeviceGroupDeviceGroupDeviceMbr

//Ignoring RequestBodyDeviceGroupDeviceGroupImsis

//Ignoring RequestBodyEnterprise

//Ignoring RequestBodyEnterpriseEnterprise

//Ignoring RequestBodyEnterpriseEnterpriseConnectivityService

//Ignoring RequestBodyIpDomain

//Ignoring RequestBodyIpDomainIpDomain

//Ignoring RequestBodySite

//Ignoring RequestBodySiteSite

//Ignoring RequestBodySiteSiteImsiDefinition

//Ignoring RequestBodySiteSiteMonitoring

//Ignoring RequestBodySiteSiteMonitoringEdgeDevice

//Ignoring RequestBodySiteSiteSmallCell

//Ignoring RequestBodyTemplate

//Ignoring RequestBodyTemplateTemplate

//Ignoring RequestBodyTemplateTemplateSlice

//Ignoring RequestBodyTemplateTemplateSliceMbr

//Ignoring RequestBodyTrafficClass

//Ignoring RequestBodyTrafficClassTrafficClass

//Ignoring RequestBodyUpf

//Ignoring RequestBodyUpfUpf

//Ignoring RequestBodyVcs

//Ignoring RequestBodyVcsVcs

//Ignoring RequestBodyVcsVcsDeviceGroup

//Ignoring RequestBodyVcsVcsFilter

//Ignoring RequestBodyVcsVcsSlice

//Ignoring RequestBodyVcsVcsSliceMbr

// Not generating param-types
// Not generating request-bodies

// Not generating additional-properties
// Not generating additional-properties
