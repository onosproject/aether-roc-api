// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	externalRef0 "github.com/onosproject/aether-models/models/aether-2.1.x/api"
	"github.com/onosproject/aether-roc-api/pkg/aether_2_1_0/types"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	// Not generating constants
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	// Not generating constants
	// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
	//
	// SPDX-License-Identifier: Apache-2.0

	"reflect"
	"regexp"

	liberrors "github.com/onosproject/onos-lib-go/pkg/errors"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

//Ignoring AdditionalPropertiesUnchTarget

//Ignoring AdditionalPropertyEnterpriseId

//Ignoring AdditionalPropertyUnchanged

// EncodeToGnmiApplication converts OAPI to gNMI.
func EncodeToGnmiApplication(
	jsonObj *types.Application, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'Application' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: application-id ListKey
	_, unchangedApplicationId := unchangedAttrs["application-id"]
	if !unchangedApplicationId { // Mandatory leaf

		paramsApplicationId := make([]string, len(params))
		copy(paramsApplicationId, params)
		stringValApplicationId := fmt.Sprintf("%v", jsonObj.ApplicationId)

		paramsApplicationId = append(paramsApplicationId, stringValApplicationId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationApplicationId", paramsApplicationId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application-id"), paramsApplicationId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: endpoint ApplicationEndpointList
	if jsonObj.Endpoint != nil { // Optional leaf

		update, err := EncodeToGnmiApplicationEndpointList(
			jsonObj.Endpoint, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "endpoint"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Application", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationEndpoint converts OAPI to gNMI.
func EncodeToGnmiApplicationEndpoint(
	jsonObj *types.ApplicationEndpoint, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: endpoint-id ListKey
	_, unchangedEndpointId := unchangedAttrs["endpoint-id"]
	if !unchangedEndpointId { // Mandatory leaf

		paramsEndpointId := make([]string, len(params))
		copy(paramsEndpointId, params)
		stringValEndpointId := fmt.Sprintf("%v", jsonObj.EndpointId)

		paramsEndpointId = append(paramsEndpointId, stringValEndpointId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointEndpointId", paramsEndpointId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint-id"), paramsEndpointId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: mbr ApplicationEndpointMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiApplicationEndpointMbr(
			jsonObj.Mbr, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: port-end int
	if jsonObj.PortEnd != nil { // Optional leaf

		paramsPortEnd := make([]string, len(params))
		copy(paramsPortEnd, params)
		stringValPortEnd := fmt.Sprintf("%v", *jsonObj.PortEnd)

		paramsPortEnd = append(paramsPortEnd, stringValPortEnd)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointPortEnd", paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-end"), paramsPortEnd...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: port-start int
	if jsonObj.PortStart != nil { // Optional leaf

		paramsPortStart := make([]string, len(params))
		copy(paramsPortStart, params)
		stringValPortStart := fmt.Sprintf("%v", *jsonObj.PortStart)

		paramsPortStart = append(paramsPortStart, stringValPortStart)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointPortStart", paramsPortStart...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port-start"), paramsPortStart...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: protocol string
	if jsonObj.Protocol != nil { // Optional leaf

		paramsProtocol := make([]string, len(params))
		copy(paramsProtocol, params)
		stringValProtocol := fmt.Sprintf("%v", *jsonObj.Protocol)

		paramsProtocol = append(paramsProtocol, stringValProtocol)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointProtocol", paramsProtocol...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/protocol"), paramsProtocol...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil { // Optional leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)

		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApplicationEndpoint", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationEndpointList converts OAPI List to gNMI List.
func EncodeToGnmiApplicationEndpointList(
	jsonObj *types.ApplicationEndpointList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiApplicationEndpoint(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiApplicationEndpointMbr converts OAPI to gNMI.
func EncodeToGnmiApplicationEndpointMbr(
	jsonObj *types.ApplicationEndpointMbr, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApplicationEndpointMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApplicationEndpointMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApplicationList converts OAPI List to gNMI List.
func EncodeToGnmiApplicationList(
	jsonObj *types.ApplicationList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiApplication(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSite converts OAPI to gNMI.
func EncodeToGnmiSite(
	jsonObj *types.Site, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service SiteConnectivityService
	if jsonObj.ConnectivityService != nil { // Optional leaf

		update, err := EncodeToGnmiSiteConnectivityService(
			jsonObj.ConnectivityService, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "connectivity-service"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: device SiteDeviceList
	if jsonObj.Device != nil { // Optional leaf

		update, err := EncodeToGnmiSiteDeviceList(
			jsonObj.Device, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "device"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: device-group SiteDeviceGroupList
	if jsonObj.DeviceGroup != nil { // Optional leaf

		update, err := EncodeToGnmiSiteDeviceGroupList(
			jsonObj.DeviceGroup, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "device-group"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: imsi-definition SiteImsiDefinition
	if jsonObj.ImsiDefinition != nil { // Optional leaf

		update, err := EncodeToGnmiSiteImsiDefinition(
			jsonObj.ImsiDefinition, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "imsi-definition"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: ip-domain SiteIpDomainList
	if jsonObj.IpDomain != nil { // Optional leaf

		update, err := EncodeToGnmiSiteIpDomainList(
			jsonObj.IpDomain, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "ip-domain"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: monitoring SiteMonitoring
	if jsonObj.Monitoring != nil { // Optional leaf

		update, err := EncodeToGnmiSiteMonitoring(
			jsonObj.Monitoring, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "monitoring"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sim-card SiteSimCardList
	if jsonObj.SimCard != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSimCardList(
			jsonObj.SimCard, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "sim-card"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: site-id ListKey
	_, unchangedSiteId := unchangedAttrs["site-id"]
	if !unchangedSiteId { // Mandatory leaf

		paramsSiteId := make([]string, len(params))
		copy(paramsSiteId, params)
		stringValSiteId := fmt.Sprintf("%v", jsonObj.SiteId)

		paramsSiteId = append(paramsSiteId, stringValSiteId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSiteId", paramsSiteId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/site-id"), paramsSiteId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: slice SiteSliceList
	if jsonObj.Slice != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSliceList(
			jsonObj.Slice, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "slice"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: small-cell SiteSmallCellList
	if jsonObj.SmallCell != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSmallCellList(
			jsonObj.SmallCell, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "small-cell"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: upf SiteUpfList
	if jsonObj.Upf != nil { // Optional leaf

		update, err := EncodeToGnmiSiteUpfList(
			jsonObj.Upf, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "upf"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Site", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteConnectivityService converts OAPI to gNMI.
func EncodeToGnmiSiteConnectivityService(
	jsonObj *types.SiteConnectivityService, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: core-4g SiteConnectivityServiceCore4g
	if jsonObj.Core4g != nil { // Optional leaf

		update, err := EncodeToGnmiSiteConnectivityServiceCore4g(
			jsonObj.Core4g, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "core-4g"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: core-5g SiteConnectivityServiceCore5g
	if jsonObj.Core5g != nil { // Optional leaf

		update, err := EncodeToGnmiSiteConnectivityServiceCore5g(
			jsonObj.Core5g, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "core-5g"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteConnectivityServiceCore4g converts OAPI to gNMI.
func EncodeToGnmiSiteConnectivityServiceCore4g(
	jsonObj *types.SiteConnectivityServiceCore4g, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: acc-prometheus-url string
	if jsonObj.AccPrometheusUrl != nil { // Optional leaf

		paramsAccPrometheusUrl := make([]string, len(params))
		copy(paramsAccPrometheusUrl, params)
		stringValAccPrometheusUrl := fmt.Sprintf("%v", *jsonObj.AccPrometheusUrl)

		paramsAccPrometheusUrl = append(paramsAccPrometheusUrl, stringValAccPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteConnectivityServiceCore4gAccPrometheusUrl", paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/acc-prometheus-url"), paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: endpoint string
	if jsonObj.Endpoint != nil { // Optional leaf

		paramsEndpoint := make([]string, len(params))
		copy(paramsEndpoint, params)
		stringValEndpoint := fmt.Sprintf("%v", *jsonObj.Endpoint)

		paramsEndpoint = append(paramsEndpoint, stringValEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteConnectivityServiceCore4gEndpoint", paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint"), paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteConnectivityServiceCore4g", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteConnectivityServiceCore5g converts OAPI to gNMI.
func EncodeToGnmiSiteConnectivityServiceCore5g(
	jsonObj *types.SiteConnectivityServiceCore5g, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: acc-prometheus-url string
	if jsonObj.AccPrometheusUrl != nil { // Optional leaf

		paramsAccPrometheusUrl := make([]string, len(params))
		copy(paramsAccPrometheusUrl, params)
		stringValAccPrometheusUrl := fmt.Sprintf("%v", *jsonObj.AccPrometheusUrl)

		paramsAccPrometheusUrl = append(paramsAccPrometheusUrl, stringValAccPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteConnectivityServiceCore5gAccPrometheusUrl", paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/acc-prometheus-url"), paramsAccPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: endpoint string
	if jsonObj.Endpoint != nil { // Optional leaf

		paramsEndpoint := make([]string, len(params))
		copy(paramsEndpoint, params)
		stringValEndpoint := fmt.Sprintf("%v", *jsonObj.Endpoint)

		paramsEndpoint = append(paramsEndpoint, stringValEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteConnectivityServiceCore5gEndpoint", paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint"), paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteConnectivityServiceCore5g", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteDevice converts OAPI to gNMI.
func EncodeToGnmiSiteDevice(
	jsonObj *types.SiteDevice, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: device-id ListKey
	_, unchangedDeviceId := unchangedAttrs["device-id"]
	if !unchangedDeviceId { // Mandatory leaf

		paramsDeviceId := make([]string, len(params))
		copy(paramsDeviceId, params)
		stringValDeviceId := fmt.Sprintf("%v", jsonObj.DeviceId)

		paramsDeviceId = append(paramsDeviceId, stringValDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceDeviceId", paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-id"), paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: imei string
	if jsonObj.Imei != nil { // Optional leaf

		paramsImei := make([]string, len(params))
		copy(paramsImei, params)
		stringValImei := fmt.Sprintf("%v", *jsonObj.Imei)

		paramsImei = append(paramsImei, stringValImei)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceImei", paramsImei...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imei"), paramsImei...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: sim-card string
	if jsonObj.SimCard != nil { // Optional leaf

		paramsSimCard := make([]string, len(params))
		copy(paramsSimCard, params)
		stringValSimCard := fmt.Sprintf("%v", *jsonObj.SimCard)

		paramsSimCard = append(paramsSimCard, stringValSimCard)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceSimCard", paramsSimCard...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sim-card"), paramsSimCard...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: state SiteDeviceState
	if jsonObj.State != nil { // Optional leaf

		update, err := EncodeToGnmiSiteDeviceState(
			jsonObj.State, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "state"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiSiteDeviceGroup(
	jsonObj *types.SiteDeviceGroup, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: device SiteDeviceGroupDeviceList
	if jsonObj.Device != nil { // Optional leaf

		update, err := EncodeToGnmiSiteDeviceGroupDeviceList(
			jsonObj.Device, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "device"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: device-group-id ListKey
	_, unchangedDeviceGroupId := unchangedAttrs["device-group-id"]
	if !unchangedDeviceGroupId { // Mandatory leaf

		paramsDeviceGroupId := make([]string, len(params))
		copy(paramsDeviceGroupId, params)
		stringValDeviceGroupId := fmt.Sprintf("%v", jsonObj.DeviceGroupId)

		paramsDeviceGroupId = append(paramsDeviceGroupId, stringValDeviceGroupId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupDeviceGroupId", paramsDeviceGroupId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-group-id"), paramsDeviceGroupId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: ip-domain string
	if jsonObj.IpDomain != nil { // Optional leaf

		paramsIpDomain := make([]string, len(params))
		copy(paramsIpDomain, params)
		stringValIpDomain := fmt.Sprintf("%v", *jsonObj.IpDomain)

		paramsIpDomain = append(paramsIpDomain, stringValIpDomain)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupIpDomain", paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-domain"), paramsIpDomain...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: mbr SiteDeviceGroupMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiSiteDeviceGroupMbr(
			jsonObj.Mbr, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: traffic-class string
	_, unchangedTrafficClass := unchangedAttrs["traffic-class"]
	if !unchangedTrafficClass { // Mandatory leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", jsonObj.TrafficClass)
		if stringValTrafficClass == "" {
			return nil, liberrors.NewInvalid("mandatory field 'traffic-class' of 'SiteDeviceGroup' must be provided or added to 'unchanged'")
		}
		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteDeviceGroupDevice converts OAPI to gNMI.
func EncodeToGnmiSiteDeviceGroupDevice(
	jsonObj *types.SiteDeviceGroupDevice, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-id ListKey
	_, unchangedDeviceId := unchangedAttrs["device-id"]
	if !unchangedDeviceId { // Mandatory leaf

		paramsDeviceId := make([]string, len(params))
		copy(paramsDeviceId, params)
		stringValDeviceId := fmt.Sprintf("%v", jsonObj.DeviceId)

		paramsDeviceId = append(paramsDeviceId, stringValDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupDeviceDeviceId", paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-id"), paramsDeviceId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupDeviceEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteDeviceGroupDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteDeviceGroupDeviceList converts OAPI List to gNMI List.
func EncodeToGnmiSiteDeviceGroupDeviceList(
	jsonObj *types.SiteDeviceGroupDeviceList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteDeviceGroupDevice(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteDeviceGroupList converts OAPI List to gNMI List.
func EncodeToGnmiSiteDeviceGroupList(
	jsonObj *types.SiteDeviceGroupList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteDeviceGroup(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteDeviceGroupMbr converts OAPI to gNMI.
func EncodeToGnmiSiteDeviceGroupMbr(
	jsonObj *types.SiteDeviceGroupMbr, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	_, unchangedDownlink := unchangedAttrs["downlink"]
	if !unchangedDownlink { // Mandatory leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	_, unchangedUplink := unchangedAttrs["uplink"]
	if !unchangedUplink { // Mandatory leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceGroupMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteDeviceGroupMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteDeviceList converts OAPI List to gNMI List.
func EncodeToGnmiSiteDeviceList(
	jsonObj *types.SiteDeviceList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteDevice(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteDeviceState converts OAPI to gNMI.
func EncodeToGnmiSiteDeviceState(
	jsonObj *types.SiteDeviceState, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connected string
	if jsonObj.Connected != nil { // Optional leaf

		paramsConnected := make([]string, len(params))
		copy(paramsConnected, params)
		stringValConnected := fmt.Sprintf("%v", *jsonObj.Connected)

		paramsConnected = append(paramsConnected, stringValConnected)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceStateConnected", paramsConnected...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connected"), paramsConnected...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: ip-address string
	if jsonObj.IpAddress != nil { // Optional leaf

		paramsIpAddress := make([]string, len(params))
		copy(paramsIpAddress, params)
		stringValIpAddress := fmt.Sprintf("%v", *jsonObj.IpAddress)

		paramsIpAddress = append(paramsIpAddress, stringValIpAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceStateIpAddress", paramsIpAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-address"), paramsIpAddress...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: last-connected string
	if jsonObj.LastConnected != nil { // Optional leaf

		paramsLastConnected := make([]string, len(params))
		copy(paramsLastConnected, params)
		stringValLastConnected := fmt.Sprintf("%v", *jsonObj.LastConnected)

		paramsLastConnected = append(paramsLastConnected, stringValLastConnected)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteDeviceStateLastConnected", paramsLastConnected...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/last-connected"), paramsLastConnected...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteDeviceState", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteImsiDefinition converts OAPI to gNMI.
func EncodeToGnmiSiteImsiDefinition(
	jsonObj *types.SiteImsiDefinition, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise int32
	_, unchangedEnterprise := unchangedAttrs["enterprise"]
	if !unchangedEnterprise { // Mandatory leaf

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", jsonObj.Enterprise)

		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteImsiDefinitionEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: format string
	_, unchangedFormat := unchangedAttrs["format"]
	if !unchangedFormat { // Mandatory leaf

		paramsFormat := make([]string, len(params))
		copy(paramsFormat, params)
		stringValFormat := fmt.Sprintf("%v", jsonObj.Format)
		if stringValFormat == "" {
			return nil, liberrors.NewInvalid("mandatory field 'format' of 'SiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsFormat = append(paramsFormat, stringValFormat)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteImsiDefinitionFormat", paramsFormat...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/format"), paramsFormat...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: mcc string
	_, unchangedMcc := unchangedAttrs["mcc"]
	if !unchangedMcc { // Mandatory leaf

		paramsMcc := make([]string, len(params))
		copy(paramsMcc, params)
		stringValMcc := fmt.Sprintf("%v", jsonObj.Mcc)
		if stringValMcc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mcc' of 'SiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMcc = append(paramsMcc, stringValMcc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteImsiDefinitionMcc", paramsMcc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mcc"), paramsMcc...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: mnc string
	_, unchangedMnc := unchangedAttrs["mnc"]
	if !unchangedMnc { // Mandatory leaf

		paramsMnc := make([]string, len(params))
		copy(paramsMnc, params)
		stringValMnc := fmt.Sprintf("%v", jsonObj.Mnc)
		if stringValMnc == "" {
			return nil, liberrors.NewInvalid("mandatory field 'mnc' of 'SiteImsiDefinition' must be provided or added to 'unchanged'")
		}
		paramsMnc = append(paramsMnc, stringValMnc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteImsiDefinitionMnc", paramsMnc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mnc"), paramsMnc...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteImsiDefinition", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteIpDomain converts OAPI to gNMI.
func EncodeToGnmiSiteIpDomain(
	jsonObj *types.SiteIpDomain, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: admin-status string
	if jsonObj.AdminStatus != nil { // Optional leaf

		paramsAdminStatus := make([]string, len(params))
		copy(paramsAdminStatus, params)
		stringValAdminStatus := fmt.Sprintf("%v", *jsonObj.AdminStatus)

		paramsAdminStatus = append(paramsAdminStatus, stringValAdminStatus)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainAdminStatus", paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/admin-status"), paramsAdminStatus...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: dnn string
	_, unchangedDnn := unchangedAttrs["dnn"]
	if !unchangedDnn { // Mandatory leaf

		paramsDnn := make([]string, len(params))
		copy(paramsDnn, params)
		stringValDnn := fmt.Sprintf("%v", jsonObj.Dnn)
		if stringValDnn == "" {
			return nil, liberrors.NewInvalid("mandatory field 'dnn' of 'SiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsDnn = append(paramsDnn, stringValDnn)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainDnn", paramsDnn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dnn"), paramsDnn...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: dns-primary string
	if jsonObj.DnsPrimary != nil { // Optional leaf

		paramsDnsPrimary := make([]string, len(params))
		copy(paramsDnsPrimary, params)
		stringValDnsPrimary := fmt.Sprintf("%v", *jsonObj.DnsPrimary)

		paramsDnsPrimary = append(paramsDnsPrimary, stringValDnsPrimary)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainDnsPrimary", paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-primary"), paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: dns-secondary string
	if jsonObj.DnsSecondary != nil { // Optional leaf

		paramsDnsSecondary := make([]string, len(params))
		copy(paramsDnsSecondary, params)
		stringValDnsSecondary := fmt.Sprintf("%v", *jsonObj.DnsSecondary)

		paramsDnsSecondary = append(paramsDnsSecondary, stringValDnsSecondary)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainDnsSecondary", paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-secondary"), paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: ip-domain-id ListKey
	_, unchangedIpDomainId := unchangedAttrs["ip-domain-id"]
	if !unchangedIpDomainId { // Mandatory leaf

		paramsIpDomainId := make([]string, len(params))
		copy(paramsIpDomainId, params)
		stringValIpDomainId := fmt.Sprintf("%v", jsonObj.IpDomainId)

		paramsIpDomainId = append(paramsIpDomainId, stringValIpDomainId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainIpDomainId", paramsIpDomainId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/ip-domain-id"), paramsIpDomainId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: mtu int
	if jsonObj.Mtu != nil { // Optional leaf

		paramsMtu := make([]string, len(params))
		copy(paramsMtu, params)
		stringValMtu := fmt.Sprintf("%v", *jsonObj.Mtu)

		paramsMtu = append(paramsMtu, stringValMtu)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainMtu", paramsMtu...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mtu"), paramsMtu...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: subnet string
	_, unchangedSubnet := unchangedAttrs["subnet"]
	if !unchangedSubnet { // Mandatory leaf

		paramsSubnet := make([]string, len(params))
		copy(paramsSubnet, params)
		stringValSubnet := fmt.Sprintf("%v", jsonObj.Subnet)
		if stringValSubnet == "" {
			return nil, liberrors.NewInvalid("mandatory field 'subnet' of 'SiteIpDomain' must be provided or added to 'unchanged'")
		}
		paramsSubnet = append(paramsSubnet, stringValSubnet)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteIpDomainSubnet", paramsSubnet...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/subnet"), paramsSubnet...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteIpDomain", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteIpDomainList converts OAPI List to gNMI List.
func EncodeToGnmiSiteIpDomainList(
	jsonObj *types.SiteIpDomainList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteIpDomain(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteList converts OAPI List to gNMI List.
func EncodeToGnmiSiteList(
	jsonObj *types.SiteList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSite(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteMonitoring converts OAPI to gNMI.
func EncodeToGnmiSiteMonitoring(
	jsonObj *types.SiteMonitoring, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: edge-cluster-prometheus-url string
	if jsonObj.EdgeClusterPrometheusUrl != nil { // Optional leaf

		paramsEdgeClusterPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeClusterPrometheusUrl, params)
		stringValEdgeClusterPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeClusterPrometheusUrl)

		paramsEdgeClusterPrometheusUrl = append(paramsEdgeClusterPrometheusUrl, stringValEdgeClusterPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteMonitoringEdgeClusterPrometheusUrl", paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-cluster-prometheus-url"), paramsEdgeClusterPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: edge-device SiteMonitoringEdgeDeviceList
	if jsonObj.EdgeDevice != nil { // Optional leaf

		update, err := EncodeToGnmiSiteMonitoringEdgeDeviceList(
			jsonObj.EdgeDevice, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "edge-device"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: edge-monitoring-prometheus-url string
	if jsonObj.EdgeMonitoringPrometheusUrl != nil { // Optional leaf

		paramsEdgeMonitoringPrometheusUrl := make([]string, len(params))
		copy(paramsEdgeMonitoringPrometheusUrl, params)
		stringValEdgeMonitoringPrometheusUrl := fmt.Sprintf("%v", *jsonObj.EdgeMonitoringPrometheusUrl)

		paramsEdgeMonitoringPrometheusUrl = append(paramsEdgeMonitoringPrometheusUrl, stringValEdgeMonitoringPrometheusUrl)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteMonitoringEdgeMonitoringPrometheusUrl", paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-monitoring-prometheus-url"), paramsEdgeMonitoringPrometheusUrl...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteMonitoring", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteMonitoringEdgeDevice converts OAPI to gNMI.
func EncodeToGnmiSiteMonitoringEdgeDevice(
	jsonObj *types.SiteMonitoringEdgeDevice, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteMonitoringEdgeDeviceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteMonitoringEdgeDeviceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: edge-device-id ListKey
	_, unchangedEdgeDeviceId := unchangedAttrs["edge-device-id"]
	if !unchangedEdgeDeviceId { // Mandatory leaf

		paramsEdgeDeviceId := make([]string, len(params))
		copy(paramsEdgeDeviceId, params)
		stringValEdgeDeviceId := fmt.Sprintf("%v", jsonObj.EdgeDeviceId)

		paramsEdgeDeviceId = append(paramsEdgeDeviceId, stringValEdgeDeviceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteMonitoringEdgeDeviceEdgeDeviceId", paramsEdgeDeviceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/edge-device-id"), paramsEdgeDeviceId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteMonitoringEdgeDevice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteMonitoringEdgeDeviceList converts OAPI List to gNMI List.
func EncodeToGnmiSiteMonitoringEdgeDeviceList(
	jsonObj *types.SiteMonitoringEdgeDeviceList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteMonitoringEdgeDevice(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteSimCard converts OAPI to gNMI.
func EncodeToGnmiSiteSimCard(
	jsonObj *types.SiteSimCard, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSimCardDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSimCardDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: iccid string
	if jsonObj.Iccid != nil { // Optional leaf

		paramsIccid := make([]string, len(params))
		copy(paramsIccid, params)
		stringValIccid := fmt.Sprintf("%v", *jsonObj.Iccid)

		paramsIccid = append(paramsIccid, stringValIccid)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSimCardIccid", paramsIccid...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/iccid"), paramsIccid...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: imsi int64
	if jsonObj.Imsi != nil { // Optional leaf

		paramsImsi := make([]string, len(params))
		copy(paramsImsi, params)
		stringValImsi := fmt.Sprintf("%v", *jsonObj.Imsi)

		paramsImsi = append(paramsImsi, stringValImsi)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSimCardImsi", paramsImsi...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi"), paramsImsi...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: sim-id ListKey
	_, unchangedSimId := unchangedAttrs["sim-id"]
	if !unchangedSimId { // Mandatory leaf

		paramsSimId := make([]string, len(params))
		copy(paramsSimId, params)
		stringValSimId := fmt.Sprintf("%v", jsonObj.SimId)

		paramsSimId = append(paramsSimId, stringValSimId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSimCardSimId", paramsSimId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sim-id"), paramsSimId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSimCard", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSimCardList converts OAPI List to gNMI List.
func EncodeToGnmiSiteSimCardList(
	jsonObj *types.SiteSimCardList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteSimCard(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteSlice converts OAPI to gNMI.
func EncodeToGnmiSiteSlice(
	jsonObj *types.SiteSlice, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service string
	if jsonObj.ConnectivityService != nil { // Optional leaf

		paramsConnectivityService := make([]string, len(params))
		copy(paramsConnectivityService, params)
		paramsConnectivityService = append(paramsConnectivityService, (string)(*jsonObj.ConnectivityService))
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceConnectivityService", paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField,
			fmt.Sprintf("%s%s", parentPath, "/connectivity-service"), paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'SiteSlice' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: device-group SiteSliceDeviceGroupList
	if jsonObj.DeviceGroup != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSliceDeviceGroupList(
			jsonObj.DeviceGroup, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "device-group"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: filter SiteSliceFilterList
	if jsonObj.Filter != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSliceFilterList(
			jsonObj.Filter, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "filter"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: mbr SiteSliceMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSliceMbr(
			jsonObj.Mbr, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: priority-traffic-rule SiteSlicePriorityTrafficRuleList
	if jsonObj.PriorityTrafficRule != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSlicePriorityTrafficRuleList(
			jsonObj.PriorityTrafficRule, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "priority-traffic-rule"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sd int32
	_, unchangedSd := unchangedAttrs["sd"]
	if !unchangedSd { // Mandatory leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: slice-id ListKey
	_, unchangedSliceId := unchangedAttrs["slice-id"]
	if !unchangedSliceId { // Mandatory leaf

		paramsSliceId := make([]string, len(params))
		copy(paramsSliceId, params)
		stringValSliceId := fmt.Sprintf("%v", jsonObj.SliceId)

		paramsSliceId = append(paramsSliceId, stringValSliceId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceSliceId", paramsSliceId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/slice-id"), paramsSliceId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: sst int
	_, unchangedSst := unchangedAttrs["sst"]
	if !unchangedSst { // Mandatory leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: upf string
	if jsonObj.Upf != nil { // Optional leaf

		paramsUpf := make([]string, len(params))
		copy(paramsUpf, params)
		stringValUpf := fmt.Sprintf("%v", *jsonObj.Upf)

		paramsUpf = append(paramsUpf, stringValUpf)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceUpf", paramsUpf...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf"), paramsUpf...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSlice", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSliceConnectivityService converts OAPI to gNMI.
func EncodeToGnmiSiteSliceConnectivityService(
	jsonObj *types.SiteSliceConnectivityService, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSliceConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSliceDeviceGroup converts OAPI to gNMI.
func EncodeToGnmiSiteSliceDeviceGroup(
	jsonObj *types.SiteSliceDeviceGroup, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: device-group ListKey
	_, unchangedDeviceGroup := unchangedAttrs["device-group"]
	if !unchangedDeviceGroup { // Mandatory leaf

		paramsDeviceGroup := make([]string, len(params))
		copy(paramsDeviceGroup, params)
		stringValDeviceGroup := fmt.Sprintf("%v", jsonObj.DeviceGroup)

		paramsDeviceGroup = append(paramsDeviceGroup, stringValDeviceGroup)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceDeviceGroupDeviceGroup", paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device-group"), paramsDeviceGroup...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceDeviceGroupEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSliceDeviceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSliceDeviceGroupList converts OAPI List to gNMI List.
func EncodeToGnmiSiteSliceDeviceGroupList(
	jsonObj *types.SiteSliceDeviceGroupList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteSliceDeviceGroup(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteSliceFilter converts OAPI to gNMI.
func EncodeToGnmiSiteSliceFilter(
	jsonObj *types.SiteSliceFilter, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: allow bool
	if jsonObj.Allow != nil { // Optional leaf

		paramsAllow := make([]string, len(params))
		copy(paramsAllow, params)
		stringValAllow := fmt.Sprintf("%v", *jsonObj.Allow)

		paramsAllow = append(paramsAllow, stringValAllow)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceFilterAllow", paramsAllow...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/allow"), paramsAllow...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: application ListKey
	_, unchangedApplication := unchangedAttrs["application"]
	if !unchangedApplication { // Mandatory leaf

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)

		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceFilterApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: priority int
	if jsonObj.Priority != nil { // Optional leaf

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)

		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceFilterPriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSliceFilter", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSliceFilterList converts OAPI List to gNMI List.
func EncodeToGnmiSiteSliceFilterList(
	jsonObj *types.SiteSliceFilterList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteSliceFilter(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteSliceList converts OAPI List to gNMI List.
func EncodeToGnmiSiteSliceList(
	jsonObj *types.SiteSliceList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteSlice(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteSliceMbr converts OAPI to gNMI.
func EncodeToGnmiSiteSliceMbr(
	jsonObj *types.SiteSliceMbr, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSliceMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSliceMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSlicePriorityTrafficRule converts OAPI to gNMI.
func EncodeToGnmiSiteSlicePriorityTrafficRule(
	jsonObj *types.SiteSlicePriorityTrafficRule, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: application string
	_, unchangedApplication := unchangedAttrs["application"]
	if !unchangedApplication { // Mandatory leaf

		paramsApplication := make([]string, len(params))
		copy(paramsApplication, params)
		stringValApplication := fmt.Sprintf("%v", jsonObj.Application)
		if stringValApplication == "" {
			return nil, liberrors.NewInvalid("mandatory field 'application' of 'SiteSlicePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsApplication = append(paramsApplication, stringValApplication)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleApplication", paramsApplication...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/application"), paramsApplication...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: device string
	_, unchangedDevice := unchangedAttrs["device"]
	if !unchangedDevice { // Mandatory leaf

		paramsDevice := make([]string, len(params))
		copy(paramsDevice, params)
		stringValDevice := fmt.Sprintf("%v", jsonObj.Device)
		if stringValDevice == "" {
			return nil, liberrors.NewInvalid("mandatory field 'device' of 'SiteSlicePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsDevice = append(paramsDevice, stringValDevice)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleDevice", paramsDevice...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/device"), paramsDevice...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: endpoint string
	_, unchangedEndpoint := unchangedAttrs["endpoint"]
	if !unchangedEndpoint { // Mandatory leaf

		paramsEndpoint := make([]string, len(params))
		copy(paramsEndpoint, params)
		stringValEndpoint := fmt.Sprintf("%v", jsonObj.Endpoint)
		if stringValEndpoint == "" {
			return nil, liberrors.NewInvalid("mandatory field 'endpoint' of 'SiteSlicePriorityTrafficRule' must be provided or added to 'unchanged'")
		}
		paramsEndpoint = append(paramsEndpoint, stringValEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleEndpoint", paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/endpoint"), paramsEndpoint...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: gbr SiteSlicePriorityTrafficRuleGbr
	if jsonObj.Gbr != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSlicePriorityTrafficRuleGbr(
			jsonObj.Gbr, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "gbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: mbr SiteSlicePriorityTrafficRuleMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiSiteSlicePriorityTrafficRuleMbr(
			jsonObj.Mbr, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: priority-traffic-rule-id ListKey
	_, unchangedPriorityTrafficRuleId := unchangedAttrs["priority-traffic-rule-id"]
	if !unchangedPriorityTrafficRuleId { // Mandatory leaf

		paramsPriorityTrafficRuleId := make([]string, len(params))
		copy(paramsPriorityTrafficRuleId, params)
		stringValPriorityTrafficRuleId := fmt.Sprintf("%v", jsonObj.PriorityTrafficRuleId)

		paramsPriorityTrafficRuleId = append(paramsPriorityTrafficRuleId, stringValPriorityTrafficRuleId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRulePriorityTrafficRuleId", paramsPriorityTrafficRuleId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority-traffic-rule-id"), paramsPriorityTrafficRuleId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class string
	if jsonObj.TrafficClass != nil { // Optional leaf

		paramsTrafficClass := make([]string, len(params))
		copy(paramsTrafficClass, params)
		stringValTrafficClass := fmt.Sprintf("%v", *jsonObj.TrafficClass)

		paramsTrafficClass = append(paramsTrafficClass, stringValTrafficClass)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleTrafficClass", paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class"), paramsTrafficClass...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSlicePriorityTrafficRule", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSlicePriorityTrafficRuleGbr converts OAPI to gNMI.
func EncodeToGnmiSiteSlicePriorityTrafficRuleGbr(
	jsonObj *types.SiteSlicePriorityTrafficRuleGbr, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleGbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleGbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSlicePriorityTrafficRuleGbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSlicePriorityTrafficRuleList converts OAPI List to gNMI List.
func EncodeToGnmiSiteSlicePriorityTrafficRuleList(
	jsonObj *types.SiteSlicePriorityTrafficRuleList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteSlicePriorityTrafficRule(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteSlicePriorityTrafficRuleMbr converts OAPI to gNMI.
func EncodeToGnmiSiteSlicePriorityTrafficRuleMbr(
	jsonObj *types.SiteSlicePriorityTrafficRuleMbr, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSlicePriorityTrafficRuleMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSlicePriorityTrafficRuleMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSmallCell converts OAPI to gNMI.
func EncodeToGnmiSiteSmallCell(
	jsonObj *types.SiteSmallCell, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	if jsonObj.Address != nil { // Optional leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", *jsonObj.Address)

		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSmallCellAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSmallCellDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSmallCellDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: enable bool
	if jsonObj.Enable != nil { // Optional leaf

		paramsEnable := make([]string, len(params))
		copy(paramsEnable, params)
		stringValEnable := fmt.Sprintf("%v", *jsonObj.Enable)

		paramsEnable = append(paramsEnable, stringValEnable)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSmallCellEnable", paramsEnable...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enable"), paramsEnable...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: small-cell-id ListKey
	_, unchangedSmallCellId := unchangedAttrs["small-cell-id"]
	if !unchangedSmallCellId { // Mandatory leaf

		paramsSmallCellId := make([]string, len(params))
		copy(paramsSmallCellId, params)
		stringValSmallCellId := fmt.Sprintf("%v", jsonObj.SmallCellId)

		paramsSmallCellId = append(paramsSmallCellId, stringValSmallCellId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSmallCellSmallCellId", paramsSmallCellId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/small-cell-id"), paramsSmallCellId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: tac string
	_, unchangedTac := unchangedAttrs["tac"]
	if !unchangedTac { // Mandatory leaf

		paramsTac := make([]string, len(params))
		copy(paramsTac, params)
		stringValTac := fmt.Sprintf("%v", jsonObj.Tac)
		if stringValTac == "" {
			return nil, liberrors.NewInvalid("mandatory field 'tac' of 'SiteSmallCell' must be provided or added to 'unchanged'")
		}
		paramsTac = append(paramsTac, stringValTac)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteSmallCellTac", paramsTac...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tac"), paramsTac...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteSmallCell", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteSmallCellList converts OAPI List to gNMI List.
func EncodeToGnmiSiteSmallCellList(
	jsonObj *types.SiteSmallCellList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteSmallCell(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiSiteUpf converts OAPI to gNMI.
func EncodeToGnmiSiteUpf(
	jsonObj *types.SiteUpf, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: address string
	_, unchangedAddress := unchangedAttrs["address"]
	if !unchangedAddress { // Mandatory leaf

		paramsAddress := make([]string, len(params))
		copy(paramsAddress, params)
		stringValAddress := fmt.Sprintf("%v", jsonObj.Address)
		if stringValAddress == "" {
			return nil, liberrors.NewInvalid("mandatory field 'address' of 'SiteUpf' must be provided or added to 'unchanged'")
		}
		paramsAddress = append(paramsAddress, stringValAddress)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteUpfAddress", paramsAddress...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/address"), paramsAddress...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: config-endpoint string
	if jsonObj.ConfigEndpoint != nil { // Optional leaf

		paramsConfigEndpoint := make([]string, len(params))
		copy(paramsConfigEndpoint, params)
		stringValConfigEndpoint := fmt.Sprintf("%v", *jsonObj.ConfigEndpoint)

		paramsConfigEndpoint = append(paramsConfigEndpoint, stringValConfigEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteUpfConfigEndpoint", paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/config-endpoint"), paramsConfigEndpoint...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteUpfDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteUpfDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: port int
	_, unchangedPort := unchangedAttrs["port"]
	if !unchangedPort { // Mandatory leaf

		paramsPort := make([]string, len(params))
		copy(paramsPort, params)
		stringValPort := fmt.Sprintf("%v", jsonObj.Port)

		paramsPort = append(paramsPort, stringValPort)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteUpfPort", paramsPort...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/port"), paramsPort...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: upf-id ListKey
	_, unchangedUpfId := unchangedAttrs["upf-id"]
	if !unchangedUpfId { // Mandatory leaf

		paramsUpfId := make([]string, len(params))
		copy(paramsUpfId, params)
		stringValUpfId := fmt.Sprintf("%v", jsonObj.UpfId)

		paramsUpfId = append(paramsUpfId, stringValUpfId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SiteUpfUpfId", paramsUpfId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/upf-id"), paramsUpfId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SiteUpf", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSiteUpfList converts OAPI List to gNMI List.
func EncodeToGnmiSiteUpfList(
	jsonObj *types.SiteUpfList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiSiteUpf(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiTemplate converts OAPI to gNMI.
func EncodeToGnmiTemplate(
	jsonObj *types.Template, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: default-behavior string
	_, unchangedDefaultBehavior := unchangedAttrs["default-behavior"]
	if !unchangedDefaultBehavior { // Mandatory leaf

		paramsDefaultBehavior := make([]string, len(params))
		copy(paramsDefaultBehavior, params)
		stringValDefaultBehavior := fmt.Sprintf("%v", jsonObj.DefaultBehavior)
		if stringValDefaultBehavior == "" {
			return nil, liberrors.NewInvalid("mandatory field 'default-behavior' of 'Template' must be provided or added to 'unchanged'")
		}
		paramsDefaultBehavior = append(paramsDefaultBehavior, stringValDefaultBehavior)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateDefaultBehavior", paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/default-behavior"), paramsDefaultBehavior...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: mbr TemplateMbr
	if jsonObj.Mbr != nil { // Optional leaf

		update, err := EncodeToGnmiTemplateMbr(
			jsonObj.Mbr, false, removeIndex, enterpriseId,
			fmt.Sprintf("%s/%s", parentPath, "mbr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: sd int32
	if jsonObj.Sd != nil { // Optional leaf

		paramsSd := make([]string, len(params))
		copy(paramsSd, params)
		stringValSd := fmt.Sprintf("%v", *jsonObj.Sd)

		paramsSd = append(paramsSd, stringValSd)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateSd", paramsSd...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sd"), paramsSd...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: sst int
	if jsonObj.Sst != nil { // Optional leaf

		paramsSst := make([]string, len(params))
		copy(paramsSst, params)
		stringValSst := fmt.Sprintf("%v", *jsonObj.Sst)

		paramsSst = append(paramsSst, stringValSst)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateSst", paramsSst...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sst"), paramsSst...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: template-id ListKey
	_, unchangedTemplateId := unchangedAttrs["template-id"]
	if !unchangedTemplateId { // Mandatory leaf

		paramsTemplateId := make([]string, len(params))
		copy(paramsTemplateId, params)
		stringValTemplateId := fmt.Sprintf("%v", jsonObj.TemplateId)

		paramsTemplateId = append(paramsTemplateId, stringValTemplateId)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateTemplateId", paramsTemplateId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/template-id"), paramsTemplateId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Template", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTemplateList converts OAPI List to gNMI List.
func EncodeToGnmiTemplateList(
	jsonObj *types.TemplateList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiTemplate(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiTemplateMbr converts OAPI to gNMI.
func EncodeToGnmiTemplateMbr(
	jsonObj *types.TemplateMbr, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int64
	if jsonObj.Downlink != nil { // Optional leaf

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)

		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateMbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: downlink-burst-size int32
	if jsonObj.DownlinkBurstSize != nil { // Optional leaf

		paramsDownlinkBurstSize := make([]string, len(params))
		copy(paramsDownlinkBurstSize, params)
		stringValDownlinkBurstSize := fmt.Sprintf("%v", *jsonObj.DownlinkBurstSize)

		paramsDownlinkBurstSize = append(paramsDownlinkBurstSize, stringValDownlinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateMbrDownlinkBurstSize", paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink-burst-size"), paramsDownlinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink int64
	if jsonObj.Uplink != nil { // Optional leaf

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)

		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateMbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: uplink-burst-size int32
	if jsonObj.UplinkBurstSize != nil { // Optional leaf

		paramsUplinkBurstSize := make([]string, len(params))
		copy(paramsUplinkBurstSize, params)
		stringValUplinkBurstSize := fmt.Sprintf("%v", *jsonObj.UplinkBurstSize)

		paramsUplinkBurstSize = append(paramsUplinkBurstSize, stringValUplinkBurstSize)
		mpField, err := utils.CreateModelPluginObject(&mp, "TemplateMbrUplinkBurstSize", paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink-burst-size"), paramsUplinkBurstSize...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TemplateMbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClass converts OAPI to gNMI.
func EncodeToGnmiTrafficClass(
	jsonObj *types.TrafficClass, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: arp int
	if jsonObj.Arp != nil { // Optional leaf

		paramsArp := make([]string, len(params))
		copy(paramsArp, params)
		stringValArp := fmt.Sprintf("%v", *jsonObj.Arp)

		paramsArp = append(paramsArp, stringValArp)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassArp", paramsArp...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/arp"), paramsArp...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil { // Optional leaf

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)

		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil { // Optional leaf

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)

		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: pdb int
	if jsonObj.Pdb != nil { // Optional leaf

		paramsPdb := make([]string, len(params))
		copy(paramsPdb, params)
		stringValPdb := fmt.Sprintf("%v", *jsonObj.Pdb)

		paramsPdb = append(paramsPdb, stringValPdb)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassPdb", paramsPdb...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pdb"), paramsPdb...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: pelr int
	if jsonObj.Pelr != nil { // Optional leaf

		paramsPelr := make([]string, len(params))
		copy(paramsPelr, params)
		stringValPelr := fmt.Sprintf("%v", *jsonObj.Pelr)

		paramsPelr = append(paramsPelr, stringValPelr)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassPelr", paramsPelr...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pelr"), paramsPelr...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: qci int
	if jsonObj.Qci != nil { // Optional leaf

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)

		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}
	// Property: traffic-class-id ListKey
	_, unchangedTrafficClassId := unchangedAttrs["traffic-class-id"]
	if !unchangedTrafficClassId { // Mandatory leaf

		paramsTrafficClassId := make([]string, len(params))
		copy(paramsTrafficClassId, params)
		stringValTrafficClassId := fmt.Sprintf("%v", jsonObj.TrafficClassId)

		paramsTrafficClassId = append(paramsTrafficClassId, stringValTrafficClassId)
		mpField, err := utils.CreateModelPluginObject(&mp, "TrafficClassTrafficClassId", paramsTrafficClassId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/traffic-class-id"), paramsTrafficClassId...)
		if err != nil {
			return nil, err
		}
		if enterpriseId != "" {
			update.Path.Target = string(enterpriseId)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "TrafficClass", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiTrafficClassList converts OAPI List to gNMI List.
func EncodeToGnmiTrafficClassList(
	jsonObj *types.TrafficClassList, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	updates := make([]*gnmi.Update, 0)
	for _, childObj := range *jsonObj {
		childObj := childObj //Pinning
		allParams := make([]string, len(params))
		copy(allParams, params)
		allParams = append(allParams, "unknown_id")

		newUpdates, err := EncodeToGnmiTrafficClass(&childObj, true, removeIndex, enterpriseId, fmt.Sprintf("%s/{unknown_key}", parentPath), allParams...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, newUpdates...)
	}

	return updates, nil
}

// EncodeToGnmiEnterpriseId converts OAPI to gNMI.
func EncodeToGnmiEnterpriseId(
	jsonObj *types.EnterpriseId, needKey bool, removeIndex bool, enterpriseId types.EnterpriseId, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	unchangedAttrs, tgt := utils.CheckForAdditionalProps(jsonObj)
	if tgt != nil {
		enterpriseId = types.EnterpriseId(*tgt)
	}
	_ = len(unchangedAttrs)

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseId", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

//Ignoring RequestBodyApplication

//Ignoring RequestBodyApplicationEndpoint

//Ignoring RequestBodyApplicationEndpointMbr

//Ignoring RequestBodySite

//Ignoring RequestBodySiteConnectivityService

//Ignoring RequestBodySiteConnectivityServiceCore4g

//Ignoring RequestBodySiteConnectivityServiceCore5g

//Ignoring RequestBodySiteDevice

//Ignoring RequestBodySiteDeviceGroup

//Ignoring RequestBodySiteDeviceGroupDevice

//Ignoring RequestBodySiteDeviceGroupMbr

//Ignoring RequestBodySiteImsiDefinition

//Ignoring RequestBodySiteIpDomain

//Ignoring RequestBodySiteMonitoring

//Ignoring RequestBodySiteMonitoringEdgeDevice

//Ignoring RequestBodySiteSimCard

//Ignoring RequestBodySiteSlice

//Ignoring RequestBodySiteSliceDeviceGroup

//Ignoring RequestBodySiteSliceFilter

//Ignoring RequestBodySiteSliceMbr

//Ignoring RequestBodySiteSlicePriorityTrafficRule

//Ignoring RequestBodySiteSmallCell

//Ignoring RequestBodySiteUpf

//Ignoring RequestBodyTemplate

//Ignoring RequestBodyTemplateMbr

//Ignoring RequestBodyTrafficClass

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating param-types
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating request-bodies

// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
// SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0

// Not generating additional-properties
