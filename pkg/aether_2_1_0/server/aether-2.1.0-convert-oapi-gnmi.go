// Code generated by oapi-codegen. DO NOT EDIT.
// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package server

import (
	"fmt"
	"strings"

	"reflect"
	"regexp"

	"github.com/onosproject/aether-roc-api/pkg/aether_2_1_0/types"
	"github.com/onosproject/aether-roc-api/pkg/utils"
	externalRef0 "github.com/onosproject/config-models/modelplugin/aether-2.1.0/aether_2_1_0"
	"github.com/openconfig/gnmi/proto/gnmi"
)

var re *regexp.Regexp = regexp.MustCompile(`[A-Z][^A-Z]*`)

// EncodeToGnmiAccessProfile converts OAPI to gNMI.
func EncodeToGnmiAccessProfile(
	jsonObj *types.AccessProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: access-profile []AccessProfileAccessProfile
	if jsonObj.AccessProfile != nil {

	}

	// Property: access-profile []AccessProfileAccessProfile
	if jsonObj.AccessProfile != nil {
		for _, item := range *jsonObj.AccessProfile {
			item := item //Pinning
			paramsAccessProfile := make([]string, len(params))
			copy(paramsAccessProfile, params)
			paramsAccessProfile = append(paramsAccessProfile, "unknown_id")
			updatesAccessProfile, err :=
				EncodeToGnmiAccessProfileAccessProfile(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "access-profile"), paramsAccessProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesAccessProfile...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "AccessProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiAccessProfileAccessProfile converts OAPI to gNMI.
func EncodeToGnmiAccessProfileAccessProfile(
	jsonObj *types.AccessProfileAccessProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: filter string
	if jsonObj.Filter != nil {

		paramsFilter := make([]string, len(params))
		copy(paramsFilter, params)
		stringValFilter := fmt.Sprintf("%v", *jsonObj.Filter)
		paramsFilter = append(paramsFilter, stringValFilter)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileFilter", paramsFilter...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/filter"), paramsFilter...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: type string
	if jsonObj.Type != nil {

		paramsType := make([]string, len(params))
		copy(paramsType, params)
		stringValType := fmt.Sprintf("%v", *jsonObj.Type)
		paramsType = append(paramsType, stringValType)
		mpField, err := utils.CreateModelPluginObject(&mp, "AccessProfileAccessProfileType", paramsType...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/type"), paramsType...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "AccessProfileAccessProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

//Ignoring AdditionalPropertyTarget

// EncodeToGnmiApnProfile converts OAPI to gNMI.
func EncodeToGnmiApnProfile(
	jsonObj *types.ApnProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: apn-profile []ApnProfileApnProfile
	if jsonObj.ApnProfile != nil {

	}

	// Property: apn-profile []ApnProfileApnProfile
	if jsonObj.ApnProfile != nil {
		for _, item := range *jsonObj.ApnProfile {
			item := item //Pinning
			paramsApnProfile := make([]string, len(params))
			copy(paramsApnProfile, params)
			paramsApnProfile = append(paramsApnProfile, "unknown_id")
			updatesApnProfile, err :=
				EncodeToGnmiApnProfileApnProfile(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "apn-profile"), paramsApnProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesApnProfile...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApnProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiApnProfileApnProfile converts OAPI to gNMI.
func EncodeToGnmiApnProfileApnProfile(
	jsonObj *types.ApnProfileApnProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: apn-name string
	if jsonObj.ApnName != nil {

		paramsApnName := make([]string, len(params))
		copy(paramsApnName, params)
		stringValApnName := fmt.Sprintf("%v", *jsonObj.ApnName)
		paramsApnName = append(paramsApnName, stringValApnName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileApnName", paramsApnName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/apn-name"), paramsApnName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-primary string
	if jsonObj.DnsPrimary != nil {

		paramsDnsPrimary := make([]string, len(params))
		copy(paramsDnsPrimary, params)
		stringValDnsPrimary := fmt.Sprintf("%v", *jsonObj.DnsPrimary)
		paramsDnsPrimary = append(paramsDnsPrimary, stringValDnsPrimary)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDnsPrimary", paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-primary"), paramsDnsPrimary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: dns-secondary string
	if jsonObj.DnsSecondary != nil {

		paramsDnsSecondary := make([]string, len(params))
		copy(paramsDnsSecondary, params)
		stringValDnsSecondary := fmt.Sprintf("%v", *jsonObj.DnsSecondary)
		paramsDnsSecondary = append(paramsDnsSecondary, stringValDnsSecondary)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileDnsSecondary", paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/dns-secondary"), paramsDnsSecondary...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: gx-enabled bool
	if jsonObj.GxEnabled != nil {

		paramsGxEnabled := make([]string, len(params))
		copy(paramsGxEnabled, params)
		stringValGxEnabled := fmt.Sprintf("%v", *jsonObj.GxEnabled)
		paramsGxEnabled = append(paramsGxEnabled, stringValGxEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileGxEnabled", paramsGxEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/gx-enabled"), paramsGxEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mtu int32
	if jsonObj.Mtu != nil {

		paramsMtu := make([]string, len(params))
		copy(paramsMtu, params)
		stringValMtu := fmt.Sprintf("%v", *jsonObj.Mtu)
		paramsMtu = append(paramsMtu, stringValMtu)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileMtu", paramsMtu...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mtu"), paramsMtu...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: service-group string
	if jsonObj.ServiceGroup != nil {

		paramsServiceGroup := make([]string, len(params))
		copy(paramsServiceGroup, params)
		stringValServiceGroup := fmt.Sprintf("%v", *jsonObj.ServiceGroup)
		paramsServiceGroup = append(paramsServiceGroup, stringValServiceGroup)
		mpField, err := utils.CreateModelPluginObject(&mp, "ApnProfileApnProfileServiceGroup", paramsServiceGroup...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/service-group"), paramsServiceGroup...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ApnProfileApnProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityService(
	jsonObj *types.ConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service []ConnectivityServiceConnectivityService
	if jsonObj.ConnectivityService != nil {

	}

	// Property: connectivity-service []ConnectivityServiceConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiConnectivityServiceConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiConnectivityServiceConnectivityService converts OAPI to gNMI.
func EncodeToGnmiConnectivityServiceConnectivityService(
	jsonObj *types.ConnectivityServiceConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: hss-endpoint string
	if jsonObj.HssEndpoint != nil {

		paramsHssEndpoint := make([]string, len(params))
		copy(paramsHssEndpoint, params)
		stringValHssEndpoint := fmt.Sprintf("%v", *jsonObj.HssEndpoint)
		paramsHssEndpoint = append(paramsHssEndpoint, stringValHssEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceHssEndpoint", paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/hss-endpoint"), paramsHssEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: pcrf-endpoint string
	if jsonObj.PcrfEndpoint != nil {

		paramsPcrfEndpoint := make([]string, len(params))
		copy(paramsPcrfEndpoint, params)
		stringValPcrfEndpoint := fmt.Sprintf("%v", *jsonObj.PcrfEndpoint)
		paramsPcrfEndpoint = append(paramsPcrfEndpoint, stringValPcrfEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServicePcrfEndpoint", paramsPcrfEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/pcrf-endpoint"), paramsPcrfEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: spgwc-endpoint string
	if jsonObj.SpgwcEndpoint != nil {

		paramsSpgwcEndpoint := make([]string, len(params))
		copy(paramsSpgwcEndpoint, params)
		stringValSpgwcEndpoint := fmt.Sprintf("%v", *jsonObj.SpgwcEndpoint)
		paramsSpgwcEndpoint = append(paramsSpgwcEndpoint, stringValSpgwcEndpoint)
		mpField, err := utils.CreateModelPluginObject(&mp, "ConnectivityServiceConnectivityServiceSpgwcEndpoint", paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/spgwc-endpoint"), paramsSpgwcEndpoint...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ConnectivityServiceConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterprise(
	jsonObj *types.Enterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enterprise []EnterpriseEnterprise
	if jsonObj.Enterprise != nil {

	}

	// Property: enterprise []EnterpriseEnterprise
	if jsonObj.Enterprise != nil {
		for _, item := range *jsonObj.Enterprise {
			item := item //Pinning
			paramsEnterprise := make([]string, len(params))
			copy(paramsEnterprise, params)
			paramsEnterprise = append(paramsEnterprise, "unknown_id")
			updatesEnterprise, err :=
				EncodeToGnmiEnterpriseEnterprise(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "enterprise"), paramsEnterprise...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesEnterprise...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Enterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterprise converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterprise(
	jsonObj *types.EnterpriseEnterprise, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service []EnterpriseEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil {

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: connectivity-service []EnterpriseEnterpriseConnectivityService
	if jsonObj.ConnectivityService != nil {
		for _, item := range *jsonObj.ConnectivityService {
			item := item //Pinning
			paramsConnectivityService := make([]string, len(params))
			copy(paramsConnectivityService, params)
			paramsConnectivityService = append(paramsConnectivityService, "unknown_id")
			updatesConnectivityService, err :=
				EncodeToGnmiEnterpriseEnterpriseConnectivityService(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "connectivity-service"), paramsConnectivityService...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesConnectivityService...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterprise", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiEnterpriseEnterpriseConnectivityService converts OAPI to gNMI.
func EncodeToGnmiEnterpriseEnterpriseConnectivityService(
	jsonObj *types.EnterpriseEnterpriseConnectivityService, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: connectivity-service string
	if jsonObj.ConnectivityService != nil {

		paramsConnectivityService := make([]string, len(params))
		copy(paramsConnectivityService, params)
		stringValConnectivityService := fmt.Sprintf("%v", *jsonObj.ConnectivityService)
		paramsConnectivityService = append(paramsConnectivityService, stringValConnectivityService)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceConnectivityService", paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/connectivity-service"), paramsConnectivityService...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	if jsonObj.Enabled != nil {

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)
		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "EnterpriseEnterpriseConnectivityServiceEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "EnterpriseEnterpriseConnectivityService", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfile converts OAPI to gNMI.
func EncodeToGnmiQosProfile(
	jsonObj *types.QosProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: qos-profile []QosProfileQosProfile
	if jsonObj.QosProfile != nil {

	}

	// Property: qos-profile []QosProfileQosProfile
	if jsonObj.QosProfile != nil {
		for _, item := range *jsonObj.QosProfile {
			item := item //Pinning
			paramsQosProfile := make([]string, len(params))
			copy(paramsQosProfile, params)
			paramsQosProfile = append(paramsQosProfile, "unknown_id")
			updatesQosProfile, err :=
				EncodeToGnmiQosProfileQosProfile(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "qos-profile"), paramsQosProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesQosProfile...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfileQosProfile converts OAPI to gNMI.
func EncodeToGnmiQosProfileQosProfile(
	jsonObj *types.QosProfileQosProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: apn-ambr QosProfileQosProfileApnAmbr
	if jsonObj.ApnAmbr != nil {

		update, err := EncodeToGnmiQosProfileQosProfileApnAmbr(
			jsonObj.ApnAmbr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "apn-ambr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: arp QosProfileQosProfileArp
	if jsonObj.Arp != nil {

		update, err := EncodeToGnmiQosProfileQosProfileArp(
			jsonObj.Arp, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "arp"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qci int32
	if jsonObj.Qci != nil {

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)
		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfileQosProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfileQosProfileApnAmbr converts OAPI to gNMI.
func EncodeToGnmiQosProfileQosProfileApnAmbr(
	jsonObj *types.QosProfileQosProfileApnAmbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int32
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileApnAmbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int32
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileApnAmbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfileQosProfileApnAmbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiQosProfileQosProfileArp converts OAPI to gNMI.
func EncodeToGnmiQosProfileQosProfileArp(
	jsonObj *types.QosProfileQosProfileArp, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: preemption-capability bool
	if jsonObj.PreemptionCapability != nil {

		paramsPreemptionCapability := make([]string, len(params))
		copy(paramsPreemptionCapability, params)
		stringValPreemptionCapability := fmt.Sprintf("%v", *jsonObj.PreemptionCapability)
		paramsPreemptionCapability = append(paramsPreemptionCapability, stringValPreemptionCapability)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileArpPreemptionCapability", paramsPreemptionCapability...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/preemption-capability"), paramsPreemptionCapability...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: preemption-vulnerability bool
	if jsonObj.PreemptionVulnerability != nil {

		paramsPreemptionVulnerability := make([]string, len(params))
		copy(paramsPreemptionVulnerability, params)
		stringValPreemptionVulnerability := fmt.Sprintf("%v", *jsonObj.PreemptionVulnerability)
		paramsPreemptionVulnerability = append(paramsPreemptionVulnerability, stringValPreemptionVulnerability)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileArpPreemptionVulnerability", paramsPreemptionVulnerability...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/preemption-vulnerability"), paramsPreemptionVulnerability...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: priority int32
	if jsonObj.Priority != nil {

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)
		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "QosProfileQosProfileArpPriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "QosProfileQosProfileArp", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSecurityProfile converts OAPI to gNMI.
func EncodeToGnmiSecurityProfile(
	jsonObj *types.SecurityProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: security-profile []SecurityProfileSecurityProfile
	if jsonObj.SecurityProfile != nil {

	}

	// Property: security-profile []SecurityProfileSecurityProfile
	if jsonObj.SecurityProfile != nil {
		for _, item := range *jsonObj.SecurityProfile {
			item := item //Pinning
			paramsSecurityProfile := make([]string, len(params))
			copy(paramsSecurityProfile, params)
			paramsSecurityProfile = append(paramsSecurityProfile, "unknown_id")
			updatesSecurityProfile, err :=
				EncodeToGnmiSecurityProfileSecurityProfile(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "security-profile"), paramsSecurityProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesSecurityProfile...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SecurityProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSecurityProfileSecurityProfile converts OAPI to gNMI.
func EncodeToGnmiSecurityProfileSecurityProfile(
	jsonObj *types.SecurityProfileSecurityProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: key string
	if jsonObj.Key != nil {

		paramsKey := make([]string, len(params))
		copy(paramsKey, params)
		stringValKey := fmt.Sprintf("%v", *jsonObj.Key)
		paramsKey = append(paramsKey, stringValKey)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileKey", paramsKey...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/key"), paramsKey...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: opc string
	if jsonObj.Opc != nil {

		paramsOpc := make([]string, len(params))
		copy(paramsOpc, params)
		stringValOpc := fmt.Sprintf("%v", *jsonObj.Opc)
		paramsOpc = append(paramsOpc, stringValOpc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileOpc", paramsOpc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/opc"), paramsOpc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: sqn int32
	if jsonObj.Sqn != nil {

		paramsSqn := make([]string, len(params))
		copy(paramsSqn, params)
		stringValSqn := fmt.Sprintf("%v", *jsonObj.Sqn)
		paramsSqn = append(paramsSqn, stringValSqn)
		mpField, err := utils.CreateModelPluginObject(&mp, "SecurityProfileSecurityProfileSqn", paramsSqn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/sqn"), paramsSqn...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SecurityProfileSecurityProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceGroup converts OAPI to gNMI.
func EncodeToGnmiServiceGroup(
	jsonObj *types.ServiceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: service-group []ServiceGroupServiceGroup
	if jsonObj.ServiceGroup != nil {

	}

	// Property: service-group []ServiceGroupServiceGroup
	if jsonObj.ServiceGroup != nil {
		for _, item := range *jsonObj.ServiceGroup {
			item := item //Pinning
			paramsServiceGroup := make([]string, len(params))
			copy(paramsServiceGroup, params)
			paramsServiceGroup = append(paramsServiceGroup, "unknown_id")
			updatesServiceGroup, err :=
				EncodeToGnmiServiceGroupServiceGroup(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "service-group"), paramsServiceGroup...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesServiceGroup...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceGroupServiceGroup converts OAPI to gNMI.
func EncodeToGnmiServiceGroupServiceGroup(
	jsonObj *types.ServiceGroupServiceGroup, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceGroupServiceGroupDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceGroupServiceGroupDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceGroupServiceGroupId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: service-policies []ServiceGroupServiceGroupServicePolicies
	if jsonObj.ServicePolicies != nil {

	}

	// Property: service-policies []ServiceGroupServiceGroupServicePolicies
	if jsonObj.ServicePolicies != nil {
		for _, item := range *jsonObj.ServicePolicies {
			item := item //Pinning
			paramsServicePolicies := make([]string, len(params))
			copy(paramsServicePolicies, params)
			paramsServicePolicies = append(paramsServicePolicies, "unknown_id")
			updatesServicePolicies, err :=
				EncodeToGnmiServiceGroupServiceGroupServicePolicies(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "service-policies"), paramsServicePolicies...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesServicePolicies...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceGroupServiceGroup", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceGroupServiceGroupServicePolicies converts OAPI to gNMI.
func EncodeToGnmiServiceGroupServiceGroupServicePolicies(
	jsonObj *types.ServiceGroupServiceGroupServicePolicies, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: kind string
	if jsonObj.Kind != nil {

		paramsKind := make([]string, len(params))
		copy(paramsKind, params)
		stringValKind := fmt.Sprintf("%v", *jsonObj.Kind)
		paramsKind = append(paramsKind, stringValKind)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceGroupServiceGroupServicePoliciesKind", paramsKind...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/kind"), paramsKind...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: service-policy string
	if jsonObj.ServicePolicy != nil {

		paramsServicePolicy := make([]string, len(params))
		copy(paramsServicePolicy, params)
		stringValServicePolicy := fmt.Sprintf("%v", *jsonObj.ServicePolicy)
		paramsServicePolicy = append(paramsServicePolicy, stringValServicePolicy)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceGroupServiceGroupServicePoliciesServicePolicy", paramsServicePolicy...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/service-policy"), paramsServicePolicy...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceGroupServiceGroupServicePolicies", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServicePolicy converts OAPI to gNMI.
func EncodeToGnmiServicePolicy(
	jsonObj *types.ServicePolicy, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: service-policy []ServicePolicyServicePolicy
	if jsonObj.ServicePolicy != nil {

	}

	// Property: service-policy []ServicePolicyServicePolicy
	if jsonObj.ServicePolicy != nil {
		for _, item := range *jsonObj.ServicePolicy {
			item := item //Pinning
			paramsServicePolicy := make([]string, len(params))
			copy(paramsServicePolicy, params)
			paramsServicePolicy = append(paramsServicePolicy, "unknown_id")
			updatesServicePolicy, err :=
				EncodeToGnmiServicePolicyServicePolicy(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "service-policy"), paramsServicePolicy...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesServicePolicy...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServicePolicy", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServicePolicyServicePolicy converts OAPI to gNMI.
func EncodeToGnmiServicePolicyServicePolicy(
	jsonObj *types.ServicePolicyServicePolicy, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: ambr ServicePolicyServicePolicyAmbr
	if jsonObj.Ambr != nil {

		update, err := EncodeToGnmiServicePolicyServicePolicyAmbr(
			jsonObj.Ambr, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "ambr"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: arp int32
	if jsonObj.Arp != nil {

		paramsArp := make([]string, len(params))
		copy(paramsArp, params)
		stringValArp := fmt.Sprintf("%v", *jsonObj.Arp)
		paramsArp = append(paramsArp, stringValArp)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyArp", paramsArp...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/arp"), paramsArp...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qci int32
	if jsonObj.Qci != nil {

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)
		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: rules []ServicePolicyServicePolicyRules
	if jsonObj.Rules != nil {

	}

	// Property: rules []ServicePolicyServicePolicyRules
	if jsonObj.Rules != nil {
		for _, item := range *jsonObj.Rules {
			item := item //Pinning
			paramsRules := make([]string, len(params))
			copy(paramsRules, params)
			paramsRules = append(paramsRules, "unknown_id")
			updatesRules, err :=
				EncodeToGnmiServicePolicyServicePolicyRules(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "rules"), paramsRules...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesRules...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServicePolicyServicePolicy", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServicePolicyServicePolicyAmbr converts OAPI to gNMI.
func EncodeToGnmiServicePolicyServicePolicyAmbr(
	jsonObj *types.ServicePolicyServicePolicyAmbr, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int32
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyAmbrDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int32
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyAmbrUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServicePolicyServicePolicyAmbr", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServicePolicyServicePolicyRules converts OAPI to gNMI.
func EncodeToGnmiServicePolicyServicePolicyRules(
	jsonObj *types.ServicePolicyServicePolicyRules, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: enabled bool
	if jsonObj.Enabled != nil {

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)
		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyRulesEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: rule string
	if jsonObj.Rule != nil {

		paramsRule := make([]string, len(params))
		copy(paramsRule, params)
		stringValRule := fmt.Sprintf("%v", *jsonObj.Rule)
		paramsRule = append(paramsRule, stringValRule)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServicePolicyServicePolicyRulesRule", paramsRule...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/rule"), paramsRule...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServicePolicyServicePolicyRules", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRule converts OAPI to gNMI.
func EncodeToGnmiServiceRule(
	jsonObj *types.ServiceRule, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: service-rule []ServiceRuleServiceRule
	if jsonObj.ServiceRule != nil {

	}

	// Property: service-rule []ServiceRuleServiceRule
	if jsonObj.ServiceRule != nil {
		for _, item := range *jsonObj.ServiceRule {
			item := item //Pinning
			paramsServiceRule := make([]string, len(params))
			copy(paramsServiceRule, params)
			paramsServiceRule = append(paramsServiceRule, "unknown_id")
			updatesServiceRule, err :=
				EncodeToGnmiServiceRuleServiceRule(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "service-rule"), paramsServiceRule...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesServiceRule...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRule", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRuleServiceRule converts OAPI to gNMI.
func EncodeToGnmiServiceRuleServiceRule(
	jsonObj *types.ServiceRuleServiceRule, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: charging-rule-name string
	if jsonObj.ChargingRuleName != nil {

		paramsChargingRuleName := make([]string, len(params))
		copy(paramsChargingRuleName, params)
		stringValChargingRuleName := fmt.Sprintf("%v", *jsonObj.ChargingRuleName)
		paramsChargingRuleName = append(paramsChargingRuleName, stringValChargingRuleName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleChargingRuleName", paramsChargingRuleName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/charging-rule-name"), paramsChargingRuleName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: flow ServiceRuleServiceRuleFlow
	if jsonObj.Flow != nil {

		update, err := EncodeToGnmiServiceRuleServiceRuleFlow(
			jsonObj.Flow, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "flow"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qos ServiceRuleServiceRuleQos
	if jsonObj.Qos != nil {

		update, err := EncodeToGnmiServiceRuleServiceRuleQos(
			jsonObj.Qos, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "qos"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRuleServiceRule", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRuleServiceRuleFlow converts OAPI to gNMI.
func EncodeToGnmiServiceRuleServiceRuleFlow(
	jsonObj *types.ServiceRuleServiceRuleFlow, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: specification string
	if jsonObj.Specification != nil {

		paramsSpecification := make([]string, len(params))
		copy(paramsSpecification, params)
		stringValSpecification := fmt.Sprintf("%v", *jsonObj.Specification)
		paramsSpecification = append(paramsSpecification, stringValSpecification)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleFlowSpecification", paramsSpecification...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/specification"), paramsSpecification...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRuleServiceRuleFlow", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRuleServiceRuleQos converts OAPI to gNMI.
func EncodeToGnmiServiceRuleServiceRuleQos(
	jsonObj *types.ServiceRuleServiceRuleQos, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: aggregate-maximum-bitrate ServiceRuleServiceRuleQosAggregateMaximumBitrate
	if jsonObj.AggregateMaximumBitrate != nil {

		update, err := EncodeToGnmiServiceRuleServiceRuleQosAggregateMaximumBitrate(
			jsonObj.AggregateMaximumBitrate, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "aggregate-maximum-bitrate"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: arp ServiceRuleServiceRuleQosArp
	if jsonObj.Arp != nil {

		update, err := EncodeToGnmiServiceRuleServiceRuleQosArp(
			jsonObj.Arp, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "arp"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: guaranteed-bitrate ServiceRuleServiceRuleQosGuaranteedBitrate
	if jsonObj.GuaranteedBitrate != nil {

		update, err := EncodeToGnmiServiceRuleServiceRuleQosGuaranteedBitrate(
			jsonObj.GuaranteedBitrate, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "guaranteed-bitrate"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: maximum-requested-bandwidth ServiceRuleServiceRuleQosMaximumRequestedBandwidth
	if jsonObj.MaximumRequestedBandwidth != nil {

		update, err := EncodeToGnmiServiceRuleServiceRuleQosMaximumRequestedBandwidth(
			jsonObj.MaximumRequestedBandwidth, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "maximum-requested-bandwidth"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: qci int32
	if jsonObj.Qci != nil {

		paramsQci := make([]string, len(params))
		copy(paramsQci, params)
		stringValQci := fmt.Sprintf("%v", *jsonObj.Qci)
		paramsQci = append(paramsQci, stringValQci)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosQci", paramsQci...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qci"), paramsQci...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRuleServiceRuleQos", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRuleServiceRuleQosAggregateMaximumBitrate converts OAPI to gNMI.
func EncodeToGnmiServiceRuleServiceRuleQosAggregateMaximumBitrate(
	jsonObj *types.ServiceRuleServiceRuleQosAggregateMaximumBitrate, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int32
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosAggregateMaximumBitrateDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int32
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosAggregateMaximumBitrateUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRuleServiceRuleQosAggregateMaximumBitrate", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRuleServiceRuleQosArp converts OAPI to gNMI.
func EncodeToGnmiServiceRuleServiceRuleQosArp(
	jsonObj *types.ServiceRuleServiceRuleQosArp, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: preemption-capability bool
	if jsonObj.PreemptionCapability != nil {

		paramsPreemptionCapability := make([]string, len(params))
		copy(paramsPreemptionCapability, params)
		stringValPreemptionCapability := fmt.Sprintf("%v", *jsonObj.PreemptionCapability)
		paramsPreemptionCapability = append(paramsPreemptionCapability, stringValPreemptionCapability)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosArpPreemptionCapability", paramsPreemptionCapability...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/preemption-capability"), paramsPreemptionCapability...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: preemption-vulnerability bool
	if jsonObj.PreemptionVulnerability != nil {

		paramsPreemptionVulnerability := make([]string, len(params))
		copy(paramsPreemptionVulnerability, params)
		stringValPreemptionVulnerability := fmt.Sprintf("%v", *jsonObj.PreemptionVulnerability)
		paramsPreemptionVulnerability = append(paramsPreemptionVulnerability, stringValPreemptionVulnerability)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosArpPreemptionVulnerability", paramsPreemptionVulnerability...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/preemption-vulnerability"), paramsPreemptionVulnerability...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: priority int32
	if jsonObj.Priority != nil {

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)
		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosArpPriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRuleServiceRuleQosArp", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRuleServiceRuleQosGuaranteedBitrate converts OAPI to gNMI.
func EncodeToGnmiServiceRuleServiceRuleQosGuaranteedBitrate(
	jsonObj *types.ServiceRuleServiceRuleQosGuaranteedBitrate, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int32
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosGuaranteedBitrateDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int32
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosGuaranteedBitrateUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRuleServiceRuleQosGuaranteedBitrate", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiServiceRuleServiceRuleQosMaximumRequestedBandwidth converts OAPI to gNMI.
func EncodeToGnmiServiceRuleServiceRuleQosMaximumRequestedBandwidth(
	jsonObj *types.ServiceRuleServiceRuleQosMaximumRequestedBandwidth, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: downlink int32
	if jsonObj.Downlink != nil {

		paramsDownlink := make([]string, len(params))
		copy(paramsDownlink, params)
		stringValDownlink := fmt.Sprintf("%v", *jsonObj.Downlink)
		paramsDownlink = append(paramsDownlink, stringValDownlink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosMaximumRequestedBandwidthDownlink", paramsDownlink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/downlink"), paramsDownlink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: uplink int32
	if jsonObj.Uplink != nil {

		paramsUplink := make([]string, len(params))
		copy(paramsUplink, params)
		stringValUplink := fmt.Sprintf("%v", *jsonObj.Uplink)
		paramsUplink = append(paramsUplink, stringValUplink)
		mpField, err := utils.CreateModelPluginObject(&mp, "ServiceRuleServiceRuleQosMaximumRequestedBandwidthUplink", paramsUplink...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/uplink"), paramsUplink...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "ServiceRuleServiceRuleQosMaximumRequestedBandwidth", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriber converts OAPI to gNMI.
func EncodeToGnmiSubscriber(
	jsonObj *types.Subscriber, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: ue []SubscriberUe
	if jsonObj.Ue != nil {

	}

	// Property: ue []SubscriberUe
	if jsonObj.Ue != nil {
		for _, item := range *jsonObj.Ue {
			item := item //Pinning
			paramsUe := make([]string, len(params))
			copy(paramsUe, params)
			paramsUe = append(paramsUe, "unknown_id")
			updatesUe, err :=
				EncodeToGnmiSubscriberUe(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "ue"), paramsUe...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesUe...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "Subscriber", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUe converts OAPI to gNMI.
func EncodeToGnmiSubscriberUe(
	jsonObj *types.SubscriberUe, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enabled bool
	if jsonObj.Enabled != nil {

		paramsEnabled := make([]string, len(params))
		copy(paramsEnabled, params)
		stringValEnabled := fmt.Sprintf("%v", *jsonObj.Enabled)
		paramsEnabled = append(paramsEnabled, stringValEnabled)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeEnabled", paramsEnabled...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enabled"), paramsEnabled...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: enterprise string
	if jsonObj.Enterprise != nil {

		paramsEnterprise := make([]string, len(params))
		copy(paramsEnterprise, params)
		stringValEnterprise := fmt.Sprintf("%v", *jsonObj.Enterprise)
		paramsEnterprise = append(paramsEnterprise, stringValEnterprise)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeEnterprise", paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/enterprise"), paramsEnterprise...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-range-from int64
	if jsonObj.ImsiRangeFrom != nil {

		paramsImsiRangeFrom := make([]string, len(params))
		copy(paramsImsiRangeFrom, params)
		stringValImsiRangeFrom := fmt.Sprintf("%v", *jsonObj.ImsiRangeFrom)
		paramsImsiRangeFrom = append(paramsImsiRangeFrom, stringValImsiRangeFrom)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeImsiRangeFrom", paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-from"), paramsImsiRangeFrom...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-range-to int64
	if jsonObj.ImsiRangeTo != nil {

		paramsImsiRangeTo := make([]string, len(params))
		copy(paramsImsiRangeTo, params)
		stringValImsiRangeTo := fmt.Sprintf("%v", *jsonObj.ImsiRangeTo)
		paramsImsiRangeTo = append(paramsImsiRangeTo, stringValImsiRangeTo)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeImsiRangeTo", paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-range-to"), paramsImsiRangeTo...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: imsi-wildcard string
	if jsonObj.ImsiWildcard != nil {

		paramsImsiWildcard := make([]string, len(params))
		copy(paramsImsiWildcard, params)
		stringValImsiWildcard := fmt.Sprintf("%v", *jsonObj.ImsiWildcard)
		paramsImsiWildcard = append(paramsImsiWildcard, stringValImsiWildcard)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeImsiWildcard", paramsImsiWildcard...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/imsi-wildcard"), paramsImsiWildcard...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: priority int32
	if jsonObj.Priority != nil {

		paramsPriority := make([]string, len(params))
		copy(paramsPriority, params)
		stringValPriority := fmt.Sprintf("%v", *jsonObj.Priority)
		paramsPriority = append(paramsPriority, stringValPriority)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUePriority", paramsPriority...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/priority"), paramsPriority...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: profiles SubscriberUeProfiles
	if jsonObj.Profiles != nil {

		update, err := EncodeToGnmiSubscriberUeProfiles(
			jsonObj.Profiles, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "profiles"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}
	// Property: requested-apn string
	if jsonObj.RequestedApn != nil {

		paramsRequestedApn := make([]string, len(params))
		copy(paramsRequestedApn, params)
		stringValRequestedApn := fmt.Sprintf("%v", *jsonObj.RequestedApn)
		paramsRequestedApn = append(paramsRequestedApn, stringValRequestedApn)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeRequestedApn", paramsRequestedApn...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/requested-apn"), paramsRequestedApn...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: serving-plmn SubscriberUeServingPlmn
	if jsonObj.ServingPlmn != nil {

		update, err := EncodeToGnmiSubscriberUeServingPlmn(
			jsonObj.ServingPlmn, false, removeIndex, target,
			fmt.Sprintf("%s/%s", parentPath, "serving-plmn"), params...)
		if err != nil {
			return nil, err
		}
		updates = append(updates, update...)
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUe", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUeProfiles converts OAPI to gNMI.
func EncodeToGnmiSubscriberUeProfiles(
	jsonObj *types.SubscriberUeProfiles, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: access-profile []SubscriberUeProfilesAccessProfile
	if jsonObj.AccessProfile != nil {

	}
	// Property: apn-profile string
	if jsonObj.ApnProfile != nil {

		paramsApnProfile := make([]string, len(params))
		copy(paramsApnProfile, params)
		stringValApnProfile := fmt.Sprintf("%v", *jsonObj.ApnProfile)
		paramsApnProfile = append(paramsApnProfile, stringValApnProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesApnProfile", paramsApnProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/apn-profile"), paramsApnProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: qos-profile string
	if jsonObj.QosProfile != nil {

		paramsQosProfile := make([]string, len(params))
		copy(paramsQosProfile, params)
		stringValQosProfile := fmt.Sprintf("%v", *jsonObj.QosProfile)
		paramsQosProfile = append(paramsQosProfile, stringValQosProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesQosProfile", paramsQosProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/qos-profile"), paramsQosProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: security-profile string
	if jsonObj.SecurityProfile != nil {

		paramsSecurityProfile := make([]string, len(params))
		copy(paramsSecurityProfile, params)
		stringValSecurityProfile := fmt.Sprintf("%v", *jsonObj.SecurityProfile)
		paramsSecurityProfile = append(paramsSecurityProfile, stringValSecurityProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesSecurityProfile", paramsSecurityProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/security-profile"), paramsSecurityProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: up-profile string
	if jsonObj.UpProfile != nil {

		paramsUpProfile := make([]string, len(params))
		copy(paramsUpProfile, params)
		stringValUpProfile := fmt.Sprintf("%v", *jsonObj.UpProfile)
		paramsUpProfile = append(paramsUpProfile, stringValUpProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesUpProfile", paramsUpProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/up-profile"), paramsUpProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	// Property: access-profile []SubscriberUeProfilesAccessProfile
	if jsonObj.AccessProfile != nil {
		for _, item := range *jsonObj.AccessProfile {
			item := item //Pinning
			paramsAccessProfile := make([]string, len(params))
			copy(paramsAccessProfile, params)
			paramsAccessProfile = append(paramsAccessProfile, "unknown_id")
			updatesAccessProfile, err :=
				EncodeToGnmiSubscriberUeProfilesAccessProfile(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "access-profile"), paramsAccessProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesAccessProfile...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUeProfiles", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUeProfilesAccessProfile converts OAPI to gNMI.
func EncodeToGnmiSubscriberUeProfilesAccessProfile(
	jsonObj *types.SubscriberUeProfilesAccessProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: access-profile string
	if jsonObj.AccessProfile != nil {

		paramsAccessProfile := make([]string, len(params))
		copy(paramsAccessProfile, params)
		stringValAccessProfile := fmt.Sprintf("%v", *jsonObj.AccessProfile)
		paramsAccessProfile = append(paramsAccessProfile, stringValAccessProfile)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesAccessProfileAccessProfile", paramsAccessProfile...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/access-profile"), paramsAccessProfile...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: allowed bool
	if jsonObj.Allowed != nil {

		paramsAllowed := make([]string, len(params))
		copy(paramsAllowed, params)
		stringValAllowed := fmt.Sprintf("%v", *jsonObj.Allowed)
		paramsAllowed = append(paramsAllowed, stringValAllowed)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeProfilesAccessProfileAllowed", paramsAllowed...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/allowed"), paramsAllowed...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUeProfilesAccessProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiSubscriberUeServingPlmn converts OAPI to gNMI.
func EncodeToGnmiSubscriberUeServingPlmn(
	jsonObj *types.SubscriberUeServingPlmn, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: mcc int32
	if jsonObj.Mcc != nil {

		paramsMcc := make([]string, len(params))
		copy(paramsMcc, params)
		stringValMcc := fmt.Sprintf("%v", *jsonObj.Mcc)
		paramsMcc = append(paramsMcc, stringValMcc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeServingPlmnMcc", paramsMcc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mcc"), paramsMcc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: mnc int32
	if jsonObj.Mnc != nil {

		paramsMnc := make([]string, len(params))
		copy(paramsMnc, params)
		stringValMnc := fmt.Sprintf("%v", *jsonObj.Mnc)
		paramsMnc = append(paramsMnc, stringValMnc)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeServingPlmnMnc", paramsMnc...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/mnc"), paramsMnc...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: tac int32
	if jsonObj.Tac != nil {

		paramsTac := make([]string, len(params))
		copy(paramsTac, params)
		stringValTac := fmt.Sprintf("%v", *jsonObj.Tac)
		paramsTac = append(paramsTac, stringValTac)
		mpField, err := utils.CreateModelPluginObject(&mp, "SubscriberUeServingPlmnTac", paramsTac...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/tac"), paramsTac...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "SubscriberUeServingPlmn", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiUpProfile converts OAPI to gNMI.
func EncodeToGnmiUpProfile(
	jsonObj *types.UpProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: up-profile []UpProfileUpProfile
	if jsonObj.UpProfile != nil {

	}

	// Property: up-profile []UpProfileUpProfile
	if jsonObj.UpProfile != nil {
		for _, item := range *jsonObj.UpProfile {
			item := item //Pinning
			paramsUpProfile := make([]string, len(params))
			copy(paramsUpProfile, params)
			paramsUpProfile = append(paramsUpProfile, "unknown_id")
			updatesUpProfile, err :=
				EncodeToGnmiUpProfileUpProfile(&item, true, removeIndex, target,
					fmt.Sprintf("%s/%s/{unknown_key}", parentPath, "up-profile"), paramsUpProfile...)
			if err != nil {
				return nil, err
			}
			updates = append(updates, updatesUpProfile...)
		}
	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "UpProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

// EncodeToGnmiUpProfileUpProfile converts OAPI to gNMI.
func EncodeToGnmiUpProfileUpProfile(
	jsonObj *types.UpProfileUpProfile, needKey bool, removeIndex bool, target types.Target, parentPath string, params ...string) (
	[]*gnmi.Update, error) {

	for _, v := range jsonObj.AdditionalProperties { // Map entry could be called anything e.g. "1" or "additional-properties"
		if v.Target != nil {
			target = types.Target(*v.Target)
		}
	}

	updates := make([]*gnmi.Update, 0)
	mp := externalRef0.Device{}
	// For when the encode is called on the top level object
	if len(params) == 1 && strings.HasSuffix(parentPath, params[0]) {
		parentPath = strings.Replace(parentPath, params[0], fmt.Sprintf("{%s}", params[0]), 1)
	}

	// Property: access-control string
	if jsonObj.AccessControl != nil {

		paramsAccessControl := make([]string, len(params))
		copy(paramsAccessControl, params)
		stringValAccessControl := fmt.Sprintf("%v", *jsonObj.AccessControl)
		paramsAccessControl = append(paramsAccessControl, stringValAccessControl)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileAccessControl", paramsAccessControl...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/access-control"), paramsAccessControl...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: description string
	if jsonObj.Description != nil {

		paramsDescription := make([]string, len(params))
		copy(paramsDescription, params)
		stringValDescription := fmt.Sprintf("%v", *jsonObj.Description)
		paramsDescription = append(paramsDescription, stringValDescription)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileDescription", paramsDescription...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/description"), paramsDescription...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: display-name string
	if jsonObj.DisplayName != nil {

		paramsDisplayName := make([]string, len(params))
		copy(paramsDisplayName, params)
		stringValDisplayName := fmt.Sprintf("%v", *jsonObj.DisplayName)
		paramsDisplayName = append(paramsDisplayName, stringValDisplayName)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileDisplayName", paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/display-name"), paramsDisplayName...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: id string
	if jsonObj.Id != nil {

		paramsId := make([]string, len(params))
		copy(paramsId, params)
		stringValId := fmt.Sprintf("%v", *jsonObj.Id)
		paramsId = append(paramsId, stringValId)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileId", paramsId...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/id"), paramsId...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}
	// Property: user-plane string
	if jsonObj.UserPlane != nil {

		paramsUserPlane := make([]string, len(params))
		copy(paramsUserPlane, params)
		stringValUserPlane := fmt.Sprintf("%v", *jsonObj.UserPlane)
		paramsUserPlane = append(paramsUserPlane, stringValUserPlane)
		mpField, err := utils.CreateModelPluginObject(&mp, "UpProfileUpProfileUserPlane", paramsUserPlane...)
		if err != nil {
			return nil, err
		}
		update, err := utils.UpdateForElement(mpField, fmt.Sprintf("%s%s", parentPath, "/user-plane"), paramsUserPlane...)
		if err != nil {
			return nil, err
		}
		if target != "" {
			update.Path.Target = string(target)
		}
		updates = append(updates, update)

	}

	if needKey || removeIndex {
		reflectKey, err := utils.FindModelPluginObject(mp, "UpProfileUpProfile", params...)
		if err != nil {
			return nil, err
		}
		if reflectKey == nil {
			return updates, nil
		}
		reflectType := reflectKey.Type()
		reflect2 := reflect.New(reflectType) // Needed so the type can be read to extract list
		reflect2.Elem().Set(*reflectKey)
		keyMap, err := utils.ExtractGnmiListKeyMap(reflect2.Interface())
		if err != nil {
			return nil, err
		}
		indices := make([]int, 0)
		for k, v := range keyMap {
			// parentPath = fmt.Sprintf("%s/{%s}", parentPath, k)
			for i, u := range updates {
				if needKey {
					if err := utils.ReplaceUnknownKey(u, k, v, utils.UnknownKey, utils.UnknownID); err != nil {
						return nil, err
					}
				}
				if removeIndex {
					lastElem := u.Path.Elem[len(u.Path.Elem)-1]
					if k == lastElem.Name {
						indices = append(indices, i)
					}
				}
			}
		}
		// Only remove the index field if it's not the only field
		if removeIndex && len(indices) > 0 && len(updates) > 1 {
			updates = utils.RemoveIndexAttributes(updates, indices)
		}
	}
	return updates, nil
}

//Ignoring Target

//Ignoring RequestBodyAccessProfile

//Ignoring RequestBodyAccessProfileAccessProfile

//Ignoring RequestBodyApnProfile

//Ignoring RequestBodyApnProfileApnProfile

//Ignoring RequestBodyConnectivityService

//Ignoring RequestBodyConnectivityServiceConnectivityService

//Ignoring RequestBodyEnterprise

//Ignoring RequestBodyEnterpriseEnterprise

//Ignoring RequestBodyEnterpriseEnterpriseConnectivityService

//Ignoring RequestBodyQosProfile

//Ignoring RequestBodyQosProfileQosProfile

//Ignoring RequestBodyQosProfileQosProfileApnAmbr

//Ignoring RequestBodyQosProfileQosProfileArp

//Ignoring RequestBodySecurityProfile

//Ignoring RequestBodySecurityProfileSecurityProfile

//Ignoring RequestBodyServiceGroup

//Ignoring RequestBodyServiceGroupServiceGroup

//Ignoring RequestBodyServiceGroupServiceGroupServicePolicies

//Ignoring RequestBodyServicePolicy

//Ignoring RequestBodyServicePolicyServicePolicy

//Ignoring RequestBodyServicePolicyServicePolicyAmbr

//Ignoring RequestBodyServicePolicyServicePolicyRules

//Ignoring RequestBodyServiceRule

//Ignoring RequestBodyServiceRuleServiceRule

//Ignoring RequestBodyServiceRuleServiceRuleFlow

//Ignoring RequestBodyServiceRuleServiceRuleQos

//Ignoring RequestBodyServiceRuleServiceRuleQosAggregateMaximumBitrate

//Ignoring RequestBodyServiceRuleServiceRuleQosArp

//Ignoring RequestBodyServiceRuleServiceRuleQosGuaranteedBitrate

//Ignoring RequestBodyServiceRuleServiceRuleQosMaximumRequestedBandwidth

//Ignoring RequestBodySubscriber

//Ignoring RequestBodySubscriberUe

//Ignoring RequestBodySubscriberUeProfiles

//Ignoring RequestBodySubscriberUeProfilesAccessProfile

//Ignoring RequestBodySubscriberUeServingPlmn

//Ignoring RequestBodyUpProfile

//Ignoring RequestBodyUpProfileUpProfile

// Not generating param-types
// Not generating request-bodies

// Not generating additional-properties
// Not generating additional-properties
